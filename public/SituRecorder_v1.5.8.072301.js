(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SituRecorder = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	function createMetadataMethodsForProperty(metadataMap, kind, property) {
	  return {
	    getMetadata: function (key) {
	      if ("symbol" != typeof key) throw new TypeError("Metadata keys must be symbols, received: " + key);
	      var metadataForKey = metadataMap[key];
	      if (void 0 !== metadataForKey) if (1 === kind) {
	        var pub = metadataForKey.public;
	        if (void 0 !== pub) return pub[property];
	      } else if (2 === kind) {
	        var priv = metadataForKey.private;
	        if (void 0 !== priv) return priv.get(property);
	      } else if (Object.hasOwnProperty.call(metadataForKey, "constructor")) return metadataForKey.constructor;
	    },
	    setMetadata: function (key, value) {
	      if ("symbol" != typeof key) throw new TypeError("Metadata keys must be symbols, received: " + key);
	      var metadataForKey = metadataMap[key];

	      if (void 0 === metadataForKey && (metadataForKey = metadataMap[key] = {}), 1 === kind) {
	        var pub = metadataForKey.public;
	        void 0 === pub && (pub = metadataForKey.public = {}), pub[property] = value;
	      } else if (2 === kind) {
	        var priv = metadataForKey.priv;
	        void 0 === priv && (priv = metadataForKey.private = new Map()), priv.set(property, value);
	      } else metadataForKey.constructor = value;
	    }
	  };
	}

	function convertMetadataMapToFinal(obj, metadataMap) {
	  var parentMetadataMap = obj[Symbol.metadata || Symbol.for("Symbol.metadata")],
	      metadataKeys = Object.getOwnPropertySymbols(metadataMap);

	  if (0 !== metadataKeys.length) {
	    for (var i = 0; i < metadataKeys.length; i++) {
	      var key = metadataKeys[i],
	          metaForKey = metadataMap[key],
	          parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null,
	          pub = metaForKey.public,
	          parentPub = parentMetaForKey ? parentMetaForKey.public : null;
	      pub && parentPub && Object.setPrototypeOf(pub, parentPub);
	      var priv = metaForKey.private;

	      if (priv) {
	        var privArr = Array.from(priv.values()),
	            parentPriv = parentMetaForKey ? parentMetaForKey.private : null;
	        parentPriv && (privArr = privArr.concat(parentPriv)), metaForKey.private = privArr;
	      }

	      parentMetaForKey && Object.setPrototypeOf(metaForKey, parentMetaForKey);
	    }

	    parentMetadataMap && Object.setPrototypeOf(metadataMap, parentMetadataMap), obj[Symbol.metadata || Symbol.for("Symbol.metadata")] = metadataMap;
	  }
	}

	function createAddInitializerMethod(initializers) {
	  return function (initializer) {
	    assertValidInitializer(initializer), initializers.push(initializer);
	  };
	}

	function memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate) {
	  var kindStr;

	  switch (kind) {
	    case 1:
	      kindStr = "accessor";
	      break;

	    case 2:
	      kindStr = "method";
	      break;

	    case 3:
	      kindStr = "getter";
	      break;

	    case 4:
	      kindStr = "setter";
	      break;

	    default:
	      kindStr = "field";
	  }

	  var metadataKind,
	      metadataName,
	      ctx = {
	    kind: kindStr,
	    name: isPrivate ? "#" + name : name,
	    isStatic: isStatic,
	    isPrivate: isPrivate
	  };

	  if (0 !== kind && (ctx.addInitializer = createAddInitializerMethod(initializers)), isPrivate) {
	    metadataKind = 2, metadataName = Symbol(name);
	    var access = {};
	    0 === kind ? (access.get = desc.get, access.set = desc.set) : 2 === kind ? access.get = function () {
	      return desc.value;
	    } : (1 !== kind && 3 !== kind || (access.get = function () {
	      return desc.get.call(this);
	    }), 1 !== kind && 4 !== kind || (access.set = function (v) {
	      desc.set.call(this, v);
	    })), ctx.access = access;
	  } else metadataKind = 1, metadataName = name;

	  return Object.assign(ctx, createMetadataMethodsForProperty(metadataMap, metadataKind, metadataName));
	}

	function assertValidInitializer(initializer) {
	  if ("function" != typeof initializer) throw new Error("initializers must be functions");
	}

	function assertValidReturnValue(kind, value) {
	  var type = typeof value;

	  if (1 === kind) {
	    if ("object" !== type || null === value) throw new Error("accessor decorators must return an object with get, set, or initializer properties or void 0");
	  } else if ("function" !== type) throw 0 === kind ? new Error("field decorators must return a initializer function or void 0") : new Error("method decorators must return a function or void 0");
	}

	function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {
	  var desc,
	      initializer,
	      value,
	      decs = decInfo[0];
	  isPrivate ? desc = 0 === kind || 1 === kind ? {
	    get: decInfo[3],
	    set: decInfo[4]
	  } : 3 === kind ? {
	    get: decInfo[3]
	  } : 4 === kind ? {
	    set: decInfo[3]
	  } : {
	    value: decInfo[3]
	  } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {
	    get: desc.get,
	    set: desc.set
	  } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set);
	  var newValue,
	      get,
	      set,
	      ctx = memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate);
	  if ("function" == typeof decs) void 0 !== (newValue = decs(value, ctx)) && (assertValidReturnValue(kind, newValue), 0 === kind ? initializer = newValue : 1 === kind ? (initializer = newValue.initializer, get = newValue.get || value.get, set = newValue.set || value.set, value = {
	    get: get,
	    set: set
	  }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {
	    var newInit;
	    if (void 0 !== (newValue = (0, decs[i])(value, ctx))) assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.initializer, get = newValue.get || value.get, set = newValue.set || value.set, value = {
	      get: get,
	      set: set
	    }) : value = newValue, void 0 !== newInit && (void 0 === initializer ? initializer = newInit : "function" == typeof initializer ? initializer = [initializer, newInit] : initializer.push(newInit));
	  }

	  if (0 === kind || 1 === kind) {
	    if (void 0 === initializer) initializer = function (instance, init) {
	      return init;
	    };else if ("function" != typeof initializer) {
	      var ownInitializers = initializer;

	      initializer = function (instance, init) {
	        for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);

	        return value;
	      };
	    } else {
	      var originalInitializer = initializer;

	      initializer = function (instance, init) {
	        return originalInitializer.call(instance, init);
	      };
	    }
	    ret.push(initializer);
	  }

	  0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {
	    return value.get.call(instance, args);
	  }), ret.push(function (instance, args) {
	    return value.set.call(instance, args);
	  })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {
	    return value.call(instance, args);
	  }) : Object.defineProperty(base, name, desc));
	}

	function applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {
	  for (var protoInitializers = [], staticInitializers = [], existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {
	    var decInfo = decInfos[i];

	    if (Array.isArray(decInfo)) {
	      var base,
	          metadataMap,
	          initializers,
	          kind = decInfo[1],
	          name = decInfo[2],
	          isPrivate = decInfo.length > 3,
	          isStatic = kind >= 5;

	      if (isStatic ? (base = Class, metadataMap = staticMetadataMap, kind -= 5, initializers = staticInitializers) : (base = Class.prototype, metadataMap = protoMetadataMap, initializers = protoInitializers), 0 !== kind && !isPrivate) {
	        var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,
	            existingKind = existingNonFields.get(name) || 0;
	        if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
	        !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);
	      }

	      applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers);
	    }
	  }

	  protoInitializers.length > 0 && pushInitializers(ret, protoInitializers), staticInitializers.length > 0 && pushInitializers(ret, staticInitializers);
	}

	function pushInitializers(ret, initializers) {
	  initializers.length > 0 ? (initializers = initializers.slice(), ret.push(function (instance) {
	    for (var i = 0; i < initializers.length; i++) initializers[i].call(instance, instance);

	    return instance;
	  })) : ret.push(function (instance) {
	    return instance;
	  });
	}

	function applyClassDecs(ret, targetClass, metadataMap, classDecs) {
	  for (var initializers = [], newClass = targetClass, name = targetClass.name, ctx = Object.assign({
	    kind: "class",
	    name: name,
	    addInitializer: createAddInitializerMethod(initializers)
	  }, createMetadataMethodsForProperty(metadataMap, 0, name)), i = classDecs.length - 1; i >= 0; i--) newClass = classDecs[i](newClass, ctx) || newClass;

	  ret.push(newClass), initializers.length > 0 ? ret.push(function () {
	    for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass, newClass);
	  }) : ret.push(function () {});
	}

	function _applyDecs(targetClass, memberDecs, classDecs) {
	  var ret = [],
	      staticMetadataMap = {};

	  if (memberDecs) {
	    var protoMetadataMap = {};
	    applyMemberDecs(ret, targetClass, protoMetadataMap, staticMetadataMap, memberDecs), convertMetadataMapToFinal(targetClass.prototype, protoMetadataMap);
	  }

	  return classDecs && applyClassDecs(ret, targetClass, staticMetadataMap, classDecs), convertMetadataMapToFinal(targetClass, staticMetadataMap), ret;
	}

	function _asyncIterator(iterable) {
	  var method,
	      async,
	      sync,
	      retry = 2;

	  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
	    if (async && null != (method = iterable[async])) return method.call(iterable);
	    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
	    async = "@@asyncIterator", sync = "@@iterator";
	  }

	  throw new TypeError("Object is not async iterable");
	}

	function AsyncFromSyncIterator(s) {
	  function AsyncFromSyncIteratorContinuation(r) {
	    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
	    var done = r.done;
	    return Promise.resolve(r.value).then(function (value) {
	      return {
	        value: value,
	        done: done
	      };
	    });
	  }

	  return AsyncFromSyncIterator = function (s) {
	    this.s = s, this.n = s.next;
	  }, AsyncFromSyncIterator.prototype = {
	    s: null,
	    n: null,
	    next: function () {
	      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
	    },
	    return: function (value) {
	      var ret = this.s.return;
	      return void 0 === ret ? Promise.resolve({
	        value: value,
	        done: !0
	      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
	    },
	    throw: function (value) {
	      var thr = this.s.return;
	      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
	    }
	  }, new AsyncFromSyncIterator(s);
	}

	var REACT_ELEMENT_TYPE;

	function _jsx(type, props, key, children) {
	  REACT_ELEMENT_TYPE || (REACT_ELEMENT_TYPE = "function" == typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103);
	  var defaultProps = type && type.defaultProps,
	      childrenLength = arguments.length - 3;
	  if (props || 0 === childrenLength || (props = {
	    children: void 0
	  }), 1 === childrenLength) props.children = children;else if (childrenLength > 1) {
	    for (var childArray = new Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 3];

	    props.children = childArray;
	  }
	  if (props && defaultProps) for (var propName in defaultProps) void 0 === props[propName] && (props[propName] = defaultProps[propName]);else props || (props = defaultProps || {});
	  return {
	    $$typeof: REACT_ELEMENT_TYPE,
	    type: type,
	    key: void 0 === key ? null : "" + key,
	    ref: null,
	    props: props,
	    _owner: null
	  };
	}

	function ownKeys$1(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    })), keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    });
	  }

	  return target;
	}

	function _typeof$c(obj) {
	  "@babel/helpers - typeof";

	  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, _typeof$c(obj);
	}

	function _wrapRegExp() {
	  _wrapRegExp = function (re, groups) {
	    return new BabelRegExp(re, void 0, groups);
	  };

	  var _super = RegExp.prototype,
	      _groups = new WeakMap();

	  function BabelRegExp(re, flags, groups) {
	    var _this = new RegExp(re, flags);

	    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
	  }

	  function buildGroups(result, re) {
	    var g = _groups.get(re);

	    return Object.keys(g).reduce(function (groups, name) {
	      return groups[name] = result[g[name]], groups;
	    }, Object.create(null));
	  }

	  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
	    var result = _super.exec.call(this, str);

	    return result && (result.groups = buildGroups(result, this)), result;
	  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
	    if ("string" == typeof substitution) {
	      var groups = _groups.get(this);

	      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
	        return "$" + groups[name];
	      }));
	    }

	    if ("function" == typeof substitution) {
	      var _this = this;

	      return _super[Symbol.replace].call(this, str, function () {
	        var args = arguments;
	        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
	      });
	    }

	    return _super[Symbol.replace].call(this, str, substitution);
	  }, _wrapRegExp.apply(this, arguments);
	}

	function _AwaitValue(value) {
	  this.wrapped = value;
	}

	function _AsyncGenerator(gen) {
	  var front, back;

	  function send(key, arg) {
	    return new Promise(function (resolve, reject) {
	      var request = {
	        key: key,
	        arg: arg,
	        resolve: resolve,
	        reject: reject,
	        next: null
	      };

	      if (back) {
	        back = back.next = request;
	      } else {
	        front = back = request;
	        resume(key, arg);
	      }
	    });
	  }

	  function resume(key, arg) {
	    try {
	      var result = gen[key](arg);
	      var value = result.value;
	      var wrappedAwait = value instanceof _AwaitValue;
	      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
	        if (wrappedAwait) {
	          resume(key === "return" ? "return" : "next", arg);
	          return;
	        }

	        settle(result.done ? "return" : "normal", arg);
	      }, function (err) {
	        resume("throw", err);
	      });
	    } catch (err) {
	      settle("throw", err);
	    }
	  }

	  function settle(type, value) {
	    switch (type) {
	      case "return":
	        front.resolve({
	          value: value,
	          done: true
	        });
	        break;

	      case "throw":
	        front.reject(value);
	        break;

	      default:
	        front.resolve({
	          value: value,
	          done: false
	        });
	        break;
	    }

	    front = front.next;

	    if (front) {
	      resume(front.key, front.arg);
	    } else {
	      back = null;
	    }
	  }

	  this._invoke = send;

	  if (typeof gen.return !== "function") {
	    this.return = undefined;
	  }
	}

	_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () {
	  return this;
	};

	_AsyncGenerator.prototype.next = function (arg) {
	  return this._invoke("next", arg);
	};

	_AsyncGenerator.prototype.throw = function (arg) {
	  return this._invoke("throw", arg);
	};

	_AsyncGenerator.prototype.return = function (arg) {
	  return this._invoke("return", arg);
	};

	function _wrapAsyncGenerator(fn) {
	  return function () {
	    return new _AsyncGenerator(fn.apply(this, arguments));
	  };
	}

	function _awaitAsyncGenerator(value) {
	  return new _AwaitValue(value);
	}

	function _asyncGeneratorDelegate(inner, awaitWrap) {
	  var iter = {},
	      waiting = false;

	  function pump(key, value) {
	    waiting = true;
	    value = new Promise(function (resolve) {
	      resolve(inner[key](value));
	    });
	    return {
	      done: false,
	      value: awaitWrap(value)
	    };
	  }

	  iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () {
	    return this;
	  };

	  iter.next = function (value) {
	    if (waiting) {
	      waiting = false;
	      return value;
	    }

	    return pump("next", value);
	  };

	  if (typeof inner.throw === "function") {
	    iter.throw = function (value) {
	      if (waiting) {
	        waiting = false;
	        throw value;
	      }

	      return pump("throw", value);
	    };
	  }

	  if (typeof inner.return === "function") {
	    iter.return = function (value) {
	      if (waiting) {
	        waiting = false;
	        return value;
	      }

	      return pump("return", value);
	    };
	  }

	  return iter;
	}

	function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator$1(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}

	function _defineEnumerableProperties(obj, descs) {
	  for (var key in descs) {
	    var desc = descs[key];
	    desc.configurable = desc.enumerable = true;
	    if ("value" in desc) desc.writable = true;
	    Object.defineProperty(obj, key, desc);
	  }

	  if (Object.getOwnPropertySymbols) {
	    var objectSymbols = Object.getOwnPropertySymbols(descs);

	    for (var i = 0; i < objectSymbols.length; i++) {
	      var sym = objectSymbols[i];
	      var desc = descs[sym];
	      desc.configurable = desc.enumerable = true;
	      if ("value" in desc) desc.writable = true;
	      Object.defineProperty(obj, sym, desc);
	    }
	  }

	  return obj;
	}

	function _defaults(obj, defaults) {
	  var keys = Object.getOwnPropertyNames(defaults);

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var value = Object.getOwnPropertyDescriptor(defaults, key);

	    if (value && value.configurable && obj[key] === undefined) {
	      Object.defineProperty(obj, key, value);
	    }
	  }

	  return obj;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? Object(arguments[i]) : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  Object.defineProperty(subClass, "prototype", {
	    writable: false
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;

	  _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !_isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return _setPrototypeOf(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	function _instanceof(left, right) {
	  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
	    return !!right[Symbol.hasInstance](left);
	  } else {
	    return left instanceof right;
	  }
	}

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    default: obj
	  };
	}

	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = new WeakMap();
	  var cacheNodeInterop = new WeakMap();
	  return (_getRequireWildcardCache = function (nodeInterop) {
	    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}

	function _interopRequireWildcard(obj, nodeInterop) {
	  if (!nodeInterop && obj && obj.__esModule) {
	    return obj;
	  }

	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return {
	      default: obj
	    };
	  }

	  var cache = _getRequireWildcardCache(nodeInterop);

	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }

	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }

	  newObj.default = obj;

	  if (cache) {
	    cache.set(obj, newObj);
	  }

	  return newObj;
	}

	function _newArrowCheck(innerThis, boundThis) {
	  if (innerThis !== boundThis) {
	    throw new TypeError("Cannot instantiate an arrow function");
	  }
	}

	function _objectDestructuringEmpty(obj) {
	  if (obj == null) throw new TypeError("Cannot destructure undefined");
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  } else if (call !== void 0) {
	    throw new TypeError("Derived constructors may only return object or undefined");
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();

	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = _getPrototypeOf(object);
	    if (object === null) break;
	  }

	  return object;
	}

	function _get() {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    _get = Reflect.get;
	  } else {
	    _get = function _get(target, property, receiver) {
	      var base = _superPropBase(target, property);

	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);

	      if (desc.get) {
	        return desc.get.call(arguments.length < 3 ? target : receiver);
	      }

	      return desc.value;
	    };
	  }

	  return _get.apply(this, arguments);
	}

	function set$4(target, property, value, receiver) {
	  if (typeof Reflect !== "undefined" && Reflect.set) {
	    set$4 = Reflect.set;
	  } else {
	    set$4 = function set(target, property, value, receiver) {
	      var base = _superPropBase(target, property);

	      var desc;

	      if (base) {
	        desc = Object.getOwnPropertyDescriptor(base, property);

	        if (desc.set) {
	          desc.set.call(receiver, value);
	          return true;
	        } else if (!desc.writable) {
	          return false;
	        }
	      }

	      desc = Object.getOwnPropertyDescriptor(receiver, property);

	      if (desc) {
	        if (!desc.writable) {
	          return false;
	        }

	        desc.value = value;
	        Object.defineProperty(receiver, property, desc);
	      } else {
	        _defineProperty(receiver, property, value);
	      }

	      return true;
	    };
	  }

	  return set$4(target, property, value, receiver);
	}

	function _set(target, property, value, receiver, isStrict) {
	  var s = set$4(target, property, value, receiver || target);

	  if (!s && isStrict) {
	    throw new Error('failed to set property');
	  }

	  return value;
	}

	function _taggedTemplateLiteral(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }

	  return Object.freeze(Object.defineProperties(strings, {
	    raw: {
	      value: Object.freeze(raw)
	    }
	  }));
	}

	function _taggedTemplateLiteralLoose(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }

	  strings.raw = raw;
	  return strings;
	}

	function _readOnlyError(name) {
	  throw new TypeError("\"" + name + "\" is read-only");
	}

	function _writeOnlyError(name) {
	  throw new TypeError("\"" + name + "\" is write-only");
	}

	function _classNameTDZError(name) {
	  throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
	}

	function _temporalUndefined() {}

	function _tdz(name) {
	  throw new ReferenceError(name + " is not defined - temporal dead zone");
	}

	function _temporalRef(val, name) {
	  return val === _temporalUndefined ? _tdz(name) : val;
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
	}

	function _slicedToArrayLoose(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
	}

	function _toArray(arr) {
	  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _maybeArrayLike(next, arr, i) {
	  if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
	    var len = arr.length;
	    return _arrayLikeToArray$1(arr, i !== void 0 && i < len ? i : len);
	  }

	  return next(arr, i);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

	  if (_i == null) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;

	  var _s, _e;

	  try {
	    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _iterableToArrayLimitLoose(arr, i) {
	  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

	  if (_i == null) return;
	  var _arr = [];

	  for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
	    _arr.push(_step.value);

	    if (i && _arr.length === i) break;
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray$1(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
	}

	function _arrayLikeToArray$1(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _createForOfIteratorHelper$1(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

	  if (!it) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function () {};

	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function () {
	      it = it.call(o);
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (it) return (it = it.call(o)).next.bind(it);

	  if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
	    if (it) o = it;
	    var i = 0;
	    return function () {
	      if (i >= o.length) return {
	        done: true
	      };
	      return {
	        done: false,
	        value: o[i++]
	      };
	    };
	  }

	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _skipFirstGeneratorNext(fn) {
	  return function () {
	    var it = fn.apply(this, arguments);
	    it.next();
	    return it;
	  };
	}

	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];

	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }

	  return (hint === "string" ? String : Number)(input);
	}

	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");

	  return typeof key === "symbol" ? key : String(key);
	}

	function _initializerWarningHelper(descriptor, context) {
	  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
	}

	function _initializerDefineProperty(target, property, descriptor, context) {
	  if (!descriptor) return;
	  Object.defineProperty(target, property, {
	    enumerable: descriptor.enumerable,
	    configurable: descriptor.configurable,
	    writable: descriptor.writable,
	    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
	  });
	}

	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
	  var desc = {};
	  Object.keys(descriptor).forEach(function (key) {
	    desc[key] = descriptor[key];
	  });
	  desc.enumerable = !!desc.enumerable;
	  desc.configurable = !!desc.configurable;

	  if ('value' in desc || desc.initializer) {
	    desc.writable = true;
	  }

	  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
	    return decorator(target, property, desc) || desc;
	  }, desc);

	  if (context && desc.initializer !== void 0) {
	    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
	    desc.initializer = undefined;
	  }

	  if (desc.initializer === void 0) {
	    Object.defineProperty(target, property, desc);
	    desc = null;
	  }

	  return desc;
	}

	var id$2 = 0;

	function _classPrivateFieldLooseKey(name) {
	  return "__private_" + id$2++ + "_" + name;
	}

	function _classPrivateFieldLooseBase(receiver, privateKey) {
	  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
	    throw new TypeError("attempted to use private field on non-instance");
	  }

	  return receiver;
	}

	function _classPrivateFieldGet(receiver, privateMap) {
	  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");

	  return _classApplyDescriptorGet(receiver, descriptor);
	}

	function _classPrivateFieldSet(receiver, privateMap, value) {
	  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");

	  _classApplyDescriptorSet(receiver, descriptor, value);

	  return value;
	}

	function _classPrivateFieldDestructureSet(receiver, privateMap) {
	  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");

	  return _classApplyDescriptorDestructureSet(receiver, descriptor);
	}

	function _classExtractFieldDescriptor(receiver, privateMap, action) {
	  if (!privateMap.has(receiver)) {
	    throw new TypeError("attempted to " + action + " private field on non-instance");
	  }

	  return privateMap.get(receiver);
	}

	function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
	  _classCheckPrivateStaticAccess(receiver, classConstructor);

	  _classCheckPrivateStaticFieldDescriptor(descriptor, "get");

	  return _classApplyDescriptorGet(receiver, descriptor);
	}

	function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
	  _classCheckPrivateStaticAccess(receiver, classConstructor);

	  _classCheckPrivateStaticFieldDescriptor(descriptor, "set");

	  _classApplyDescriptorSet(receiver, descriptor, value);

	  return value;
	}

	function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
	  _classCheckPrivateStaticAccess(receiver, classConstructor);

	  return method;
	}

	function _classStaticPrivateMethodSet() {
	  throw new TypeError("attempted to set read only static private field");
	}

	function _classApplyDescriptorGet(receiver, descriptor) {
	  if (descriptor.get) {
	    return descriptor.get.call(receiver);
	  }

	  return descriptor.value;
	}

	function _classApplyDescriptorSet(receiver, descriptor, value) {
	  if (descriptor.set) {
	    descriptor.set.call(receiver, value);
	  } else {
	    if (!descriptor.writable) {
	      throw new TypeError("attempted to set read only private field");
	    }

	    descriptor.value = value;
	  }
	}

	function _classApplyDescriptorDestructureSet(receiver, descriptor) {
	  if (descriptor.set) {
	    if (!("__destrObj" in descriptor)) {
	      descriptor.__destrObj = {
	        set value(v) {
	          descriptor.set.call(receiver, v);
	        }

	      };
	    }

	    return descriptor.__destrObj;
	  } else {
	    if (!descriptor.writable) {
	      throw new TypeError("attempted to set read only private field");
	    }

	    return descriptor;
	  }
	}

	function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
	  _classCheckPrivateStaticAccess(receiver, classConstructor);

	  _classCheckPrivateStaticFieldDescriptor(descriptor, "set");

	  return _classApplyDescriptorDestructureSet(receiver, descriptor);
	}

	function _classCheckPrivateStaticAccess(receiver, classConstructor) {
	  if (receiver !== classConstructor) {
	    throw new TypeError("Private static access of wrong provenance");
	  }
	}

	function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
	  if (descriptor === undefined) {
	    throw new TypeError("attempted to " + action + " private static field before its declaration");
	  }
	}

	function _decorate(decorators, factory, superClass, mixins) {
	  var api = _getDecoratorsApi();

	  if (mixins) {
	    for (var i = 0; i < mixins.length; i++) {
	      api = mixins[i](api);
	    }
	  }

	  var r = factory(function initialize(O) {
	    api.initializeInstanceElements(O, decorated.elements);
	  }, superClass);
	  var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);
	  api.initializeClassElements(r.F, decorated.elements);
	  return api.runClassFinishers(r.F, decorated.finishers);
	}

	function _getDecoratorsApi() {
	  _getDecoratorsApi = function () {
	    return api;
	  };

	  var api = {
	    elementsDefinitionOrder: [["method"], ["field"]],
	    initializeInstanceElements: function (O, elements) {
	      ["method", "field"].forEach(function (kind) {
	        elements.forEach(function (element) {
	          if (element.kind === kind && element.placement === "own") {
	            this.defineClassElement(O, element);
	          }
	        }, this);
	      }, this);
	    },
	    initializeClassElements: function (F, elements) {
	      var proto = F.prototype;
	      ["method", "field"].forEach(function (kind) {
	        elements.forEach(function (element) {
	          var placement = element.placement;

	          if (element.kind === kind && (placement === "static" || placement === "prototype")) {
	            var receiver = placement === "static" ? F : proto;
	            this.defineClassElement(receiver, element);
	          }
	        }, this);
	      }, this);
	    },
	    defineClassElement: function (receiver, element) {
	      var descriptor = element.descriptor;

	      if (element.kind === "field") {
	        var initializer = element.initializer;
	        descriptor = {
	          enumerable: descriptor.enumerable,
	          writable: descriptor.writable,
	          configurable: descriptor.configurable,
	          value: initializer === void 0 ? void 0 : initializer.call(receiver)
	        };
	      }

	      Object.defineProperty(receiver, element.key, descriptor);
	    },
	    decorateClass: function (elements, decorators) {
	      var newElements = [];
	      var finishers = [];
	      var placements = {
	        static: [],
	        prototype: [],
	        own: []
	      };
	      elements.forEach(function (element) {
	        this.addElementPlacement(element, placements);
	      }, this);
	      elements.forEach(function (element) {
	        if (!_hasDecorators(element)) return newElements.push(element);
	        var elementFinishersExtras = this.decorateElement(element, placements);
	        newElements.push(elementFinishersExtras.element);
	        newElements.push.apply(newElements, elementFinishersExtras.extras);
	        finishers.push.apply(finishers, elementFinishersExtras.finishers);
	      }, this);

	      if (!decorators) {
	        return {
	          elements: newElements,
	          finishers: finishers
	        };
	      }

	      var result = this.decorateConstructor(newElements, decorators);
	      finishers.push.apply(finishers, result.finishers);
	      result.finishers = finishers;
	      return result;
	    },
	    addElementPlacement: function (element, placements, silent) {
	      var keys = placements[element.placement];

	      if (!silent && keys.indexOf(element.key) !== -1) {
	        throw new TypeError("Duplicated element (" + element.key + ")");
	      }

	      keys.push(element.key);
	    },
	    decorateElement: function (element, placements) {
	      var extras = [];
	      var finishers = [];

	      for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {
	        var keys = placements[element.placement];
	        keys.splice(keys.indexOf(element.key), 1);
	        var elementObject = this.fromElementDescriptor(element);
	        var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);
	        element = elementFinisherExtras.element;
	        this.addElementPlacement(element, placements);

	        if (elementFinisherExtras.finisher) {
	          finishers.push(elementFinisherExtras.finisher);
	        }

	        var newExtras = elementFinisherExtras.extras;

	        if (newExtras) {
	          for (var j = 0; j < newExtras.length; j++) {
	            this.addElementPlacement(newExtras[j], placements);
	          }

	          extras.push.apply(extras, newExtras);
	        }
	      }

	      return {
	        element: element,
	        finishers: finishers,
	        extras: extras
	      };
	    },
	    decorateConstructor: function (elements, decorators) {
	      var finishers = [];

	      for (var i = decorators.length - 1; i >= 0; i--) {
	        var obj = this.fromClassDescriptor(elements);
	        var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);

	        if (elementsAndFinisher.finisher !== undefined) {
	          finishers.push(elementsAndFinisher.finisher);
	        }

	        if (elementsAndFinisher.elements !== undefined) {
	          elements = elementsAndFinisher.elements;

	          for (var j = 0; j < elements.length - 1; j++) {
	            for (var k = j + 1; k < elements.length; k++) {
	              if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {
	                throw new TypeError("Duplicated element (" + elements[j].key + ")");
	              }
	            }
	          }
	        }
	      }

	      return {
	        elements: elements,
	        finishers: finishers
	      };
	    },
	    fromElementDescriptor: function (element) {
	      var obj = {
	        kind: element.kind,
	        key: element.key,
	        placement: element.placement,
	        descriptor: element.descriptor
	      };
	      var desc = {
	        value: "Descriptor",
	        configurable: true
	      };
	      Object.defineProperty(obj, Symbol.toStringTag, desc);
	      if (element.kind === "field") obj.initializer = element.initializer;
	      return obj;
	    },
	    toElementDescriptors: function (elementObjects) {
	      if (elementObjects === undefined) return;
	      return _toArray(elementObjects).map(function (elementObject) {
	        var element = this.toElementDescriptor(elementObject);
	        this.disallowProperty(elementObject, "finisher", "An element descriptor");
	        this.disallowProperty(elementObject, "extras", "An element descriptor");
	        return element;
	      }, this);
	    },
	    toElementDescriptor: function (elementObject) {
	      var kind = String(elementObject.kind);

	      if (kind !== "method" && kind !== "field") {
	        throw new TypeError('An element descriptor\'s .kind property must be either "method" or' + ' "field", but a decorator created an element descriptor with' + ' .kind "' + kind + '"');
	      }

	      var key = _toPropertyKey(elementObject.key);

	      var placement = String(elementObject.placement);

	      if (placement !== "static" && placement !== "prototype" && placement !== "own") {
	        throw new TypeError('An element descriptor\'s .placement property must be one of "static",' + ' "prototype" or "own", but a decorator created an element descriptor' + ' with .placement "' + placement + '"');
	      }

	      var descriptor = elementObject.descriptor;
	      this.disallowProperty(elementObject, "elements", "An element descriptor");
	      var element = {
	        kind: kind,
	        key: key,
	        placement: placement,
	        descriptor: Object.assign({}, descriptor)
	      };

	      if (kind !== "field") {
	        this.disallowProperty(elementObject, "initializer", "A method descriptor");
	      } else {
	        this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor");
	        this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor");
	        this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor");
	        element.initializer = elementObject.initializer;
	      }

	      return element;
	    },
	    toElementFinisherExtras: function (elementObject) {
	      var element = this.toElementDescriptor(elementObject);

	      var finisher = _optionalCallableProperty(elementObject, "finisher");

	      var extras = this.toElementDescriptors(elementObject.extras);
	      return {
	        element: element,
	        finisher: finisher,
	        extras: extras
	      };
	    },
	    fromClassDescriptor: function (elements) {
	      var obj = {
	        kind: "class",
	        elements: elements.map(this.fromElementDescriptor, this)
	      };
	      var desc = {
	        value: "Descriptor",
	        configurable: true
	      };
	      Object.defineProperty(obj, Symbol.toStringTag, desc);
	      return obj;
	    },
	    toClassDescriptor: function (obj) {
	      var kind = String(obj.kind);

	      if (kind !== "class") {
	        throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator' + ' created a class descriptor with .kind "' + kind + '"');
	      }

	      this.disallowProperty(obj, "key", "A class descriptor");
	      this.disallowProperty(obj, "placement", "A class descriptor");
	      this.disallowProperty(obj, "descriptor", "A class descriptor");
	      this.disallowProperty(obj, "initializer", "A class descriptor");
	      this.disallowProperty(obj, "extras", "A class descriptor");

	      var finisher = _optionalCallableProperty(obj, "finisher");

	      var elements = this.toElementDescriptors(obj.elements);
	      return {
	        elements: elements,
	        finisher: finisher
	      };
	    },
	    runClassFinishers: function (constructor, finishers) {
	      for (var i = 0; i < finishers.length; i++) {
	        var newConstructor = (0, finishers[i])(constructor);

	        if (newConstructor !== undefined) {
	          if (typeof newConstructor !== "function") {
	            throw new TypeError("Finishers must return a constructor.");
	          }

	          constructor = newConstructor;
	        }
	      }

	      return constructor;
	    },
	    disallowProperty: function (obj, name, objectType) {
	      if (obj[name] !== undefined) {
	        throw new TypeError(objectType + " can't have a ." + name + " property.");
	      }
	    }
	  };
	  return api;
	}

	function _createElementDescriptor(def) {
	  var key = _toPropertyKey(def.key);

	  var descriptor;

	  if (def.kind === "method") {
	    descriptor = {
	      value: def.value,
	      writable: true,
	      configurable: true,
	      enumerable: false
	    };
	  } else if (def.kind === "get") {
	    descriptor = {
	      get: def.value,
	      configurable: true,
	      enumerable: false
	    };
	  } else if (def.kind === "set") {
	    descriptor = {
	      set: def.value,
	      configurable: true,
	      enumerable: false
	    };
	  } else if (def.kind === "field") {
	    descriptor = {
	      configurable: true,
	      writable: true,
	      enumerable: true
	    };
	  }

	  var element = {
	    kind: def.kind === "field" ? "field" : "method",
	    key: key,
	    placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
	    descriptor: descriptor
	  };
	  if (def.decorators) element.decorators = def.decorators;
	  if (def.kind === "field") element.initializer = def.value;
	  return element;
	}

	function _coalesceGetterSetter(element, other) {
	  if (element.descriptor.get !== undefined) {
	    other.descriptor.get = element.descriptor.get;
	  } else {
	    other.descriptor.set = element.descriptor.set;
	  }
	}

	function _coalesceClassElements(elements) {
	  var newElements = [];

	  var isSameElement = function (other) {
	    return other.kind === "method" && other.key === element.key && other.placement === element.placement;
	  };

	  for (var i = 0; i < elements.length; i++) {
	    var element = elements[i];
	    var other;

	    if (element.kind === "method" && (other = newElements.find(isSameElement))) {
	      if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
	        if (_hasDecorators(element) || _hasDecorators(other)) {
	          throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated.");
	        }

	        other.descriptor = element.descriptor;
	      } else {
	        if (_hasDecorators(element)) {
	          if (_hasDecorators(other)) {
	            throw new ReferenceError("Decorators can't be placed on different accessors with for " + "the same property (" + element.key + ").");
	          }

	          other.decorators = element.decorators;
	        }

	        _coalesceGetterSetter(element, other);
	      }
	    } else {
	      newElements.push(element);
	    }
	  }

	  return newElements;
	}

	function _hasDecorators(element) {
	  return element.decorators && element.decorators.length;
	}

	function _isDataDescriptor(desc) {
	  return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);
	}

	function _optionalCallableProperty(obj, name) {
	  var value = obj[name];

	  if (value !== undefined && typeof value !== "function") {
	    throw new TypeError("Expected '" + name + "' to be a function");
	  }

	  return value;
	}

	function _classPrivateMethodGet(receiver, privateSet, fn) {
	  if (!privateSet.has(receiver)) {
	    throw new TypeError("attempted to get private field on non-instance");
	  }

	  return fn;
	}

	function _checkPrivateRedeclaration(obj, privateCollection) {
	  if (privateCollection.has(obj)) {
	    throw new TypeError("Cannot initialize the same private elements twice on an object");
	  }
	}

	function _classPrivateFieldInitSpec(obj, privateMap, value) {
	  _checkPrivateRedeclaration(obj, privateMap);

	  privateMap.set(obj, value);
	}

	function _classPrivateMethodInitSpec(obj, privateSet) {
	  _checkPrivateRedeclaration(obj, privateSet);

	  privateSet.add(obj);
	}

	function _classPrivateMethodSet() {
	  throw new TypeError("attempted to reassign private method");
	}

	function _identity(x) {
	  return x;
	}

	var _rollupPluginBabelHelpers = /*#__PURE__*/Object.freeze({
		__proto__: null,
		applyDecs: _applyDecs,
		asyncIterator: _asyncIterator,
		jsx: _jsx,
		objectSpread2: _objectSpread2,
		get typeof () { return _typeof$c; },
		get wrapRegExp () { return _wrapRegExp; },
		AwaitValue: _AwaitValue,
		AsyncGenerator: _AsyncGenerator,
		wrapAsyncGenerator: _wrapAsyncGenerator,
		awaitAsyncGenerator: _awaitAsyncGenerator,
		asyncGeneratorDelegate: _asyncGeneratorDelegate,
		asyncToGenerator: _asyncToGenerator$1,
		classCallCheck: _classCallCheck,
		createClass: _createClass,
		defineEnumerableProperties: _defineEnumerableProperties,
		defaults: _defaults,
		defineProperty: _defineProperty,
		get extends () { return _extends; },
		objectSpread: _objectSpread,
		inherits: _inherits,
		inheritsLoose: _inheritsLoose,
		get getPrototypeOf () { return _getPrototypeOf; },
		get setPrototypeOf () { return _setPrototypeOf; },
		isNativeReflectConstruct: _isNativeReflectConstruct,
		get construct () { return _construct; },
		isNativeFunction: _isNativeFunction,
		get wrapNativeSuper () { return _wrapNativeSuper; },
		'instanceof': _instanceof,
		interopRequireDefault: _interopRequireDefault,
		interopRequireWildcard: _interopRequireWildcard,
		newArrowCheck: _newArrowCheck,
		objectDestructuringEmpty: _objectDestructuringEmpty,
		objectWithoutPropertiesLoose: _objectWithoutPropertiesLoose,
		objectWithoutProperties: _objectWithoutProperties,
		assertThisInitialized: _assertThisInitialized,
		possibleConstructorReturn: _possibleConstructorReturn,
		createSuper: _createSuper,
		superPropBase: _superPropBase,
		get get () { return _get; },
		set: _set,
		taggedTemplateLiteral: _taggedTemplateLiteral,
		taggedTemplateLiteralLoose: _taggedTemplateLiteralLoose,
		readOnlyError: _readOnlyError,
		writeOnlyError: _writeOnlyError,
		classNameTDZError: _classNameTDZError,
		temporalUndefined: _temporalUndefined,
		tdz: _tdz,
		temporalRef: _temporalRef,
		slicedToArray: _slicedToArray,
		slicedToArrayLoose: _slicedToArrayLoose,
		toArray: _toArray,
		toConsumableArray: _toConsumableArray,
		arrayWithoutHoles: _arrayWithoutHoles,
		arrayWithHoles: _arrayWithHoles,
		maybeArrayLike: _maybeArrayLike,
		iterableToArray: _iterableToArray,
		iterableToArrayLimit: _iterableToArrayLimit,
		iterableToArrayLimitLoose: _iterableToArrayLimitLoose,
		unsupportedIterableToArray: _unsupportedIterableToArray$1,
		arrayLikeToArray: _arrayLikeToArray$1,
		nonIterableSpread: _nonIterableSpread,
		nonIterableRest: _nonIterableRest,
		createForOfIteratorHelper: _createForOfIteratorHelper$1,
		createForOfIteratorHelperLoose: _createForOfIteratorHelperLoose,
		skipFirstGeneratorNext: _skipFirstGeneratorNext,
		toPrimitive: _toPrimitive,
		toPropertyKey: _toPropertyKey,
		initializerWarningHelper: _initializerWarningHelper,
		initializerDefineProperty: _initializerDefineProperty,
		applyDecoratedDescriptor: _applyDecoratedDescriptor,
		classPrivateFieldLooseKey: _classPrivateFieldLooseKey,
		classPrivateFieldLooseBase: _classPrivateFieldLooseBase,
		classPrivateFieldGet: _classPrivateFieldGet,
		classPrivateFieldSet: _classPrivateFieldSet,
		classPrivateFieldDestructureSet: _classPrivateFieldDestructureSet,
		classExtractFieldDescriptor: _classExtractFieldDescriptor,
		classStaticPrivateFieldSpecGet: _classStaticPrivateFieldSpecGet,
		classStaticPrivateFieldSpecSet: _classStaticPrivateFieldSpecSet,
		classStaticPrivateMethodGet: _classStaticPrivateMethodGet,
		classStaticPrivateMethodSet: _classStaticPrivateMethodSet,
		classApplyDescriptorGet: _classApplyDescriptorGet,
		classApplyDescriptorSet: _classApplyDescriptorSet,
		classApplyDescriptorDestructureSet: _classApplyDescriptorDestructureSet,
		classStaticPrivateFieldDestructureSet: _classStaticPrivateFieldDestructureSet,
		classCheckPrivateStaticAccess: _classCheckPrivateStaticAccess,
		classCheckPrivateStaticFieldDescriptor: _classCheckPrivateStaticFieldDescriptor,
		decorate: _decorate,
		classPrivateMethodGet: _classPrivateMethodGet,
		checkPrivateRedeclaration: _checkPrivateRedeclaration,
		classPrivateFieldInitSpec: _classPrivateFieldInitSpec,
		classPrivateMethodInitSpec: _classPrivateMethodInitSpec,
		classPrivateMethodSet: _classPrivateMethodSet,
		identity: _identity
	});

	var require$$0 = getCjsExportFromNamespace(_rollupPluginBabelHelpers);

	var _typeof$b = require$$0["typeof"];

	var check = function check(it) {
	  return it && it.Math == Math && it;
	}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


	var global_1 = // eslint-disable-next-line es/no-global-this -- safe
	check((typeof globalThis === "undefined" ? "undefined" : _typeof$b(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof$b(window)) == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
	check((typeof self === "undefined" ? "undefined" : _typeof$b(self)) == 'object' && self) || check((typeof commonjsGlobal === "undefined" ? "undefined" : _typeof$b(commonjsGlobal)) == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
	function () {
	  return this;
	}() || Function('return this')();

	var isPure = false;

	// eslint-disable-next-line es/no-object-defineproperty -- safe


	var defineProperty$g = Object.defineProperty;

	var setGlobal = function (key, value) {
	  try {
	    defineProperty$g(global_1, key, {
	      value: value,
	      configurable: true,
	      writable: true
	    });
	  } catch (error) {
	    global_1[key] = value;
	  }

	  return value;
	};

	var SHARED = '__core-js_shared__';
	var store$1 = global_1[SHARED] || setGlobal(SHARED, {});
	var sharedStore = store$1;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.21.1',
	  mode: 'global',
	  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
	  license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
	  source: 'https://github.com/zloirock/core-js'
	});
	});

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	var functionBindNative = !fails(function () {
	  var test = function () {
	    /* empty */
	  }.bind(); // eslint-disable-next-line no-prototype-builtins -- safe


	  return typeof test != 'function' || test.hasOwnProperty('prototype');
	});

	var FunctionPrototype$4 = Function.prototype;
	var bind$3 = FunctionPrototype$4.bind;
	var call$2 = FunctionPrototype$4.call;
	var uncurryThis = functionBindNative && bind$3.bind(call$2, call$2);
	var functionUncurryThis = functionBindNative ? function (fn) {
	  return fn && uncurryThis(fn);
	} : function (fn) {
	  return fn && function () {
	    return call$2.apply(fn, arguments);
	  };
	};

	var TypeError$s = global_1.TypeError; // `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible

	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError$s("Can't call method on " + it);
	  return it;
	};

	var Object$5 = global_1.Object; // `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject

	var toObject = function (argument) {
	  return Object$5(requireObjectCoercible(argument));
	};

	var hasOwnProperty = functionUncurryThis({}.hasOwnProperty); // `HasOwnProperty` abstract operation
	// https://tc39.es/ecma262/#sec-hasownproperty

	var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty(toObject(it), key);
	};

	var id$1 = 0;
	var postfix = Math.random();
	var toString$2 = functionUncurryThis(1.0.toString);

	var uid = function (key) {
	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$2(++id$1 + postfix, 36);
	};

	// `IsCallable` abstract operation
	// https://tc39.es/ecma262/#sec-iscallable
	var isCallable = function (argument) {
	  return typeof argument == 'function';
	};

	var aFunction = function aFunction(argument) {
	  return isCallable(argument) ? argument : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
	};

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process$5 = global_1.process;
	var Deno = global_1.Deno;
	var versions = process$5 && process$5.versions || Deno && Deno.version;
	var v8 = versions && versions.v8;
	var match, version$2;

	if (v8) {
	  match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
	  // but their correct versions are not interesting for us

	  version$2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	} // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
	// so check `userAgent` even if `.v8` exists, but 0


	if (!version$2 && engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);

	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version$2 = +match[1];
	  }
	}

	var engineV8Version = version$2;

	/* eslint-disable es/no-symbol -- required for testing */


	 // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing


	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
	  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

	  return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
	  !Symbol.sham && engineV8Version && engineV8Version < 41;
	});

	var _typeof$a = require$$0["typeof"];

	/* eslint-disable es/no-symbol -- required for testing */


	var useSymbolAsUid = nativeSymbol && !Symbol.sham && _typeof$a(Symbol.iterator) == 'symbol';

	var WellKnownSymbolsStore$1 = shared('wks');
	var _Symbol$2 = global_1.Symbol;
	var symbolFor = _Symbol$2 && _Symbol$2['for'];
	var createWellKnownSymbol = useSymbolAsUid ? _Symbol$2 : _Symbol$2 && _Symbol$2.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!hasOwnProperty_1(WellKnownSymbolsStore$1, name) || !(nativeSymbol || typeof WellKnownSymbolsStore$1[name] == 'string')) {
	    var description = 'Symbol.' + name;

	    if (nativeSymbol && hasOwnProperty_1(_Symbol$2, name)) {
	      WellKnownSymbolsStore$1[name] = _Symbol$2[name];
	    } else if (useSymbolAsUid && symbolFor) {
	      WellKnownSymbolsStore$1[name] = symbolFor(description);
	    } else {
	      WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
	    }
	  }

	  return WellKnownSymbolsStore$1[name];
	};

	var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
	var test$2 = {};
	test$2[TO_STRING_TAG$4] = 'z';
	var toStringTagSupport = String(test$2) === '[object z]';

	// Detect IE8's incomplete defineProperty implementation


	var descriptors = !fails(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty({}, 1, {
	    get: function get() {
	      return 7;
	    }
	  })[1] != 7;
	});

	var _typeof$9 = require$$0["typeof"];



	var isObject$1 = function (it) {
	  return _typeof$9(it) == 'object' ? it !== null : isCallable(it);
	};

	var document$3 = global_1.document; // typeof document.createElement is 'object' in old IE

	var EXISTS$1 = isObject$1(document$3) && isObject$1(document$3.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS$1 ? document$3.createElement(it) : {};
	};

	// Thanks to IE8 for its funny defineProperty


	var ie8DomDefine = !descriptors && !fails(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function get() {
	      return 7;
	    }
	  }).a != 7;
	});

	// V8 ~ Chrome 36-
	// https://bugs.chromium.org/p/v8/issues/detail?id=3334


	var v8PrototypeDefineBug = descriptors && fails(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty(function () {
	    /* empty */
	  }, 'prototype', {
	    value: 42,
	    writable: false
	  }).prototype != 42;
	});

	var String$6 = global_1.String;
	var TypeError$r = global_1.TypeError; // `Assert: Type(argument) is Object`

	var anObject = function (argument) {
	  if (isObject$1(argument)) return argument;
	  throw TypeError$r(String$6(argument) + ' is not an object');
	};

	var call$1 = Function.prototype.call;
	var functionCall = functionBindNative ? call$1.bind(call$1) : function () {
	  return call$1.apply(call$1, arguments);
	};

	var objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);

	var _typeof$8 = require$$0["typeof"];











	var Object$4 = global_1.Object;
	var isSymbol = useSymbolAsUid ? function (it) {
	  return _typeof$8(it) == 'symbol';
	} : function (it) {
	  var $Symbol = getBuiltIn('Symbol');
	  return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, Object$4(it));
	};

	var String$5 = global_1.String;

	var tryToString = function (argument) {
	  try {
	    return String$5(argument);
	  } catch (error) {
	    return 'Object';
	  }
	};

	var TypeError$q = global_1.TypeError; // `Assert: IsCallable(argument) is true`

	var aCallable = function (argument) {
	  if (isCallable(argument)) return argument;
	  throw TypeError$q(tryToString(argument) + ' is not a function');
	};

	// `GetMethod` abstract operation
	// https://tc39.es/ecma262/#sec-getmethod


	var getMethod = function (V, P) {
	  var func = V[P];
	  return func == null ? undefined : aCallable(func);
	};

	var TypeError$p = global_1.TypeError; // `OrdinaryToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-ordinarytoprimitive

	var ordinaryToPrimitive = function (input, pref) {
	  var fn, val;
	  if (pref === 'string' && isCallable(fn = input.toString) && !isObject$1(val = functionCall(fn, input))) return val;
	  if (isCallable(fn = input.valueOf) && !isObject$1(val = functionCall(fn, input))) return val;
	  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject$1(val = functionCall(fn, input))) return val;
	  throw TypeError$p("Can't convert object to primitive value");
	};

	var TypeError$o = global_1.TypeError;
	var TO_PRIMITIVE$2 = wellKnownSymbol('toPrimitive'); // `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive

	var toPrimitive = function (input, pref) {
	  if (!isObject$1(input) || isSymbol(input)) return input;
	  var exoticToPrim = getMethod(input, TO_PRIMITIVE$2);
	  var result;

	  if (exoticToPrim) {
	    if (pref === undefined) pref = 'default';
	    result = functionCall(exoticToPrim, input, pref);
	    if (!isObject$1(result) || isSymbol(result)) return result;
	    throw TypeError$o("Can't convert object to primitive value");
	  }

	  if (pref === undefined) pref = 'number';
	  return ordinaryToPrimitive(input, pref);
	};

	// `ToPropertyKey` abstract operation
	// https://tc39.es/ecma262/#sec-topropertykey


	var toPropertyKey = function (argument) {
	  var key = toPrimitive(argument, 'string');
	  return isSymbol(key) ? key : key + '';
	};

	var TypeError$n = global_1.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

	var $defineProperty$1 = Object.defineProperty; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

	var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
	var ENUMERABLE = 'enumerable';
	var CONFIGURABLE$1 = 'configurable';
	var WRITABLE = 'writable'; // `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty

	var f$8 = descriptors ? v8PrototypeDefineBug ? function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPropertyKey(P);
	  anObject(Attributes);

	  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
	    var current = $getOwnPropertyDescriptor$2(O, P);

	    if (current && current[WRITABLE]) {
	      O[P] = Attributes.value;
	      Attributes = {
	        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
	        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
	        writable: false
	      };
	    }
	  }

	  return $defineProperty$1(O, P, Attributes);
	} : $defineProperty$1 : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPropertyKey(P);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return $defineProperty$1(O, P, Attributes);
	  } catch (error) {
	    /* empty */
	  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError$n('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$8
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var functionToString$1 = functionUncurryThis(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

	if (!isCallable(sharedStore.inspectSource)) {
	  sharedStore.inspectSource = function (it) {
	    return functionToString$1(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$2 = global_1.WeakMap;
	var nativeWeakMap = isCallable(WeakMap$2) && /native code/.test(inspectSource(WeakMap$2));

	var keys$3 = shared('keys');

	var sharedKey = function (key) {
	  return keys$3[key] || (keys$3[key] = uid(key));
	};

	var hiddenKeys$1 = {};

	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError$m = global_1.TypeError;
	var WeakMap$1 = global_1.WeakMap;
	var set$3, get$2, has;

	var enforce = function enforce(it) {
	  return has(it) ? get$2(it) : set$3(it, {});
	};

	var getterFor$1 = function getterFor(TYPE) {
	  return function (it) {
	    var state;

	    if (!isObject$1(it) || (state = get$2(it)).type !== TYPE) {
	      throw TypeError$m('Incompatible receiver, ' + TYPE + ' required');
	    }

	    return state;
	  };
	};

	if (nativeWeakMap || sharedStore.state) {
	  var store = sharedStore.state || (sharedStore.state = new WeakMap$1());
	  var wmget = functionUncurryThis(store.get);
	  var wmhas = functionUncurryThis(store.has);
	  var wmset = functionUncurryThis(store.set);

	  set$3 = function set(it, metadata) {
	    if (wmhas(store, it)) throw new TypeError$m(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    wmset(store, it, metadata);
	    return metadata;
	  };

	  get$2 = function get(it) {
	    return wmget(store, it) || {};
	  };

	  has = function has(it) {
	    return wmhas(store, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys$1[STATE] = true;

	  set$3 = function set(it, metadata) {
	    if (hasOwnProperty_1(it, STATE)) throw new TypeError$m(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };

	  get$2 = function get(it) {
	    return hasOwnProperty_1(it, STATE) ? it[STATE] : {};
	  };

	  has = function has(it) {
	    return hasOwnProperty_1(it, STATE);
	  };
	}

	var internalState = {
	  set: set$3,
	  get: get$2,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor$1
	};

	var FunctionPrototype$3 = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

	var getDescriptor = descriptors && Object.getOwnPropertyDescriptor;
	var EXISTS = hasOwnProperty_1(FunctionPrototype$3, 'name'); // additional protection from minified / mangled / dropped function names

	var PROPER = EXISTS && function something() {
	  /* empty */
	}.name === 'something';

	var CONFIGURABLE = EXISTS && (!descriptors || descriptors && getDescriptor(FunctionPrototype$3, 'name').configurable);
	var functionName = {
	  EXISTS: EXISTS,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};

	var redefine = createCommonjsModule(function (module) {
	var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;

	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');
	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  var name = options && options.name !== undefined ? options.name : key;
	  var state;

	  if (isCallable(value)) {
	    if (String(name).slice(0, 7) === 'Symbol(') {
	      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
	    }

	    if (!hasOwnProperty_1(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
	      createNonEnumerableProperty(value, 'name', name);
	    }

	    state = enforceInternalState(value);

	    if (!state.source) {
	      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
	    }
	  }

	  if (O === global_1) {
	    if (simple) O[key] = value;else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }

	  if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return isCallable(this) && getInternalState(this).source || inspectSource(this);
	});
	});

	var toString$1 = functionUncurryThis({}.toString);
	var stringSlice$e = functionUncurryThis(''.slice);

	var classofRaw = function (it) {
	  return stringSlice$e(toString$1(it), 8, -1);
	};

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var Object$3 = global_1.Object; // ES3 wrong here

	var CORRECT_ARGUMENTS = classofRaw(function () {
	  return arguments;
	}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

	var tryGet = function tryGet(it, key) {
	  try {
	    return it[key];
	  } catch (error) {
	    /* empty */
	  }
	}; // getting tag from ES6+ `Object.prototype.toString`


	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
	  : typeof (tag = tryGet(O = Object$3(it), TO_STRING_TAG$3)) == 'string' ? tag // builtinTag case
	  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
	  : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
	};

	// `Object.prototype.toString` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.tostring


	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// `Object.prototype.toString` method
	// https://tc39.es/ecma262/#sec-object.prototype.tostring


	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString, {
	    unsafe: true
	  });
	}

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	var $propertyIsEnumerable$2 = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

	var getOwnPropertyDescriptor$8 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

	var NASHORN_BUG = getOwnPropertyDescriptor$8 && !$propertyIsEnumerable$2.call({
	  1: 2
	}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

	var f$7 = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$8(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable$2;

	var objectPropertyIsEnumerable = {
		f: f$7
	};

	var Object$2 = global_1.Object;
	var split$3 = functionUncurryThis(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return !Object$2('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split$3(it, '') : Object$2(it);
	} : Object$2;

	// toObject with fallback for non-array-like ES3 strings




	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe


	var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

	var f$6 = descriptors ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPropertyKey(P);
	  if (ie8DomDefine) try {
	    return $getOwnPropertyDescriptor$1(O, P);
	  } catch (error) {
	    /* empty */
	  }
	  if (hasOwnProperty_1(O, P)) return createPropertyDescriptor(!functionCall(objectPropertyIsEnumerable.f, O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$6
	};

	var ceil$2 = Math.ceil;
	var floor$a = Math.floor; // `ToIntegerOrInfinity` abstract operation
	// https://tc39.es/ecma262/#sec-tointegerorinfinity

	var toIntegerOrInfinity = function (argument) {
	  var number = +argument; // eslint-disable-next-line no-self-compare -- safe

	  return number !== number || number === 0 ? 0 : (number > 0 ? floor$a : ceil$2)(number);
	};

	var max$6 = Math.max;
	var min$9 = Math.min; // Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

	var toAbsoluteIndex = function (index, length) {
	  var integer = toIntegerOrInfinity(index);
	  return integer < 0 ? max$6(integer + length, 0) : min$9(integer, length);
	};

	var min$8 = Math.min; // `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength

	var toLength = function (argument) {
	  return argument > 0 ? min$8(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	// `LengthOfArrayLike` abstract operation
	// https://tc39.es/ecma262/#sec-lengthofarraylike


	var lengthOfArrayLike = function (obj) {
	  return toLength(obj.length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation


	var createMethod$6 = function createMethod(IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = lengthOfArrayLike(O);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value; // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare -- NaN check

	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

	      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    }
	    return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$6(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$6(false)
	};

	var indexOf$1 = arrayIncludes.indexOf;



	var push$b = functionUncurryThis([].push);

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;

	  for (key in O) {
	    !hasOwnProperty_1(hiddenKeys$1, key) && hasOwnProperty_1(O, key) && push$b(result, key);
	  } // Don't enum bug & hidden keys


	  while (names.length > i) {
	    if (hasOwnProperty_1(O, key = names[i++])) {
	      ~indexOf$1(result, key) || push$b(result, key);
	    }
	  }

	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

	var hiddenKeys = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	// eslint-disable-next-line es/no-object-getownpropertynames -- safe

	var f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys);
	};

	var objectGetOwnPropertyNames = {
		f: f$5
	};

	// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	var concat$3 = functionUncurryThis([].concat); // all object keys, includes non-enumerable and symbols

	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? concat$3(keys, getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source, exceptions) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];

	    if (!hasOwnProperty_1(target, key) && !(exceptions && hasOwnProperty_1(exceptions, key))) {
	      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	    }
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function isForced(feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';
	var isForced_1 = isForced;

	var _typeof$7 = require$$0["typeof"];



	var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;










	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	  options.name        - the .name of the function if it does not match the key
	*/


	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }

	  if (target) for (key in source) {
	    sourceProperty = source[key];

	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$7(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];

	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

	    if (!FORCED && targetProperty !== undefined) {
	      if (_typeof$7(sourceProperty) == _typeof$7(targetProperty)) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    } // add a flag to not completely full polyfills


	    if (options.sham || targetProperty && targetProperty.sham) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    } // extend global


	    redefine(target, key, sourceProperty, options);
	  }
	};

	var _typeof$6 = require$$0["typeof"];



	var FunctionPrototype$2 = Function.prototype;
	var apply = FunctionPrototype$2.apply;
	var call = FunctionPrototype$2.call; // eslint-disable-next-line es/no-reflect -- safe

	var functionApply = (typeof Reflect === "undefined" ? "undefined" : _typeof$6(Reflect)) == 'object' && Reflect.apply || (functionBindNative ? call.bind(apply) : function () {
	  return call.apply(apply, arguments);
	});

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	// eslint-disable-next-line es/no-array-isarray -- safe


	var isArray$1 = Array.isArray || function isArray(argument) {
	  return classofRaw(argument) == 'Array';
	};

	var String$4 = global_1.String;

	var toString_1 = function (argument) {
	  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
	  return String$4(argument);
	};

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	// eslint-disable-next-line es/no-object-keys -- safe


	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es/no-object-defineproperties -- safe


	var f$3 = descriptors && !v8PrototypeDefineBug ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var props = toIndexedObject(Properties);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;

	  while (length > index) {
	    objectDefineProperty.f(O, key = keys[index++], props[key]);
	  }

	  return O;
	};

	var objectDefineProperties = {
		f: f$3
	};

	var html = getBuiltIn('document', 'documentElement');

	/* global ActiveXObject -- old IE, WSH */














	var GT = '>';
	var LT = '<';
	var PROTOTYPE$2 = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey('IE_PROTO');

	var EmptyConstructor = function EmptyConstructor() {
	  /* empty */
	};

	var scriptTag = function scriptTag(content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


	var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak

	  return temp;
	}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


	var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	}; // Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug


	var activeXDocument;

	var _NullProtoObject = function NullProtoObject() {
	  try {
	    activeXDocument = new ActiveXObject('htmlfile');
	  } catch (error) {
	    /* ignore */
	  }

	  _NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
	  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

	  var length = enumBugKeys.length;

	  while (length--) {
	    delete _NullProtoObject[PROTOTYPE$2][enumBugKeys[length]];
	  }

	  return _NullProtoObject();
	};

	hiddenKeys$1[IE_PROTO$1] = true; // `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create

	var objectCreate = Object.create || function create(O, Properties) {
	  var result;

	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE$2] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE$2] = null; // add "__proto__" for Object.getPrototypeOf polyfill

	    result[IE_PROTO$1] = O;
	  } else result = _NullProtoObject();

	  return Properties === undefined ? result : objectDefineProperties.f(result, Properties);
	};

	var createProperty = function (object, key, value) {
	  var propertyKey = toPropertyKey(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
	};

	var Array$9 = global_1.Array;
	var max$5 = Math.max;

	var arraySliceSimple = function (O, start, end) {
	  var length = lengthOfArrayLike(O);
	  var k = toAbsoluteIndex(start, length);
	  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	  var result = Array$9(max$5(fin - k, 0));

	  for (var n = 0; k < fin; k++, n++) {
	    createProperty(result, n, O[k]);
	  }

	  result.length = n;
	  return result;
	};

	var _typeof$5 = require$$0["typeof"];

	/* eslint-disable es/no-object-getownpropertynames -- safe */




	var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;



	var windowNames = (typeof window === "undefined" ? "undefined" : _typeof$5(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function getWindowNames(it) {
	  try {
	    return $getOwnPropertyNames$1(it);
	  } catch (error) {
	    return arraySliceSimple(windowNames);
	  }
	}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


	var f$2 = function getOwnPropertyNames(it) {
	  return windowNames && classofRaw(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$2
	};

	var arraySlice$1 = functionUncurryThis([].slice);

	var f$1 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$1
	};

	var path = global_1;

	var defineProperty$f = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var _Symbol = path.Symbol || (path.Symbol = {});

	  if (!hasOwnProperty_1(_Symbol, NAME)) defineProperty$f(_Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var defineProperty$e = objectDefineProperty.f;





	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (target, TAG, STATIC) {
	  if (target && !STATIC) target = target.prototype;

	  if (target && !hasOwnProperty_1(target, TO_STRING_TAG$2)) {
	    defineProperty$e(target, TO_STRING_TAG$2, {
	      configurable: true,
	      value: TAG
	    });
	  }
	};

	var bind$2 = functionUncurryThis(functionUncurryThis.bind); // optional / simple context binding

	var functionBindContext = function (fn, that) {
	  aCallable(fn);
	  return that === undefined ? fn : functionBindNative ? bind$2(fn, that) : function
	    /* ...args */
	  () {
	    return fn.apply(that, arguments);
	  };
	};

	var noop = function noop() {
	  /* empty */
	};

	var empty = [];
	var construct$1 = getBuiltIn('Reflect', 'construct');
	var constructorRegExp = /^\s*(?:class|function)\b/;
	var exec$8 = functionUncurryThis(constructorRegExp.exec);
	var INCORRECT_TO_STRING$2 = !constructorRegExp.exec(noop);

	var isConstructorModern = function isConstructor(argument) {
	  if (!isCallable(argument)) return false;

	  try {
	    construct$1(noop, empty, argument);
	    return true;
	  } catch (error) {
	    return false;
	  }
	};

	var isConstructorLegacy = function isConstructor(argument) {
	  if (!isCallable(argument)) return false;

	  switch (classof(argument)) {
	    case 'AsyncFunction':
	    case 'GeneratorFunction':
	    case 'AsyncGeneratorFunction':
	      return false;
	  }

	  try {
	    // we can't check .prototype since constructors produced by .bind haven't it
	    // `Function#toString` throws on some built-it function in some legacy engines
	    // (for example, `DOMQuad` and similar in FF41-)
	    return INCORRECT_TO_STRING$2 || !!exec$8(constructorRegExp, inspectSource(argument));
	  } catch (error) {
	    return true;
	  }
	};

	isConstructorLegacy.sham = true; // `IsConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-isconstructor

	var isConstructor = !construct$1 || fails(function () {
	  var called;
	  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
	    called = true;
	  }) || called;
	}) ? isConstructorLegacy : isConstructorModern;

	var SPECIES$6 = wellKnownSymbol('species');
	var Array$8 = global_1.Array; // a part of `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate

	var arraySpeciesConstructor = function (originalArray) {
	  var C;

	  if (isArray$1(originalArray)) {
	    C = originalArray.constructor; // cross-realm fallback

	    if (isConstructor(C) && (C === Array$8 || isArray$1(C.prototype))) C = undefined;else if (isObject$1(C)) {
	      C = C[SPECIES$6];
	      if (C === null) C = undefined;
	    }
	  }

	  return C === undefined ? Array$8 : C;
	};

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate


	var arraySpeciesCreate = function (originalArray, length) {
	  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
	};

	var push$a = functionUncurryThis([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

	var createMethod$5 = function createMethod(TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var IS_FILTER_REJECT = TYPE == 7;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that);
	    var length = lengthOfArrayLike(self);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
	    var value, result;

	    for (; length > index; index++) {
	      if (NO_HOLES || index in self) {
	        value = self[index];
	        result = boundFunction(value, index, O);

	        if (TYPE) {
	          if (IS_MAP) target[index] = result; // map
	          else if (result) switch (TYPE) {
	            case 3:
	              return true;
	            // some

	            case 5:
	              return value;
	            // find

	            case 6:
	              return index;
	            // findIndex

	            case 2:
	              push$a(target, value);
	            // filter
	          } else switch (TYPE) {
	            case 4:
	              return false;
	            // every

	            case 7:
	              push$a(target, value);
	            // filterReject
	          }
	        }
	      }
	    }

	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$5(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$5(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$5(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$5(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$5(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$5(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$5(6),
	  // `Array.prototype.filterReject` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterReject: createMethod$5(7)
	};

	var $forEach$2 = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE$1 = wellKnownSymbol('toPrimitive');
	var setInternalState$9 = internalState.set;
	var getInternalState$8 = internalState.getterFor(SYMBOL);
	var ObjectPrototype$4 = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var SymbolPrototype$1 = $Symbol && $Symbol[PROTOTYPE$1];
	var TypeError$l = global_1.TypeError;
	var QObject = global_1.QObject;
	var $stringify$1 = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyNames = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable = objectPropertyIsEnumerable.f;
	var push$9 = functionUncurryThis([].push);
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore = shared('wks'); // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty({}, 'a', {
	    get: function get() {
	      return nativeDefineProperty(this, 'a', {
	        value: 7
	      }).a;
	    }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$4, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype$4[P];
	  nativeDefineProperty(O, P, Attributes);

	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$4) {
	    nativeDefineProperty(ObjectPrototype$4, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty;

	var wrap$1 = function wrap(tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate(SymbolPrototype$1);
	  setInternalState$9(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype$4) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPropertyKey(P);
	  anObject(Attributes);

	  if (hasOwnProperty_1(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!hasOwnProperty_1(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (hasOwnProperty_1(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate(Attributes, {
	        enumerable: createPropertyDescriptor(0, false)
	      });
	    }

	    return setSymbolDescriptor(O, key, Attributes);
	  }

	  return nativeDefineProperty(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach$2(keys, function (key) {
	    if (!descriptors || functionCall($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};

	var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
	  var P = toPropertyKey(V);
	  var enumerable = functionCall(nativePropertyIsEnumerable, this, P);
	  if (this === ObjectPrototype$4 && hasOwnProperty_1(AllSymbols, P) && !hasOwnProperty_1(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !hasOwnProperty_1(this, P) || !hasOwnProperty_1(AllSymbols, P) || hasOwnProperty_1(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPropertyKey(P);
	  if (it === ObjectPrototype$4 && hasOwnProperty_1(AllSymbols, key) && !hasOwnProperty_1(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

	  if (descriptor && hasOwnProperty_1(AllSymbols, key) && !(hasOwnProperty_1(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }

	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
	  var result = [];
	  $forEach$2(names, function (key) {
	    if (!hasOwnProperty_1(AllSymbols, key) && !hasOwnProperty_1(hiddenKeys$1, key)) push$9(result, key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$4;
	  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach$2(names, function (key) {
	    if (hasOwnProperty_1(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwnProperty_1(ObjectPrototype$4, key))) {
	      push$9(result, AllSymbols[key]);
	    }
	  });
	  return result;
	}; // `Symbol` constructor
	// https://tc39.es/ecma262/#sec-symbol-constructor


	if (!nativeSymbol) {
	  $Symbol = function _Symbol() {
	    if (objectIsPrototypeOf(SymbolPrototype$1, this)) throw TypeError$l('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : toString_1(arguments[0]);
	    var tag = uid(description);

	    var setter = function setter(value) {
	      if (this === ObjectPrototype$4) functionCall(setter, ObjectPrototypeSymbols, value);
	      if (hasOwnProperty_1(this, HIDDEN) && hasOwnProperty_1(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };

	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype$4, tag, {
	      configurable: true,
	      set: setter
	    });
	    return wrap$1(tag, description);
	  };

	  SymbolPrototype$1 = $Symbol[PROTOTYPE$1];
	  redefine(SymbolPrototype$1, 'toString', function toString() {
	    return getInternalState$8(this).tag;
	  });
	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap$1(uid(description), description);
	  });
	  objectPropertyIsEnumerable.f = $propertyIsEnumerable$1;
	  objectDefineProperty.f = $defineProperty;
	  objectDefineProperties.f = $defineProperties;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap$1(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty(SymbolPrototype$1, 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState$8(this).description;
	      }
	    });

	    {
	      redefine(ObjectPrototype$4, 'propertyIsEnumerable', $propertyIsEnumerable$1, {
	        unsafe: true
	      });
	    }
	  }
	}

	_export({
	  global: true,
	  wrap: true,
	  forced: !nativeSymbol,
	  sham: !nativeSymbol
	}, {
	  Symbol: $Symbol
	});
	$forEach$2(objectKeys(WellKnownSymbolsStore), function (name) {
	  defineWellKnownSymbol(name);
	});
	_export({
	  target: SYMBOL,
	  stat: true,
	  forced: !nativeSymbol
	}, {
	  // `Symbol.for` method
	  // https://tc39.es/ecma262/#sec-symbol.for
	  'for': function _for(key) {
	    var string = toString_1(key);
	    if (hasOwnProperty_1(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.es/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError$l(sym + ' is not a symbol');
	    if (hasOwnProperty_1(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function useSetter() {
	    USE_SETTER = true;
	  },
	  useSimple: function useSimple() {
	    USE_SETTER = false;
	  }
	});
	_export({
	  target: 'Object',
	  stat: true,
	  forced: !nativeSymbol,
	  sham: !descriptors
	}, {
	  // `Object.create` method
	  // https://tc39.es/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.es/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.es/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});
	_export({
	  target: 'Object',
	  stat: true,
	  forced: !nativeSymbol
	}, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443

	_export({
	  target: 'Object',
	  stat: true,
	  forced: fails(function () {
	    objectGetOwnPropertySymbols.f(1);
	  })
	}, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	}); // `JSON.stringify` method behavior with symbols
	// https://tc39.es/ecma262/#sec-json.stringify

	if ($stringify$1) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

	    return $stringify$1([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
	    || $stringify$1({
	      a: symbol
	    }) != '{}' // V8 throws on boxed symbols
	    || $stringify$1(Object(symbol)) != '{}';
	  });
	  _export({
	    target: 'JSON',
	    stat: true,
	    forced: FORCED_JSON_STRINGIFY
	  }, {
	    // eslint-disable-next-line no-unused-vars -- required for `.length`
	    stringify: function stringify(it, replacer, space) {
	      var args = arraySlice$1(arguments);
	      var $replacer = replacer;
	      if (!isObject$1(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

	      if (!isArray$1(replacer)) replacer = function replacer(key, value) {
	        if (isCallable($replacer)) value = functionCall($replacer, this, key, value);
	        if (!isSymbol(value)) return value;
	      };
	      args[1] = replacer;
	      return functionApply($stringify$1, null, args);
	    }
	  });
	} // `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive


	if (!SymbolPrototype$1[TO_PRIMITIVE$1]) {
	  var valueOf = SymbolPrototype$1.valueOf; // eslint-disable-next-line no-unused-vars -- required for .length

	  redefine(SymbolPrototype$1, TO_PRIMITIVE$1, function (hint) {
	    // TODO: improve hint logic
	    return functionCall(valueOf, this);
	  });
	} // `Symbol.prototype[@@toStringTag]` property
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag


	setToStringTag($Symbol, SYMBOL);
	hiddenKeys$1[HIDDEN] = true;

	var defineProperty$d = objectDefineProperty.f;



	var NativeSymbol = global_1.Symbol;
	var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

	if (descriptors && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) || // Safari 12 bug
	NativeSymbol().description !== undefined)) {
	  var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

	  var SymbolWrapper = function _Symbol() {
	    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString_1(arguments[0]);
	    var result = objectIsPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
	    : description === undefined ? NativeSymbol() : NativeSymbol(description);
	    if (description === '') EmptyStringDescriptionStore[result] = true;
	    return result;
	  };

	  copyConstructorProperties(SymbolWrapper, NativeSymbol);
	  SymbolWrapper.prototype = SymbolPrototype;
	  SymbolPrototype.constructor = SymbolWrapper;
	  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
	  var symbolToString = functionUncurryThis(SymbolPrototype.toString);
	  var symbolValueOf = functionUncurryThis(SymbolPrototype.valueOf);
	  var regexp = /^Symbol\((.*)\)[^)]+$/;
	  var replace$a = functionUncurryThis(''.replace);
	  var stringSlice$d = functionUncurryThis(''.slice);
	  defineProperty$d(SymbolPrototype, 'description', {
	    configurable: true,
	    get: function description() {
	      var symbol = symbolValueOf(this);
	      var string = symbolToString(symbol);
	      if (hasOwnProperty_1(EmptyStringDescriptionStore, symbol)) return '';
	      var desc = NATIVE_SYMBOL ? stringSlice$d(string, 7, -1) : replace$a(string, regexp, '$1');
	      return desc === '' ? undefined : desc;
	    }
	  });
	  _export({
	    global: true,
	    forced: true
	  }, {
	    Symbol: SymbolWrapper
	  });
	}

	// `Symbol.iterator` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.iterator


	defineWellKnownSymbol('iterator');

	var charAt$c = functionUncurryThis(''.charAt);
	var charCodeAt$5 = functionUncurryThis(''.charCodeAt);
	var stringSlice$c = functionUncurryThis(''.slice);

	var createMethod$4 = function createMethod(CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = toString_1(requireObjectCoercible($this));
	    var position = toIntegerOrInfinity(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = charCodeAt$5(S, position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt$5(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$c(S, position) : first : CONVERT_TO_STRING ? stringSlice$c(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$4(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$4(true)
	};

	var correctPrototypeGetter = !fails(function () {
	  function F() {
	    /* empty */
	  }

	  F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO = sharedKey('IE_PROTO');
	var Object$1 = global_1.Object;
	var ObjectPrototype$3 = Object$1.prototype; // `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof

	var objectGetPrototypeOf = correctPrototypeGetter ? Object$1.getPrototypeOf : function (O) {
	  var object = toObject(O);
	  if (hasOwnProperty_1(object, IE_PROTO)) return object[IE_PROTO];
	  var constructor = object.constructor;

	  if (isCallable(constructor) && object instanceof constructor) {
	    return constructor.prototype;
	  }

	  return object instanceof Object$1 ? ObjectPrototype$3 : null;
	};

	var ITERATOR$a = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false; // `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object

	var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
	/* eslint-disable es/no-array-prototype-keys -- safe */

	if ([].keys) {
	  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails(function () {
	  var test = {}; // FF44- legacy iterators case

	  return IteratorPrototype$2[ITERATOR$a].call(test) !== test;
	});
	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {}; // `%IteratorPrototype%[@@iterator]()` method
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

	if (!isCallable(IteratorPrototype$2[ITERATOR$a])) {
	  redefine(IteratorPrototype$2, ITERATOR$a, function () {
	    return this;
	  });
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$2,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	var iterators = {};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;









	var returnThis$1 = function returnThis() {
	  return this;
	};

	var createIteratorConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
	    next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next)
	  });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var _typeof$4 = require$$0["typeof"];





	var String$3 = global_1.String;
	var TypeError$k = global_1.TypeError;

	var aPossiblePrototype = function (argument) {
	  if (_typeof$4(argument) == 'object' || isCallable(argument)) return argument;
	  throw TypeError$k("Can't set " + String$3(argument) + ' as a prototype');
	};

	/* eslint-disable no-proto -- safe */




	 // `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	// eslint-disable-next-line es/no-object-setprototypeof -- safe


	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;

	  try {
	    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	    setter = functionUncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
	    setter(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) {
	    /* empty */
	  }

	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var PROPER_FUNCTION_NAME$3 = functionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
	var IteratorPrototype = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$9 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function returnThis() {
	  return this;
	};

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function getIterationMethod(KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

	    switch (KIND) {
	      case KEYS:
	        return function keys() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case VALUES:
	        return function values() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case ENTRIES:
	        return function entries() {
	          return new IteratorConstructor(this, KIND);
	        };
	    }

	    return function () {
	      return new IteratorConstructor(this);
	    };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$9] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY; // fix native

	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

	    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
	        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$9])) {
	          redefine(CurrentIteratorPrototype, ITERATOR$9, returnThis);
	        }
	      } // Set @@toStringTag to native iterators


	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


	  if (PROPER_FUNCTION_NAME$3 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    if (CONFIGURABLE_FUNCTION_NAME$1) {
	      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
	    } else {
	      INCORRECT_VALUES_NAME = true;

	      defaultIterator = function values() {
	        return functionCall(nativeIterator, this);
	      };
	    }
	  } // export additional methods


	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({
	      target: NAME,
	      proto: true,
	      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
	    }, methods);
	  } // define iterator


	  if (IterablePrototype[ITERATOR$9] !== defaultIterator) {
	    redefine(IterablePrototype, ITERATOR$9, defaultIterator, {
	      name: DEFAULT
	    });
	  }

	  iterators[NAME] = defaultIterator;
	  return methods;
	};

	var charAt$b = stringMultibyte.charAt;







	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$8 = internalState.set;
	var getInternalState$7 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator

	defineIterator(String, 'String', function (iterated) {
	  setInternalState$8(this, {
	    type: STRING_ITERATOR,
	    string: toString_1(iterated),
	    index: 0
	  }); // `%StringIteratorPrototype%.next` method
	  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$7(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return {
	    value: undefined,
	    done: true
	  };
	  point = charAt$b(string, index);
	  state.index += point.length;
	  return {
	    value: point,
	    done: false
	  };
	});

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`


	var classList = documentCreateElement('span').classList;
	var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
	var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype$1 = Array.prototype; // Array.prototype[@@unscopables]
	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	} // add a key to Array.prototype[@@unscopables]


	var addToUnscopables = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	var defineProperty$c = objectDefineProperty.f;







	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$7 = internalState.set;
	var getInternalState$6 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator

	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$7(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated),
	    // target
	    index: 0,
	    // next index
	    kind: kind // kind

	  }); // `%ArrayIteratorPrototype%.next` method
	  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$6(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;

	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return {
	      value: undefined,
	      done: true
	    };
	  }

	  if (kind == 'keys') return {
	    value: index,
	    done: false
	  };
	  if (kind == 'values') return {
	    value: target[index],
	    done: false
	  };
	  return {
	    value: [index, target[index]],
	    done: false
	  };
	}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject

	var values = iterators.Arguments = iterators.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries'); // V8 ~ Chrome 45- bug

	if (descriptors && values.name !== 'values') try {
	  defineProperty$c(values, 'name', {
	    value: 'values'
	  });
	} catch (error) {
	  /* empty */
	}

	var ITERATOR$8 = wellKnownSymbol('iterator');
	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;

	var handlePrototype$1 = function handlePrototype(CollectionPrototype, COLLECTION_NAME) {
	  if (CollectionPrototype) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype[ITERATOR$8] !== ArrayValues) try {
	      createNonEnumerableProperty(CollectionPrototype, ITERATOR$8, ArrayValues);
	    } catch (error) {
	      CollectionPrototype[ITERATOR$8] = ArrayValues;
	    }

	    if (!CollectionPrototype[TO_STRING_TAG$1]) {
	      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);
	    }

	    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
	        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      }
	    }
	  }
	};

	for (var COLLECTION_NAME$1 in domIterables) {
	  handlePrototype$1(global_1[COLLECTION_NAME$1] && global_1[COLLECTION_NAME$1].prototype, COLLECTION_NAME$1);
	}

	handlePrototype$1(domTokenListPrototype, 'DOMTokenList');

	var _typeof_1 = createCommonjsModule(function (module) {
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
	}

	module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	unwrapExports(_typeof_1);

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.asynciterator


	defineWellKnownSymbol('asyncIterator');

	// `Symbol.toStringTag` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.tostringtag


	defineWellKnownSymbol('toStringTag');

	// JSON[@@toStringTag] property
	// https://tc39.es/ecma262/#sec-json-@@tostringtag


	setToStringTag(global_1.JSON, 'JSON', true);

	// Math[@@toStringTag] property
	// https://tc39.es/ecma262/#sec-math-@@tostringtag


	setToStringTag(Math, 'Math', true);

	var defineProperty$b = objectDefineProperty.f; // `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	// eslint-disable-next-line es/no-object-defineproperty -- safe


	_export({
	  target: 'Object',
	  stat: true,
	  forced: Object.defineProperty !== defineProperty$b,
	  sham: !descriptors
	}, {
	  defineProperty: defineProperty$b
	});

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create


	_export({
	  target: 'Object',
	  stat: true,
	  sham: !descriptors
	}, {
	  create: objectCreate
	});

	var FAILS_ON_PRIMITIVES$9 = fails(function () {
	  objectGetPrototypeOf(1);
	}); // `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$9,
	  sham: !correctPrototypeGetter
	}, {
	  getPrototypeOf: function getPrototypeOf(it) {
	    return objectGetPrototypeOf(toObject(it));
	  }
	});

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call -- required for testing
	    method.call(null, argument || function () {
	      return 1;
	    }, 1);
	  });
	};

	var $forEach$1 = arrayIteration.forEach;



	var STRICT_METHOD$8 = arrayMethodIsStrict('forEach'); // `Array.prototype.forEach` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.foreach

	var arrayForEach = !STRICT_METHOD$8 ? function forEach(callbackfn
	/* , thisArg */
	) {
	  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es/no-array-prototype-foreach -- safe
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.es/ecma262/#sec-array.prototype.foreach
	// eslint-disable-next-line es/no-array-prototype-foreach -- safe


	_export({
	  target: 'Array',
	  proto: true,
	  forced: [].forEach != arrayForEach
	}, {
	  forEach: arrayForEach
	});

	var FUNCTION_NAME_EXISTS = functionName.EXISTS;



	var defineProperty$a = objectDefineProperty.f;

	var FunctionPrototype$1 = Function.prototype;
	var functionToString = functionUncurryThis(FunctionPrototype$1.toString);
	var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
	var regExpExec = functionUncurryThis(nameRE.exec);
	var NAME$1 = 'name'; // Function instances `.name` property
	// https://tc39.es/ecma262/#sec-function-instances-name

	if (descriptors && !FUNCTION_NAME_EXISTS) {
	  defineProperty$a(FunctionPrototype$1, NAME$1, {
	    configurable: true,
	    get: function get() {
	      try {
	        return regExpExec(nameRE, functionToString(this))[1];
	      } catch (error) {
	        return '';
	      }
	    }
	  });
	}

	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof


	_export({
	  target: 'Object',
	  stat: true
	}, {
	  setPrototypeOf: objectSetPrototypeOf
	});

	// makes subclassing work correct for wrapped built-ins


	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if ( // it can work only with native `setPrototypeOf`
	  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	  isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$1(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	var normalizeStringArgument = function (argument, $default) {
	  return argument === undefined ? arguments.length < 2 ? '' : $default : toString_1(argument);
	};

	// `InstallErrorCause` abstract operation
	// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause


	var installErrorCause = function (O, options) {
	  if (isObject$1(options) && 'cause' in options) {
	    createNonEnumerableProperty(O, 'cause', options.cause);
	  }
	};

	var replace$9 = functionUncurryThis(''.replace);

	var TEST = function (arg) {
	  return String(Error(arg).stack);
	}('zxcasd');

	var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
	var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

	var clearErrorStack = function (stack, dropEntries) {
	  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string') {
	    while (dropEntries--) {
	      stack = replace$9(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
	    }
	  }

	  return stack;
	};

	var errorStackInstallable = !fails(function () {
	  var error = Error('a');
	  if (!('stack' in error)) return true; // eslint-disable-next-line es/no-object-defineproperty -- safe

	  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
	  return error.stack !== 7;
	});

	var wrapErrorConstructorWithCause = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
	  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
	  var path = FULL_NAME.split('.');
	  var ERROR_NAME = path[path.length - 1];
	  var OriginalError = getBuiltIn.apply(null, path);
	  if (!OriginalError) return;
	  var OriginalErrorPrototype = OriginalError.prototype; // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006

	  if (hasOwnProperty_1(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;
	  if (!FORCED) return OriginalError;
	  var BaseError = getBuiltIn('Error');
	  var WrappedError = wrapper(function (a, b) {
	    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
	    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
	    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
	    if (errorStackInstallable) createNonEnumerableProperty(result, 'stack', clearErrorStack(result.stack, 2));
	    if (this && objectIsPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
	    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
	    return result;
	  });
	  WrappedError.prototype = OriginalErrorPrototype;

	  if (ERROR_NAME !== 'Error') {
	    if (objectSetPrototypeOf) objectSetPrototypeOf(WrappedError, BaseError);else copyConstructorProperties(WrappedError, BaseError, {
	      name: true
	    });
	  }

	  copyConstructorProperties(WrappedError, OriginalError);
	  try {
	    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
	    if (OriginalErrorPrototype.name !== ERROR_NAME) {
	      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
	    }

	    OriginalErrorPrototype.constructor = WrappedError;
	  } catch (error) {
	    /* empty */
	  }
	  return WrappedError;
	};

	/* eslint-disable no-unused-vars -- required for functions `.length` */








	var WEB_ASSEMBLY = 'WebAssembly';
	var WebAssembly = global_1[WEB_ASSEMBLY];
	var FORCED$m = Error('e', {
	  cause: 7
	}).cause !== 7;

	var exportGlobalErrorCauseWrapper = function exportGlobalErrorCauseWrapper(ERROR_NAME, wrapper) {
	  var O = {};
	  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED$m);
	  _export({
	    global: true,
	    forced: FORCED$m
	  }, O);
	};

	var exportWebAssemblyErrorCauseWrapper = function exportWebAssemblyErrorCauseWrapper(ERROR_NAME, wrapper) {
	  if (WebAssembly && WebAssembly[ERROR_NAME]) {
	    var O = {};
	    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED$m);
	    _export({
	      target: WEB_ASSEMBLY,
	      stat: true,
	      forced: FORCED$m
	    }, O);
	  }
	}; // https://github.com/tc39/proposal-error-cause


	exportGlobalErrorCauseWrapper('Error', function (init) {
	  return function Error(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportGlobalErrorCauseWrapper('EvalError', function (init) {
	  return function EvalError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportGlobalErrorCauseWrapper('RangeError', function (init) {
	  return function RangeError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
	  return function ReferenceError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
	  return function SyntaxError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportGlobalErrorCauseWrapper('TypeError', function (init) {
	  return function TypeError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportGlobalErrorCauseWrapper('URIError', function (init) {
	  return function URIError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
	  return function CompileError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
	  return function LinkError(message) {
	    return functionApply(init, this, arguments);
	  };
	});
	exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
	  return function RuntimeError(message) {
	    return functionApply(init, this, arguments);
	  };
	});

	var nativeErrorToString = Error.prototype.toString;
	var INCORRECT_TO_STRING$1 = fails(function () {
	  if (descriptors) {
	    // Chrome 32- incorrectly call accessor
	    // eslint-disable-next-line es/no-object-defineproperty -- safe
	    var object = objectCreate(Object.defineProperty({}, 'name', {
	      get: function get() {
	        return this === object;
	      }
	    }));
	    if (nativeErrorToString.call(object) !== 'true') return true;
	  } // FF10- does not properly handle non-strings


	  return nativeErrorToString.call({
	    message: 1,
	    name: 2
	  }) !== '2: 1' // IE8 does not properly handle defaults
	  || nativeErrorToString.call({}) !== 'Error';
	});
	var errorToString = INCORRECT_TO_STRING$1 ? function toString() {
	  var O = anObject(this);
	  var name = normalizeStringArgument(O.name, 'Error');
	  var message = normalizeStringArgument(O.message);
	  return !name ? message : !message ? name : name + ': ' + message;
	} : nativeErrorToString;

	var ErrorPrototype$1 = Error.prototype; // `Error.prototype.toString` method fix
	// https://tc39.es/ecma262/#sec-error.prototype.tostring

	if (ErrorPrototype$1.toString !== errorToString) {
	  redefine(ErrorPrototype$1, 'toString', errorToString);
	}

	var handlePrototype = function handlePrototype(CollectionPrototype) {
	  // some Chrome versions have non-configurable methods on DOMTokenList
	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  }
	};

	for (var COLLECTION_NAME in domIterables) {
	  if (domIterables[COLLECTION_NAME]) {
	    handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype);
	  }
	}

	handlePrototype(domTokenListPrototype);

	var un$Reverse = functionUncurryThis([].reverse);
	var test$1 = [1, 2]; // `Array.prototype.reverse` method
	// https://tc39.es/ecma262/#sec-array.prototype.reverse
	// fix for Safari 12.0 bug
	// https://bugs.webkit.org/show_bug.cgi?id=188794

	_export({
	  target: 'Array',
	  proto: true,
	  forced: String(test$1) === String(test$1.reverse())
	}, {
	  reverse: function reverse() {
	    // eslint-disable-next-line no-self-assign -- dirty hack
	    if (isArray$1(this)) this.length = this.length;
	    return un$Reverse(this);
	  }
	});

	var SPECIES$5 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};

	    constructor[SPECIES$5] = function () {
	      return {
	        foo: 1
	      };
	    };

	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('slice');
	var SPECIES$4 = wellKnownSymbol('species');
	var Array$7 = global_1.Array;
	var max$4 = Math.max; // `Array.prototype.slice` method
	// https://tc39.es/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT$3
	}, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = lengthOfArrayLike(O);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

	    var Constructor, result, n;

	    if (isArray$1(O)) {
	      Constructor = O.constructor; // cross-realm fallback

	      if (isConstructor(Constructor) && (Constructor === Array$7 || isArray$1(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject$1(Constructor)) {
	        Constructor = Constructor[SPECIES$4];
	        if (Constructor === null) Constructor = undefined;
	      }

	      if (Constructor === Array$7 || Constructor === undefined) {
	        return arraySlice$1(O, k, fin);
	      }
	    }

	    result = new (Constructor === undefined ? Array$7 : Constructor)(max$4(fin - k, 0));

	    for (n = 0; k < fin; k++, n++) {
	      if (k in O) createProperty(result, n, O[k]);
	    }

	    result.length = n;
	    return result;
	  }
	});

	// `globalThis` object
	// https://tc39.es/ecma262/#sec-globalthis


	_export({
	  global: true
	}, {
	  globalThis: global_1
	});

	createCommonjsModule(function (module) {
	var _typeof = _typeof_1["default"];













































	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var runtime = function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.

	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }

	  try {
	    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
	    define({}, "");
	  } catch (err) {
	    define = function define(obj, key, value) {
	      return obj[key] = value;
	    };
	  }

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.

	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	    return generator;
	  }

	  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.

	  function tryCatch(fn, obj, arg) {
	    try {
	      return {
	        type: "normal",
	        arg: fn.call(obj, arg)
	      };
	    } catch (err) {
	      return {
	        type: "throw",
	        arg: err
	      };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.

	  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.

	  function Generator() {}

	  function GeneratorFunction() {}

	  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.


	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

	  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = GeneratorFunctionPrototype;
	  define(Gp, "constructor", GeneratorFunctionPrototype);
	  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
	  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.

	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      define(prototype, method, function (arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }

	  exports.isGeneratorFunction = function (genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
	    // do is to check its .name property.
	    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	  };

	  exports.mark = function (genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }

	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  }; // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.


	  exports.awrap = function (arg) {
	    return {
	      __await: arg
	    };
	  };

	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);

	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;

	        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function (value) {
	            invoke("next", value, resolve, reject);
	          }, function (err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return PromiseImpl.resolve(value).then(function (unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function (error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function (resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise = // If enqueue has been called before, then we want to wait until
	      // all previous Promises have been resolved before calling invoke,
	      // so that results are always delivered in the correct order. If
	      // enqueue has not been called before, then it is important to
	      // call invoke immediately, without waiting on a callback to fire,
	      // so that the async generator function has the opportunity to do
	      // any necessary setup in a predictable way. This predictability
	      // is why the Promise constructor synchronously invokes its
	      // executor callback, and why async functions synchronously
	      // execute code before the first await. Since we implement simple
	      // async functions in terms of async generators, it is especially
	      // important to get this right, even though it requires care.
	      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
	      // invocations of the iterator.
	      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	    } // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).


	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  });
	  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.

	  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
	    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	    : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        } // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;

	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);

	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;
	        var record = tryCatch(innerFn, self, context);

	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };
	        } else if (record.type === "throw") {
	          state = GenStateCompleted; // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.

	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  } // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.


	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];

	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError("The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (!info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

	      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.

	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    } // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.


	    context.delegate = null;
	    return ContinueSentinel;
	  } // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.


	  defineIteratorMethods(Gp);
	  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.

	  define(Gp, iteratorSymbol, function () {
	    return this;
	  });
	  define(Gp, "toString", function () {
	    return "[object Generator]";
	  });

	  function pushTryEntry(locs) {
	    var entry = {
	      tryLoc: locs[0]
	    };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{
	      tryLoc: "root"
	    }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function (object) {
	    var keys = [];

	    for (var key in object) {
	      keys.push(key);
	    }

	    keys.reverse(); // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.

	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();

	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      } // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.


	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];

	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1,
	            next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;
	          return next;
	        };

	        return next.next = next;
	      }
	    } // Return an iterator with no values.


	    return {
	      next: doneResult
	    };
	  }

	  exports.values = values;

	  function doneResult() {
	    return {
	      value: undefined$1,
	      done: true
	    };
	  }

	  Context.prototype = {
	    constructor: Context,
	    reset: function reset(skipTempReset) {
	      this.prev = 0;
	      this.next = 0; // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.

	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;
	      this.method = "next";
	      this.arg = undefined$1;
	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },
	    stop: function stop() {
	      this.done = true;
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;

	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },
	    dispatchException: function dispatchException(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;

	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !!caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];

	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },
	    complete: function complete(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" || record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];

	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];

	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;

	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }

	          return thrown;
	        }
	      } // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.


	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  }; // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.

	  return exports;
	}( // If this script is executing as a CommonJS module, use module.exports
	// as the regeneratorRuntime namespace. Otherwise create a new empty
	// object. Either way, the resulting object will be used to initialize
	// the regeneratorRuntime variable at the top of this file.
	(_typeof(module)) === "object" ? module.exports : {});

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, in modern engines
	  // we can explicitly access globalThis. In older engines we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
	    globalThis.regeneratorRuntime = runtime;
	  } else {
	    Function("r", "regeneratorRuntime = r")(runtime);
	  }
	}
	});

	var DatePrototype$2 = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING$1 = 'toString';
	var un$DateToString = functionUncurryThis(DatePrototype$2[TO_STRING$1]);
	var getTime$2 = functionUncurryThis(DatePrototype$2.getTime); // `Date.prototype.toString` method
	// https://tc39.es/ecma262/#sec-date.prototype.tostring

	if (String(new Date(NaN)) != INVALID_DATE) {
	  redefine(DatePrototype$2, TO_STRING$1, function toString() {
	    var value = getTime$2(this); // eslint-disable-next-line no-self-compare -- NaN check

	    return value === value ? un$DateToString(this) : INVALID_DATE;
	  });
	}

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
	var TypeError$j = global_1.TypeError; // We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679

	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});
	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function isConcatSpreadable(O) {
	  if (!isObject$1(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray$1(O);
	};

	var FORCED$l = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
	// https://tc39.es/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species

	_export({
	  target: 'Array',
	  proto: true,
	  forced: FORCED$l
	}, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  concat: function concat(arg) {
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;

	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];

	      if (isConcatSpreadable(E)) {
	        len = lengthOfArrayLike(E);
	        if (n + len > MAX_SAFE_INTEGER$1) throw TypeError$j(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

	        for (k = 0; k < len; k++, n++) {
	          if (k in E) createProperty(A, n, E[k]);
	        }
	      } else {
	        if (n >= MAX_SAFE_INTEGER$1) throw TypeError$j(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }

	    A.length = n;
	    return A;
	  }
	});

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags


	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError


	var $RegExp$2 = global_1.RegExp;
	var UNSUPPORTED_Y$3 = fails(function () {
	  var re = $RegExp$2('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	}); // UC Browser bug
	// https://github.com/zloirock/core-js/issues/1008

	var MISSED_STICKY$2 = UNSUPPORTED_Y$3 || fails(function () {
	  return !$RegExp$2('a', 'y').sticky;
	});
	var BROKEN_CARET = UNSUPPORTED_Y$3 || fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = $RegExp$2('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});
	var regexpStickyHelpers = {
	  BROKEN_CARET: BROKEN_CARET,
	  MISSED_STICKY: MISSED_STICKY$2,
	  UNSUPPORTED_Y: UNSUPPORTED_Y$3
	};

	// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError


	var $RegExp$1 = global_1.RegExp;
	var regexpUnsupportedDotAll = fails(function () {
	  var re = $RegExp$1('.', 's');
	  return !(re.dotAll && re.exec('\n') && re.flags === 's');
	});

	// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError


	var $RegExp = global_1.RegExp;
	var regexpUnsupportedNcg = fails(function () {
	  var re = $RegExp('(?<a>b)', 'g');
	  return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc';
	});

	/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */

	/* eslint-disable regexp/no-useless-quantifier -- testing */















	var getInternalState$5 = internalState.get;





	var nativeReplace = shared('native-string-replace', String.prototype.replace);
	var nativeExec = RegExp.prototype.exec;
	var patchedExec = nativeExec;
	var charAt$a = functionUncurryThis(''.charAt);
	var indexOf = functionUncurryThis(''.indexOf);
	var replace$8 = functionUncurryThis(''.replace);
	var stringSlice$b = functionUncurryThis(''.slice);

	var UPDATES_LAST_INDEX_WRONG = function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  functionCall(nativeExec, re1, 'a');
	  functionCall(nativeExec, re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	}();

	var UNSUPPORTED_Y$2 = regexpStickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.

	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$2 || regexpUnsupportedDotAll || regexpUnsupportedNcg;

	if (PATCH) {
	  patchedExec = function exec(string) {
	    var re = this;
	    var state = getInternalState$5(re);
	    var str = toString_1(string);
	    var raw = state.raw;
	    var result, reCopy, lastIndex, match, i, object, group;

	    if (raw) {
	      raw.lastIndex = re.lastIndex;
	      result = functionCall(patchedExec, raw, str);
	      re.lastIndex = raw.lastIndex;
	      return result;
	    }

	    var groups = state.groups;
	    var sticky = UNSUPPORTED_Y$2 && re.sticky;
	    var flags = functionCall(regexpFlags, re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = replace$8(flags, 'y', '');

	      if (indexOf(flags, 'g') === -1) {
	        flags += 'g';
	      }

	      strCopy = stringSlice$b(str, re.lastIndex); // Support anchored sticky behavior.

	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$a(str, re.lastIndex - 1) !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      } // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.


	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }

	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
	    match = functionCall(nativeExec, sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = stringSlice$b(match.input, charsAdded);
	        match[0] = stringSlice$b(match[0], charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }

	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      functionCall(nativeReplace, match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    if (match && groups) {
	      match.groups = object = objectCreate(null);

	      for (i = 0; i < groups.length; i++) {
	        group = groups[i];
	        object[group[0]] = match[group[1]];
	      }
	    }

	    return match;
	  };
	}

	var regexpExec = patchedExec;

	// `RegExp.prototype.exec` method
	// https://tc39.es/ecma262/#sec-regexp.prototype.exec


	_export({
	  target: 'RegExp',
	  proto: true,
	  forced: /./.exec !== regexpExec
	}, {
	  exec: regexpExec
	});

	var SPECIES$3 = wellKnownSymbol('species');
	var RegExpPrototype$5 = RegExp.prototype;

	var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
	  var SYMBOL = wellKnownSymbol(KEY);
	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};

	    O[SYMBOL] = function () {
	      return 7;
	    };

	    return ''[KEY](O) != 7;
	  });
	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.

	      re.constructor = {};

	      re.constructor[SPECIES$3] = function () {
	        return re;
	      };

	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }

	    re.exec = function () {
	      execCalled = true;
	      return null;
	    };

	    re[SYMBOL]('');
	    return !execCalled;
	  });

	  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
	    var uncurriedNativeRegExpMethod = functionUncurryThis(/./[SYMBOL]);
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      var uncurriedNativeMethod = functionUncurryThis(nativeMethod);
	      var $exec = regexp.exec;

	      if ($exec === regexpExec || $exec === RegExpPrototype$5.exec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return {
	            done: true,
	            value: uncurriedNativeRegExpMethod(regexp, str, arg2)
	          };
	        }

	        return {
	          done: true,
	          value: uncurriedNativeMethod(str, regexp, arg2)
	        };
	      }

	      return {
	        done: false
	      };
	    });
	    redefine(String.prototype, KEY, methods[0]);
	    redefine(RegExpPrototype$5, SYMBOL, methods[1]);
	  }

	  if (SHAM) createNonEnumerableProperty(RegExpPrototype$5[SYMBOL], 'sham', true);
	};

	var charAt$9 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
	// https://tc39.es/ecma262/#sec-advancestringindex


	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt$9(S, index).length : 1);
	};

	var floor$9 = Math.floor;
	var charAt$8 = functionUncurryThis(''.charAt);
	var replace$7 = functionUncurryThis(''.replace);
	var stringSlice$a = functionUncurryThis(''.slice);
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g; // `GetSubstitution` abstract operation
	// https://tc39.es/ecma262/#sec-getsubstitution

	var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
	  var tailPos = position + matched.length;
	  var m = captures.length;
	  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

	  if (namedCaptures !== undefined) {
	    namedCaptures = toObject(namedCaptures);
	    symbols = SUBSTITUTION_SYMBOLS;
	  }

	  return replace$7(replacement, symbols, function (match, ch) {
	    var capture;

	    switch (charAt$8(ch, 0)) {
	      case '$':
	        return '$';

	      case '&':
	        return matched;

	      case '`':
	        return stringSlice$a(str, 0, position);

	      case "'":
	        return stringSlice$a(str, tailPos);

	      case '<':
	        capture = namedCaptures[stringSlice$a(ch, 1, -1)];
	        break;

	      default:
	        // \d\d?
	        var n = +ch;
	        if (n === 0) return match;

	        if (n > m) {
	          var f = floor$9(n / 10);
	          if (f === 0) return match;
	          if (f <= m) return captures[f - 1] === undefined ? charAt$8(ch, 1) : captures[f - 1] + charAt$8(ch, 1);
	          return match;
	        }

	        capture = captures[n - 1];
	    }

	    return capture === undefined ? '' : capture;
	  });
	};

	var TypeError$i = global_1.TypeError; // `RegExpExec` abstract operation
	// https://tc39.es/ecma262/#sec-regexpexec

	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;

	  if (isCallable(exec)) {
	    var result = functionCall(exec, R, S);
	    if (result !== null) anObject(result);
	    return result;
	  }

	  if (classofRaw(R) === 'RegExp') return functionCall(regexpExec, R, S);
	  throw TypeError$i('RegExp#exec called on incompatible receiver');
	};

	var REPLACE = wellKnownSymbol('replace');
	var max$3 = Math.max;
	var min$7 = Math.min;
	var concat$2 = functionUncurryThis([].concat);
	var push$8 = functionUncurryThis([].push);
	var stringIndexOf$2 = functionUncurryThis(''.indexOf);
	var stringSlice$9 = functionUncurryThis(''.slice);

	var maybeToString = function maybeToString(it) {
	  return it === undefined ? it : String(it);
	}; // IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0


	var REPLACE_KEEPS_$0 = function () {
	  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
	  return 'a'.replace(/./, '$0') === '$0';
	}(); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string


	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
	  if (/./[REPLACE]) {
	    return /./[REPLACE]('a', '$0') === '';
	  }

	  return false;
	}();

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  var re = /./;

	  re.exec = function () {
	    var result = [];
	    result.groups = {
	      a: '7'
	    };
	    return result;
	  }; // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive


	  return ''.replace(re, '$<a>') !== '7';
	}); // @@replace logic

	fixRegexpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
	  return [// `String.prototype.replace` method
	  // https://tc39.es/ecma262/#sec-string.prototype.replace
	  function replace(searchValue, replaceValue) {
	    var O = requireObjectCoercible(this);
	    var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);
	    return replacer ? functionCall(replacer, searchValue, O, replaceValue) : functionCall(nativeReplace, toString_1(O), searchValue, replaceValue);
	  }, // `RegExp.prototype[@@replace]` method
	  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
	  function (string, replaceValue) {
	    var rx = anObject(this);
	    var S = toString_1(string);

	    if (typeof replaceValue == 'string' && stringIndexOf$2(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$2(replaceValue, '$<') === -1) {
	      var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
	      if (res.done) return res.value;
	    }

	    var functionalReplace = isCallable(replaceValue);
	    if (!functionalReplace) replaceValue = toString_1(replaceValue);
	    var global = rx.global;

	    if (global) {
	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	    }

	    var results = [];

	    while (true) {
	      var result = regexpExecAbstract(rx, S);
	      if (result === null) break;
	      push$8(results, result);
	      if (!global) break;
	      var matchStr = toString_1(result[0]);
	      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	    }

	    var accumulatedResult = '';
	    var nextSourcePosition = 0;

	    for (var i = 0; i < results.length; i++) {
	      result = results[i];
	      var matched = toString_1(result[0]);
	      var position = max$3(min$7(toIntegerOrInfinity(result.index), S.length), 0);
	      var captures = []; // NOTE: This is equivalent to
	      //   captures = result.slice(1).map(maybeToString)
	      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

	      for (var j = 1; j < result.length; j++) {
	        push$8(captures, maybeToString(result[j]));
	      }

	      var namedCaptures = result.groups;

	      if (functionalReplace) {
	        var replacerArgs = concat$2([matched], captures, position, S);
	        if (namedCaptures !== undefined) push$8(replacerArgs, namedCaptures);
	        var replacement = toString_1(functionApply(replaceValue, undefined, replacerArgs));
	      } else {
	        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	      }

	      if (position >= nextSourcePosition) {
	        accumulatedResult += stringSlice$9(S, nextSourcePosition, position) + replacement;
	        nextSourcePosition = position + matched.length;
	      }
	    }

	    return accumulatedResult + stringSlice$9(S, nextSourcePosition);
	  }];
	}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

	var PROPER_FUNCTION_NAME$2 = functionName.PROPER;













	var TO_STRING = 'toString';
	var RegExpPrototype$4 = RegExp.prototype;
	var n$ToString = RegExpPrototype$4[TO_STRING];
	var getFlags$1 = functionUncurryThis(regexpFlags);
	var NOT_GENERIC = fails(function () {
	  return n$ToString.call({
	    source: 'a',
	    flags: 'b'
	  }) != '/a/b';
	}); // FF44- RegExp#toString has a wrong name

	var INCORRECT_NAME = PROPER_FUNCTION_NAME$2 && n$ToString.name != TO_STRING; // `RegExp.prototype.toString` method
	// https://tc39.es/ecma262/#sec-regexp.prototype.tostring

	if (NOT_GENERIC || INCORRECT_NAME) {
	  redefine(RegExp.prototype, TO_STRING, function toString() {
	    var R = anObject(this);
	    var p = toString_1(R.source);
	    var rf = R.flags;
	    var f = toString_1(rf === undefined && objectIsPrototypeOf(RegExpPrototype$4, R) && !('flags' in RegExpPrototype$4) ? getFlags$1(R) : rf);
	    return '/' + p + '/' + f;
	  }, {
	    unsafe: true
	  });
	}

	// a string of all valid unicode whitespaces
	var whitespaces = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002" + "\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

	var replace$6 = functionUncurryThis(''.replace);
	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

	var createMethod$3 = function createMethod(TYPE) {
	  return function ($this) {
	    var string = toString_1(requireObjectCoercible($this));
	    if (TYPE & 1) string = replace$6(string, ltrim, '');
	    if (TYPE & 2) string = replace$6(string, rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$3(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimend
	  end: createMethod$3(2),
	  // `String.prototype.trim` method
	  // https://tc39.es/ecma262/#sec-string.prototype.trim
	  trim: createMethod$3(3)
	};

	var trim$3 = stringTrim.trim;



	var $parseInt = global_1.parseInt;
	var _Symbol$1 = global_1.Symbol;
	var ITERATOR$7 = _Symbol$1 && _Symbol$1.iterator;
	var hex$1 = /^[+-]?0x/i;
	var exec$7 = functionUncurryThis(hex$1.exec);
	var FORCED$k = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22 // MS Edge 18- broken with boxed symbols
	|| ITERATOR$7 && !fails(function () {
	  $parseInt(Object(ITERATOR$7));
	}); // `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix

	var numberParseInt = FORCED$k ? function parseInt(string, radix) {
	  var S = trim$3(toString_1(string));
	  return $parseInt(S, radix >>> 0 || (exec$7(hex$1, S) ? 16 : 10));
	} : $parseInt;

	// `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix


	_export({
	  global: true,
	  forced: parseInt != numberParseInt
	}, {
	  parseInt: numberParseInt
	});

	var MATCH$2 = wellKnownSymbol('match'); // `IsRegExp` abstract operation
	// https://tc39.es/ecma262/#sec-isregexp

	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject$1(it) && ((isRegExp = it[MATCH$2]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var TypeError$h = global_1.TypeError; // `Assert: IsConstructor(argument) is true`

	var aConstructor = function (argument) {
	  if (isConstructor(argument)) return argument;
	  throw TypeError$h(tryToString(argument) + ' is not a constructor');
	};

	var SPECIES$2 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-speciesconstructor

	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);
	};

	var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y;
	var MAX_UINT32 = 0xFFFFFFFF;
	var min$6 = Math.min;
	var $push = [].push;
	var exec$6 = functionUncurryThis(/./.exec);
	var push$7 = functionUncurryThis($push);
	var stringSlice$8 = functionUncurryThis(''.slice); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	// Weex JS has frozen built-in prototypes, so use try / catch wrapper

	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
	  // eslint-disable-next-line regexp/no-empty-group -- required for testing
	  var re = /(?:)/;
	  var originalExec = re.exec;

	  re.exec = function () {
	    return originalExec.apply(this, arguments);
	  };

	  var result = 'ab'.split(re);
	  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
	}); // @@split logic

	fixRegexpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
	  var internalSplit;

	  if ('abbc'.split(/(b)*/)[1] == 'c' || // eslint-disable-next-line regexp/no-empty-group -- required for testing
	  'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
	  '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function internalSplit(separator, limit) {
	      var string = toString_1(requireObjectCoercible(this));
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

	      if (!isRegexp(separator)) {
	        return functionCall(nativeSplit, string, separator, lim);
	      }

	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;

	      while (match = functionCall(regexpExec, separatorCopy, string)) {
	        lastIndex = separatorCopy.lastIndex;

	        if (lastIndex > lastLastIndex) {
	          push$7(output, stringSlice$8(string, lastLastIndex, match.index));
	          if (match.length > 1 && match.index < string.length) functionApply($push, output, arraySliceSimple(match, 1));
	          lastLength = match[0].length;
	          lastLastIndex = lastIndex;
	          if (output.length >= lim) break;
	        }

	        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
	      }

	      if (lastLastIndex === string.length) {
	        if (lastLength || !exec$6(separatorCopy, '')) push$7(output, '');
	      } else push$7(output, stringSlice$8(string, lastLastIndex));

	      return output.length > lim ? arraySliceSimple(output, 0, lim) : output;
	    }; // Chakra, V8

	  } else if ('0'.split(undefined, 0).length) {
	    internalSplit = function internalSplit(separator, limit) {
	      return separator === undefined && limit === 0 ? [] : functionCall(nativeSplit, this, separator, limit);
	    };
	  } else internalSplit = nativeSplit;

	  return [// `String.prototype.split` method
	  // https://tc39.es/ecma262/#sec-string.prototype.split
	  function split(separator, limit) {
	    var O = requireObjectCoercible(this);
	    var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
	    return splitter ? functionCall(splitter, separator, O, limit) : functionCall(internalSplit, toString_1(O), separator, limit);
	  }, // `RegExp.prototype[@@split]` method
	  // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
	  //
	  // NOTE: This cannot be properly polyfilled in engines that don't support
	  // the 'y' flag.
	  function (string, limit) {
	    var rx = anObject(this);
	    var S = toString_1(string);
	    var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
	    if (res.done) return res.value;
	    var C = speciesConstructor(rx, RegExp);
	    var unicodeMatching = rx.unicode;
	    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (UNSUPPORTED_Y$1 ? 'g' : 'y'); // ^(? + rx + ) is needed, in combination with some S slicing, to
	    // simulate the 'y' flag.

	    var splitter = new C(UNSUPPORTED_Y$1 ? '^(?:' + rx.source + ')' : rx, flags);
	    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	    if (lim === 0) return [];
	    if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
	    var p = 0;
	    var q = 0;
	    var A = [];

	    while (q < S.length) {
	      splitter.lastIndex = UNSUPPORTED_Y$1 ? 0 : q;
	      var z = regexpExecAbstract(splitter, UNSUPPORTED_Y$1 ? stringSlice$8(S, q) : S);
	      var e;

	      if (z === null || (e = min$6(toLength(splitter.lastIndex + (UNSUPPORTED_Y$1 ? q : 0)), S.length)) === p) {
	        q = advanceStringIndex(S, q, unicodeMatching);
	      } else {
	        push$7(A, stringSlice$8(S, p, q));
	        if (A.length === lim) return A;

	        for (var i = 1; i <= z.length - 1; i++) {
	          push$7(A, z[i]);
	          if (A.length === lim) return A;
	        }

	        q = p = e;
	      }
	    }

	    push$7(A, stringSlice$8(S, p));
	    return A;
	  }];
	}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y$1);

	// `thisNumberValue` abstract operation
	// https://tc39.es/ecma262/#sec-thisnumbervalue


	var thisNumberValue = functionUncurryThis(1.0.valueOf);

	var getOwnPropertyNames$3 = objectGetOwnPropertyNames.f;

	var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f;

	var defineProperty$9 = objectDefineProperty.f;



	var trim$2 = stringTrim.trim;

	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype;
	var TypeError$g = global_1.TypeError;
	var arraySlice = functionUncurryThis(''.slice);
	var charCodeAt$4 = functionUncurryThis(''.charCodeAt); // `ToNumeric` abstract operation
	// https://tc39.es/ecma262/#sec-tonumeric

	var toNumeric = function toNumeric(value) {
	  var primValue = toPrimitive(value, 'number');
	  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
	}; // `ToNumber` abstract operation
	// https://tc39.es/ecma262/#sec-tonumber


	var toNumber = function toNumber(argument) {
	  var it = toPrimitive(argument, 'number');
	  var first, third, radix, maxCode, digits, length, index, code;
	  if (isSymbol(it)) throw TypeError$g('Cannot convert a Symbol value to a number');

	  if (typeof it == 'string' && it.length > 2) {
	    it = trim$2(it);
	    first = charCodeAt$4(it, 0);

	    if (first === 43 || first === 45) {
	      third = charCodeAt$4(it, 2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (charCodeAt$4(it, 1)) {
	        case 66:
	        case 98:
	          radix = 2;
	          maxCode = 49;
	          break;
	        // fast equal of /^0b[01]+$/i

	        case 79:
	        case 111:
	          radix = 8;
	          maxCode = 55;
	          break;
	        // fast equal of /^0o[0-7]+$/i

	        default:
	          return +it;
	      }

	      digits = arraySlice(it, 2);
	      length = digits.length;

	      for (index = 0; index < length; index++) {
	        code = charCodeAt$4(digits, index); // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols

	        if (code < 48 || code > maxCode) return NaN;
	      }

	      return parseInt(digits, radix);
	    }
	  }

	  return +it;
	}; // `Number` constructor
	// https://tc39.es/ecma262/#sec-number-constructor


	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
	    var dummy = this; // check on 1..constructor(foo) case

	    return objectIsPrototypeOf(NumberPrototype, dummy) && fails(function () {
	      thisNumberValue(dummy);
	    }) ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
	  };

	  for (var keys$2 = descriptors ? getOwnPropertyNames$3(NativeNumber) : ( // ES3:
	  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
	  'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' + // ESNext
	  'fromString,range').split(','), j$1 = 0, key$3; keys$2.length > j$1; j$1++) {
	    if (hasOwnProperty_1(NativeNumber, key$3 = keys$2[j$1]) && !hasOwnProperty_1(NumberWrapper, key$3)) {
	      defineProperty$9(NumberWrapper, key$3, getOwnPropertyDescriptor$6(NativeNumber, key$3));
	    }
	  }

	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	var $find$1 = arrayIteration.find;



	var FIND = 'find';
	var SKIPS_HOLES$1 = true; // Shouldn't skip holes

	if (FIND in []) Array(1)[FIND](function () {
	  SKIPS_HOLES$1 = false;
	}); // `Array.prototype.find` method
	// https://tc39.es/ecma262/#sec-array.prototype.find

	_export({
	  target: 'Array',
	  proto: true,
	  forced: SKIPS_HOLES$1
	}, {
	  find: function find(callbackfn
	  /* , that = undefined */
	  ) {
	    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables(FIND);

	var TypeError$f = global_1.TypeError;

	var validateArgumentsLength = function (passed, required) {
	  if (passed < required) throw TypeError$f('Not enough arguments');
	  return passed;
	};

	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var Function$3 = global_1.Function;

	var wrap = function wrap(scheduler) {
	  return function (handler, timeout
	  /* , ...arguments */
	  ) {
	    var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
	    var fn = isCallable(handler) ? handler : Function$3(handler);
	    var args = boundArgs ? arraySlice$1(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      functionApply(fn, this, args);
	    } : fn, timeout);
	  };
	}; // ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


	_export({
	  global: true,
	  bind: true,
	  forced: MSIE
	}, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap(global_1.setInterval)
	});

	/* eslint-disable es/no-array-prototype-indexof -- required for testing */





	var $IndexOf = arrayIncludes.indexOf;



	var un$IndexOf = functionUncurryThis([].indexOf);
	var NEGATIVE_ZERO$1 = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
	var STRICT_METHOD$7 = arrayMethodIsStrict('indexOf'); // `Array.prototype.indexOf` method
	// https://tc39.es/ecma262/#sec-array.prototype.indexof

	_export({
	  target: 'Array',
	  proto: true,
	  forced: NEGATIVE_ZERO$1 || !STRICT_METHOD$7
	}, {
	  indexOf: function indexOf(searchElement
	  /* , fromIndex = 0 */
	  ) {
	    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
	    return NEGATIVE_ZERO$1 // convert -0 to +0
	    ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
	  }
	});

	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('splice');
	var TypeError$e = global_1.TypeError;
	var max$2 = Math.max;
	var min$5 = Math.min;
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
	// https://tc39.es/ecma262/#sec-array.prototype.splice
	// with adding support of @@species

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT$2
	}, {
	  splice: function splice(start, deleteCount
	  /* , ...items */
	  ) {
	    var O = toObject(this);
	    var len = lengthOfArrayLike(O);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;

	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$5(max$2(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
	    }

	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
	      throw TypeError$e(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }

	    A = arraySpeciesCreate(O, actualDeleteCount);

	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }

	    A.length = actualDeleteCount;

	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }

	      for (k = len; k > len - actualDeleteCount + insertCount; k--) {
	        delete O[k - 1];
	      }
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }
	    }

	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }

	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	// @@match logic


	fixRegexpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
	  return [// `String.prototype.match` method
	  // https://tc39.es/ecma262/#sec-string.prototype.match
	  function match(regexp) {
	    var O = requireObjectCoercible(this);
	    var matcher = regexp == undefined ? undefined : getMethod(regexp, MATCH);
	    return matcher ? functionCall(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString_1(O));
	  }, // `RegExp.prototype[@@match]` method
	  // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
	  function (string) {
	    var rx = anObject(this);
	    var S = toString_1(string);
	    var res = maybeCallNative(nativeMatch, rx, S);
	    if (res.done) return res.value;
	    if (!rx.global) return regexpExecAbstract(rx, S);
	    var fullUnicode = rx.unicode;
	    rx.lastIndex = 0;
	    var A = [];
	    var n = 0;
	    var result;

	    while ((result = regexpExecAbstract(rx, S)) !== null) {
	      var matchStr = toString_1(result[0]);
	      A[n] = matchStr;
	      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      n++;
	    }

	    return n === 0 ? null : A;
	  }];
	});

	var getOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f; // eslint-disable-next-line es/no-object-getownpropertynames -- required for testing


	var FAILS_ON_PRIMITIVES$8 = fails(function () {
	  return !Object.getOwnPropertyNames(1);
	}); // `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$8
	}, {
	  getOwnPropertyNames: getOwnPropertyNames$2
	});

	var ITERATOR$6 = wellKnownSymbol('iterator');
	var nativeUrl = !fails(function () {
	  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
	  var url = new URL('b?a=1&b=2&c=3', 'http://a');
	  var searchParams = url.searchParams;
	  var result = '';
	  url.pathname = 'c%20d';
	  searchParams.forEach(function (value, key) {
	    searchParams['delete']('b');
	    result += key + value;
	  });
	  return isPure && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR$6] // throws in Edge
	  || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' // not punycoded in Edge
	  || new URL('http://тест').host !== 'xn--e1aybc' // not escaped in Chrome 62-
	  || new URL('http://a#б').hash !== '#%D0%B1' // fails in Chrome 66-
	  || result !== 'a1c3' // throws in Safari
	  || new URL('http://x', undefined).host !== 'x';
	});

	var TypeError$d = global_1.TypeError;

	var anInstance = function (it, Prototype) {
	  if (objectIsPrototypeOf(Prototype, it)) return it;
	  throw TypeError$d('Incorrect invocation');
	};

	// eslint-disable-next-line es/no-object-assign -- safe


	var $assign = Object.assign; // eslint-disable-next-line es/no-object-defineproperty -- required for testing

	var defineProperty$8 = Object.defineProperty;
	var concat$1 = functionUncurryThis([].concat); // `Object.assign` method
	// https://tc39.es/ecma262/#sec-object.assign

	var objectAssign = !$assign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && $assign({
	    b: 1
	  }, $assign(defineProperty$8({}, 'a', {
	    enumerable: true,
	    get: function get() {
	      defineProperty$8(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), {
	    b: 2
	  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

	  var A = {};
	  var B = {}; // eslint-disable-next-line es/no-symbol -- safe

	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) {
	    B[chr] = chr;
	  });
	  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) {
	  // eslint-disable-line no-unused-vars -- required for `.length`
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? concat$1(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;

	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || functionCall(propertyIsEnumerable, S, key)) T[key] = S[key];
	    }
	  }

	  return T;
	} : $assign;

	var iteratorClose = function (iterator, kind, value) {
	  var innerResult, innerError;
	  anObject(iterator);

	  try {
	    innerResult = getMethod(iterator, 'return');

	    if (!innerResult) {
	      if (kind === 'throw') throw value;
	      return value;
	    }

	    innerResult = functionCall(innerResult, iterator);
	  } catch (error) {
	    innerError = true;
	    innerResult = error;
	  }

	  if (kind === 'throw') throw value;
	  if (innerError) throw innerResult;
	  anObject(innerResult);
	  return value;
	};

	// call something on iterator step with safe closing on error


	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  } catch (error) {
	    iteratorClose(iterator, 'throw', error);
	  }
	};

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype; // check on default Array iterator

	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$5] === it);
	};

	var ITERATOR$4 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return getMethod(it, ITERATOR$4) || getMethod(it, '@@iterator') || iterators[classof(it)];
	};

	var TypeError$c = global_1.TypeError;

	var getIterator = function (argument, usingIterator) {
	  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
	  if (aCallable(iteratorMethod)) return anObject(functionCall(iteratorMethod, argument));
	  throw TypeError$c(tryToString(argument) + ' is not iterable');
	};

	var Array$6 = global_1.Array; // `Array.from` method implementation
	// https://tc39.es/ecma262/#sec-array.from

	var arrayFrom = function from(arrayLike
	/* , mapfn = undefined, thisArg = undefined */
	) {
	  var O = toObject(arrayLike);
	  var IS_CONSTRUCTOR = isConstructor(this);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

	  if (iteratorMethod && !(this == Array$6 && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = getIterator(O, iteratorMethod);
	    next = iterator.next;
	    result = IS_CONSTRUCTOR ? new this() : [];

	    for (; !(step = functionCall(next, iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = lengthOfArrayLike(O);
	    result = IS_CONSTRUCTOR ? new this(length) : Array$6(length);

	    for (; length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }

	  result.length = index;
	  return result;
	};

	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80

	var delimiter = '-'; // '\x2D'

	var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars

	var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

	var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
	var baseMinusTMin = base - tMin;
	var RangeError$9 = global_1.RangeError;
	var exec$5 = functionUncurryThis(regexSeparators.exec);
	var floor$8 = Math.floor;
	var fromCharCode$2 = String.fromCharCode;
	var charCodeAt$3 = functionUncurryThis(''.charCodeAt);
	var join$6 = functionUncurryThis([].join);
	var push$6 = functionUncurryThis([].push);
	var replace$5 = functionUncurryThis(''.replace);
	var split$2 = functionUncurryThis(''.split);
	var toLowerCase$1 = functionUncurryThis(''.toLowerCase);
	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 */

	var ucs2decode = function ucs2decode(string) {
	  var output = [];
	  var counter = 0;
	  var length = string.length;

	  while (counter < length) {
	    var value = charCodeAt$3(string, counter++);

	    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	      // It's a high surrogate, and there is a next character.
	      var extra = charCodeAt$3(string, counter++);

	      if ((extra & 0xFC00) == 0xDC00) {
	        // Low surrogate.
	        push$6(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	      } else {
	        // It's an unmatched surrogate; only append this code unit, in case the
	        // next code unit is the high surrogate of a surrogate pair.
	        push$6(output, value);
	        counter--;
	      }
	    } else {
	      push$6(output, value);
	    }
	  }

	  return output;
	};
	/**
	 * Converts a digit/integer into a basic code point.
	 */


	var digitToBasic = function digitToBasic(digit) {
	  //  0..25 map to ASCII a..z or A..Z
	  // 26..35 map to ASCII 0..9
	  return digit + 22 + 75 * (digit < 26);
	};
	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 */


	var adapt = function adapt(delta, numPoints, firstTime) {
	  var k = 0;
	  delta = firstTime ? floor$8(delta / damp) : delta >> 1;
	  delta += floor$8(delta / numPoints);

	  while (delta > baseMinusTMin * tMax >> 1) {
	    delta = floor$8(delta / baseMinusTMin);
	    k += base;
	  }

	  return floor$8(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};
	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 */


	var encode$1 = function encode(input) {
	  var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

	  input = ucs2decode(input); // Cache the length.

	  var inputLength = input.length; // Initialize the state.

	  var n = initialN;
	  var delta = 0;
	  var bias = initialBias;
	  var i, currentValue; // Handle the basic code points.

	  for (i = 0; i < input.length; i++) {
	    currentValue = input[i];

	    if (currentValue < 0x80) {
	      push$6(output, fromCharCode$2(currentValue));
	    }
	  }

	  var basicLength = output.length; // number of basic code points.

	  var handledCPCount = basicLength; // number of code points that have been handled;
	  // Finish the basic string with a delimiter unless it's empty.

	  if (basicLength) {
	    push$6(output, delimiter);
	  } // Main encoding loop:


	  while (handledCPCount < inputLength) {
	    // All non-basic code points < n have been handled already. Find the next larger one:
	    var m = maxInt;

	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];

	      if (currentValue >= n && currentValue < m) {
	        m = currentValue;
	      }
	    } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.


	    var handledCPCountPlusOne = handledCPCount + 1;

	    if (m - n > floor$8((maxInt - delta) / handledCPCountPlusOne)) {
	      throw RangeError$9(OVERFLOW_ERROR);
	    }

	    delta += (m - n) * handledCPCountPlusOne;
	    n = m;

	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];

	      if (currentValue < n && ++delta > maxInt) {
	        throw RangeError$9(OVERFLOW_ERROR);
	      }

	      if (currentValue == n) {
	        // Represent delta as a generalized variable-length integer.
	        var q = delta;
	        var k = base;

	        while (true) {
	          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
	          if (q < t) break;
	          var qMinusT = q - t;
	          var baseMinusT = base - t;
	          push$6(output, fromCharCode$2(digitToBasic(t + qMinusT % baseMinusT)));
	          q = floor$8(qMinusT / baseMinusT);
	          k += base;
	        }

	        push$6(output, fromCharCode$2(digitToBasic(q)));
	        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	        delta = 0;
	        handledCPCount++;
	      }
	    }

	    delta++;
	    n++;
	  }

	  return join$6(output, '');
	};

	var stringPunycodeToAscii = function (input) {
	  var encoded = [];
	  var labels = split$2(replace$5(toLowerCase$1(input), regexSeparators, "."), '.');
	  var i, label;

	  for (i = 0; i < labels.length; i++) {
	    label = labels[i];
	    push$6(encoded, exec$5(regexNonASCII, label) ? 'xn--' + encode$1(label) : label);
	  }

	  return join$6(encoded, '.');
	};

	var redefineAll = function (target, src, options) {
	  for (var key in src) {
	    redefine(target, key, src[key], options);
	  }

	  return target;
	};

	var floor$7 = Math.floor;

	var mergeSort = function mergeSort(array, comparefn) {
	  var length = array.length;
	  var middle = floor$7(length / 2);
	  return length < 8 ? insertionSort(array, comparefn) : merge$1(array, mergeSort(arraySliceSimple(array, 0, middle), comparefn), mergeSort(arraySliceSimple(array, middle), comparefn), comparefn);
	};

	var insertionSort = function insertionSort(array, comparefn) {
	  var length = array.length;
	  var i = 1;
	  var element, j;

	  while (i < length) {
	    j = i;
	    element = array[i];

	    while (j && comparefn(array[j - 1], element) > 0) {
	      array[j] = array[--j];
	    }

	    if (j !== i++) array[j] = element;
	  }

	  return array;
	};

	var merge$1 = function merge(array, left, right, comparefn) {
	  var llength = left.length;
	  var rlength = right.length;
	  var lindex = 0;
	  var rindex = 0;

	  while (lindex < llength || rindex < rlength) {
	    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
	  }

	  return array;
	};

	var arraySort = mergeSort;

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var URL_SEARCH_PARAMS = 'URLSearchParams';
	var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
	var setInternalState$6 = internalState.set;
	var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
	var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);
	var n$Fetch = getBuiltIn('fetch');
	var N$Request = getBuiltIn('Request');
	var Headers = getBuiltIn('Headers');
	var RequestPrototype = N$Request && N$Request.prototype;
	var HeadersPrototype = Headers && Headers.prototype;
	var RegExp$1 = global_1.RegExp;
	var TypeError$b = global_1.TypeError;
	var decodeURIComponent$1 = global_1.decodeURIComponent;
	var encodeURIComponent$1 = global_1.encodeURIComponent;
	var charAt$7 = functionUncurryThis(''.charAt);
	var join$5 = functionUncurryThis([].join);
	var push$5 = functionUncurryThis([].push);
	var replace$4 = functionUncurryThis(''.replace);
	var shift$1 = functionUncurryThis([].shift);
	var splice$1 = functionUncurryThis([].splice);
	var split$1 = functionUncurryThis(''.split);
	var stringSlice$7 = functionUncurryThis(''.slice);
	var plus = /\+/g;
	var sequences = Array(4);

	var percentSequence = function percentSequence(bytes) {
	  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp$1('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
	};

	var percentDecode = function percentDecode(sequence) {
	  try {
	    return decodeURIComponent$1(sequence);
	  } catch (error) {
	    return sequence;
	  }
	};

	var deserialize = function deserialize(it) {
	  var result = replace$4(it, plus, ' ');
	  var bytes = 4;

	  try {
	    return decodeURIComponent$1(result);
	  } catch (error) {
	    while (bytes) {
	      result = replace$4(result, percentSequence(bytes--), percentDecode);
	    }

	    return result;
	  }
	};

	var find$1 = /[!'()~]|%20/g;
	var replacements = {
	  '!': '%21',
	  "'": '%27',
	  '(': '%28',
	  ')': '%29',
	  '~': '%7E',
	  '%20': '+'
	};

	var replacer = function replacer(match) {
	  return replacements[match];
	};

	var _serialize = function serialize(it) {
	  return replace$4(encodeURIComponent$1(it), find$1, replacer);
	};

	var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
	  setInternalState$6(this, {
	    type: URL_SEARCH_PARAMS_ITERATOR,
	    iterator: getIterator(getInternalParamsState(params).entries),
	    kind: kind
	  });
	}, 'Iterator', function next() {
	  var state = getInternalIteratorState(this);
	  var kind = state.kind;
	  var step = state.iterator.next();
	  var entry = step.value;

	  if (!step.done) {
	    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
	  }

	  return step;
	}, true);

	var URLSearchParamsState = function URLSearchParamsState(init) {
	  this.entries = [];
	  this.url = null;

	  if (init !== undefined) {
	    if (isObject$1(init)) this.parseObject(init);else this.parseQuery(typeof init == 'string' ? charAt$7(init, 0) === '?' ? stringSlice$7(init, 1) : init : toString_1(init));
	  }
	};

	URLSearchParamsState.prototype = {
	  type: URL_SEARCH_PARAMS,
	  bindURL: function bindURL(url) {
	    this.url = url;
	    this.update();
	  },
	  parseObject: function parseObject(object) {
	    var iteratorMethod = getIteratorMethod(object);
	    var iterator, next, step, entryIterator, entryNext, first, second;

	    if (iteratorMethod) {
	      iterator = getIterator(object, iteratorMethod);
	      next = iterator.next;

	      while (!(step = functionCall(next, iterator)).done) {
	        entryIterator = getIterator(anObject(step.value));
	        entryNext = entryIterator.next;
	        if ((first = functionCall(entryNext, entryIterator)).done || (second = functionCall(entryNext, entryIterator)).done || !functionCall(entryNext, entryIterator).done) throw TypeError$b('Expected sequence with length 2');
	        push$5(this.entries, {
	          key: toString_1(first.value),
	          value: toString_1(second.value)
	        });
	      }
	    } else for (var key in object) {
	      if (hasOwnProperty_1(object, key)) {
	        push$5(this.entries, {
	          key: key,
	          value: toString_1(object[key])
	        });
	      }
	    }
	  },
	  parseQuery: function parseQuery(query) {
	    if (query) {
	      var attributes = split$1(query, '&');
	      var index = 0;
	      var attribute, entry;

	      while (index < attributes.length) {
	        attribute = attributes[index++];

	        if (attribute.length) {
	          entry = split$1(attribute, '=');
	          push$5(this.entries, {
	            key: deserialize(shift$1(entry)),
	            value: deserialize(join$5(entry, '='))
	          });
	        }
	      }
	    }
	  },
	  serialize: function serialize() {
	    var entries = this.entries;
	    var result = [];
	    var index = 0;
	    var entry;

	    while (index < entries.length) {
	      entry = entries[index++];
	      push$5(result, _serialize(entry.key) + '=' + _serialize(entry.value));
	    }

	    return join$5(result, '&');
	  },
	  update: function update() {
	    this.entries.length = 0;
	    this.parseQuery(this.url.query);
	  },
	  updateURL: function updateURL() {
	    if (this.url) this.url.update();
	  }
	}; // `URLSearchParams` constructor
	// https://url.spec.whatwg.org/#interface-urlsearchparams

	var URLSearchParamsConstructor = function
	  /* init */
	URLSearchParams() {
	  anInstance(this, URLSearchParamsPrototype);
	  var init = arguments.length > 0 ? arguments[0] : undefined;
	  setInternalState$6(this, new URLSearchParamsState(init));
	};

	var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
	redefineAll(URLSearchParamsPrototype, {
	  // `URLSearchParams.prototype.append` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
	  append: function append(name, value) {
	    validateArgumentsLength(arguments.length, 2);
	    var state = getInternalParamsState(this);
	    push$5(state.entries, {
	      key: toString_1(name),
	      value: toString_1(value)
	    });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.delete` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
	  'delete': function _delete(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var key = toString_1(name);
	    var index = 0;

	    while (index < entries.length) {
	      if (entries[index].key === key) splice$1(entries, index, 1);else index++;
	    }

	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.get` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
	  get: function get(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = toString_1(name);
	    var index = 0;

	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) return entries[index].value;
	    }

	    return null;
	  },
	  // `URLSearchParams.prototype.getAll` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
	  getAll: function getAll(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = toString_1(name);
	    var result = [];
	    var index = 0;

	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) push$5(result, entries[index].value);
	    }

	    return result;
	  },
	  // `URLSearchParams.prototype.has` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
	  has: function has(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = toString_1(name);
	    var index = 0;

	    while (index < entries.length) {
	      if (entries[index++].key === key) return true;
	    }

	    return false;
	  },
	  // `URLSearchParams.prototype.set` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
	  set: function set(name, value) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var found = false;
	    var key = toString_1(name);
	    var val = toString_1(value);
	    var index = 0;
	    var entry;

	    for (; index < entries.length; index++) {
	      entry = entries[index];

	      if (entry.key === key) {
	        if (found) splice$1(entries, index--, 1);else {
	          found = true;
	          entry.value = val;
	        }
	      }
	    }

	    if (!found) push$5(entries, {
	      key: key,
	      value: val
	    });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.sort` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
	  sort: function sort() {
	    var state = getInternalParamsState(this);
	    arraySort(state.entries, function (a, b) {
	      return a.key > b.key ? 1 : -1;
	    });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.forEach` method
	  forEach: function forEach(callback
	  /* , thisArg */
	  ) {
	    var entries = getInternalParamsState(this).entries;
	    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined);
	    var index = 0;
	    var entry;

	    while (index < entries.length) {
	      entry = entries[index++];
	      boundFunction(entry.value, entry.key, this);
	    }
	  },
	  // `URLSearchParams.prototype.keys` method
	  keys: function keys() {
	    return new URLSearchParamsIterator(this, 'keys');
	  },
	  // `URLSearchParams.prototype.values` method
	  values: function values() {
	    return new URLSearchParamsIterator(this, 'values');
	  },
	  // `URLSearchParams.prototype.entries` method
	  entries: function entries() {
	    return new URLSearchParamsIterator(this, 'entries');
	  }
	}, {
	  enumerable: true
	}); // `URLSearchParams.prototype[@@iterator]` method

	redefine(URLSearchParamsPrototype, ITERATOR$3, URLSearchParamsPrototype.entries, {
	  name: 'entries'
	}); // `URLSearchParams.prototype.toString` method
	// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior

	redefine(URLSearchParamsPrototype, 'toString', function toString() {
	  return getInternalParamsState(this).serialize();
	}, {
	  enumerable: true
	});
	setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
	_export({
	  global: true,
	  forced: !nativeUrl
	}, {
	  URLSearchParams: URLSearchParamsConstructor
	}); // Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`

	if (!nativeUrl && isCallable(Headers)) {
	  var headersHas = functionUncurryThis(HeadersPrototype.has);
	  var headersSet = functionUncurryThis(HeadersPrototype.set);

	  var wrapRequestOptions = function wrapRequestOptions(init) {
	    if (isObject$1(init)) {
	      var body = init.body;
	      var headers;

	      if (classof(body) === URL_SEARCH_PARAMS) {
	        headers = init.headers ? new Headers(init.headers) : new Headers();

	        if (!headersHas(headers, 'content-type')) {
	          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	        }

	        return objectCreate(init, {
	          body: createPropertyDescriptor(0, toString_1(body)),
	          headers: createPropertyDescriptor(0, headers)
	        });
	      }
	    }

	    return init;
	  };

	  if (isCallable(n$Fetch)) {
	    _export({
	      global: true,
	      enumerable: true,
	      forced: true
	    }, {
	      fetch: function fetch(input
	      /* , init */
	      ) {
	        return n$Fetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
	      }
	    });
	  }

	  if (isCallable(N$Request)) {
	    var RequestConstructor = function Request(input
	    /* , init */
	    ) {
	      anInstance(this, RequestPrototype);
	      return new N$Request(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
	    };

	    RequestPrototype.constructor = RequestConstructor;
	    RequestConstructor.prototype = RequestPrototype;
	    _export({
	      global: true,
	      forced: true
	    }, {
	      Request: RequestConstructor
	    });
	  }
	}

	var web_urlSearchParams = {
	  URLSearchParams: URLSearchParamsConstructor,
	  getState: getInternalParamsState
	};

	var _typeof$3 = require$$0["typeof"];















	var defineProperties$2 = objectDefineProperties.f;













	var codeAt$1 = stringMultibyte.codeAt;













	var setInternalState$5 = internalState.set;
	var getInternalURLState = internalState.getterFor('URL');
	var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
	var getInternalSearchParamsState = web_urlSearchParams.getState;
	var NativeURL = global_1.URL;
	var TypeError$a = global_1.TypeError;
	var parseInt$1 = global_1.parseInt;
	var floor$6 = Math.floor;
	var pow$4 = Math.pow;
	var charAt$6 = functionUncurryThis(''.charAt);
	var exec$4 = functionUncurryThis(/./.exec);
	var join$4 = functionUncurryThis([].join);
	var numberToString$2 = functionUncurryThis(1.0.toString);
	var pop = functionUncurryThis([].pop);
	var push$4 = functionUncurryThis([].push);
	var replace$3 = functionUncurryThis(''.replace);
	var shift = functionUncurryThis([].shift);
	var split = functionUncurryThis(''.split);
	var stringSlice$6 = functionUncurryThis(''.slice);
	var toLowerCase = functionUncurryThis(''.toLowerCase);
	var unshift = functionUncurryThis([].unshift);
	var INVALID_AUTHORITY = 'Invalid authority';
	var INVALID_SCHEME = 'Invalid scheme';
	var INVALID_HOST = 'Invalid host';
	var INVALID_PORT = 'Invalid port';
	var ALPHA = /[a-z]/i; // eslint-disable-next-line regexp/no-obscure-range -- safe

	var ALPHANUMERIC = /[\d+-.a-z]/i;
	var DIGIT = /\d/;
	var HEX_START = /^0x/i;
	var OCT = /^[0-7]+$/;
	var DEC = /^\d+$/;
	var HEX = /^[\da-f]+$/i;
	/* eslint-disable regexp/no-control-character -- safe */

	var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
	var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
	var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
	var TAB_AND_NEW_LINE = /[\t\n\r]/g;
	/* eslint-enable regexp/no-control-character -- safe */

	var EOF; // https://url.spec.whatwg.org/#ipv4-number-parser

	var parseIPv4 = function parseIPv4(input) {
	  var parts = split(input, '.');
	  var partsLength, numbers, index, part, radix, number, ipv4;

	  if (parts.length && parts[parts.length - 1] == '') {
	    parts.length--;
	  }

	  partsLength = parts.length;
	  if (partsLength > 4) return input;
	  numbers = [];

	  for (index = 0; index < partsLength; index++) {
	    part = parts[index];
	    if (part == '') return input;
	    radix = 10;

	    if (part.length > 1 && charAt$6(part, 0) == '0') {
	      radix = exec$4(HEX_START, part) ? 16 : 8;
	      part = stringSlice$6(part, radix == 8 ? 1 : 2);
	    }

	    if (part === '') {
	      number = 0;
	    } else {
	      if (!exec$4(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;
	      number = parseInt$1(part, radix);
	    }

	    push$4(numbers, number);
	  }

	  for (index = 0; index < partsLength; index++) {
	    number = numbers[index];

	    if (index == partsLength - 1) {
	      if (number >= pow$4(256, 5 - partsLength)) return null;
	    } else if (number > 255) return null;
	  }

	  ipv4 = pop(numbers);

	  for (index = 0; index < numbers.length; index++) {
	    ipv4 += numbers[index] * pow$4(256, 3 - index);
	  }

	  return ipv4;
	}; // https://url.spec.whatwg.org/#concept-ipv6-parser
	// eslint-disable-next-line max-statements -- TODO


	var parseIPv6 = function parseIPv6(input) {
	  var address = [0, 0, 0, 0, 0, 0, 0, 0];
	  var pieceIndex = 0;
	  var compress = null;
	  var pointer = 0;
	  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

	  var chr = function chr() {
	    return charAt$6(input, pointer);
	  };

	  if (chr() == ':') {
	    if (charAt$6(input, 1) != ':') return;
	    pointer += 2;
	    pieceIndex++;
	    compress = pieceIndex;
	  }

	  while (chr()) {
	    if (pieceIndex == 8) return;

	    if (chr() == ':') {
	      if (compress !== null) return;
	      pointer++;
	      pieceIndex++;
	      compress = pieceIndex;
	      continue;
	    }

	    value = length = 0;

	    while (length < 4 && exec$4(HEX, chr())) {
	      value = value * 16 + parseInt$1(chr(), 16);
	      pointer++;
	      length++;
	    }

	    if (chr() == '.') {
	      if (length == 0) return;
	      pointer -= length;
	      if (pieceIndex > 6) return;
	      numbersSeen = 0;

	      while (chr()) {
	        ipv4Piece = null;

	        if (numbersSeen > 0) {
	          if (chr() == '.' && numbersSeen < 4) pointer++;else return;
	        }

	        if (!exec$4(DIGIT, chr())) return;

	        while (exec$4(DIGIT, chr())) {
	          number = parseInt$1(chr(), 10);
	          if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece == 0) return;else ipv4Piece = ipv4Piece * 10 + number;
	          if (ipv4Piece > 255) return;
	          pointer++;
	        }

	        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
	        numbersSeen++;
	        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
	      }

	      if (numbersSeen != 4) return;
	      break;
	    } else if (chr() == ':') {
	      pointer++;
	      if (!chr()) return;
	    } else if (chr()) return;

	    address[pieceIndex++] = value;
	  }

	  if (compress !== null) {
	    swaps = pieceIndex - compress;
	    pieceIndex = 7;

	    while (pieceIndex != 0 && swaps > 0) {
	      swap = address[pieceIndex];
	      address[pieceIndex--] = address[compress + swaps - 1];
	      address[compress + --swaps] = swap;
	    }
	  } else if (pieceIndex != 8) return;

	  return address;
	};

	var findLongestZeroSequence = function findLongestZeroSequence(ipv6) {
	  var maxIndex = null;
	  var maxLength = 1;
	  var currStart = null;
	  var currLength = 0;
	  var index = 0;

	  for (; index < 8; index++) {
	    if (ipv6[index] !== 0) {
	      if (currLength > maxLength) {
	        maxIndex = currStart;
	        maxLength = currLength;
	      }

	      currStart = null;
	      currLength = 0;
	    } else {
	      if (currStart === null) currStart = index;
	      ++currLength;
	    }
	  }

	  if (currLength > maxLength) {
	    maxIndex = currStart;
	    maxLength = currLength;
	  }

	  return maxIndex;
	}; // https://url.spec.whatwg.org/#host-serializing


	var serializeHost = function serializeHost(host) {
	  var result, index, compress, ignore0; // ipv4

	  if (typeof host == 'number') {
	    result = [];

	    for (index = 0; index < 4; index++) {
	      unshift(result, host % 256);
	      host = floor$6(host / 256);
	    }

	    return join$4(result, '.'); // ipv6
	  } else if (_typeof$3(host) == 'object') {
	    result = '';
	    compress = findLongestZeroSequence(host);

	    for (index = 0; index < 8; index++) {
	      if (ignore0 && host[index] === 0) continue;
	      if (ignore0) ignore0 = false;

	      if (compress === index) {
	        result += index ? ':' : '::';
	        ignore0 = true;
	      } else {
	        result += numberToString$2(host[index], 16);
	        if (index < 7) result += ':';
	      }
	    }

	    return '[' + result + ']';
	  }

	  return host;
	};

	var C0ControlPercentEncodeSet = {};
	var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
	  ' ': 1,
	  '"': 1,
	  '<': 1,
	  '>': 1,
	  '`': 1
	});
	var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
	  '#': 1,
	  '?': 1,
	  '{': 1,
	  '}': 1
	});
	var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
	  '/': 1,
	  ':': 1,
	  ';': 1,
	  '=': 1,
	  '@': 1,
	  '[': 1,
	  '\\': 1,
	  ']': 1,
	  '^': 1,
	  '|': 1
	});

	var percentEncode = function percentEncode(chr, set) {
	  var code = codeAt$1(chr, 0);
	  return code > 0x20 && code < 0x7F && !hasOwnProperty_1(set, chr) ? chr : encodeURIComponent(chr);
	}; // https://url.spec.whatwg.org/#special-scheme


	var specialSchemes = {
	  ftp: 21,
	  file: null,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	}; // https://url.spec.whatwg.org/#windows-drive-letter

	var isWindowsDriveLetter = function isWindowsDriveLetter(string, normalized) {
	  var second;
	  return string.length == 2 && exec$4(ALPHA, charAt$6(string, 0)) && ((second = charAt$6(string, 1)) == ':' || !normalized && second == '|');
	}; // https://url.spec.whatwg.org/#start-with-a-windows-drive-letter


	var startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(string) {
	  var third;
	  return string.length > 1 && isWindowsDriveLetter(stringSlice$6(string, 0, 2)) && (string.length == 2 || (third = charAt$6(string, 2)) === '/' || third === '\\' || third === '?' || third === '#');
	}; // https://url.spec.whatwg.org/#single-dot-path-segment


	var isSingleDot = function isSingleDot(segment) {
	  return segment === '.' || toLowerCase(segment) === '%2e';
	}; // https://url.spec.whatwg.org/#double-dot-path-segment


	var isDoubleDot = function isDoubleDot(segment) {
	  segment = toLowerCase(segment);
	  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
	}; // States:


	var SCHEME_START = {};
	var SCHEME = {};
	var NO_SCHEME = {};
	var SPECIAL_RELATIVE_OR_AUTHORITY = {};
	var PATH_OR_AUTHORITY = {};
	var RELATIVE = {};
	var RELATIVE_SLASH = {};
	var SPECIAL_AUTHORITY_SLASHES = {};
	var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
	var AUTHORITY = {};
	var HOST = {};
	var HOSTNAME = {};
	var PORT = {};
	var FILE = {};
	var FILE_SLASH = {};
	var FILE_HOST = {};
	var PATH_START = {};
	var PATH = {};
	var CANNOT_BE_A_BASE_URL_PATH = {};
	var QUERY = {};
	var FRAGMENT = {};

	var URLState = function URLState(url, isBase, base) {
	  var urlString = toString_1(url);
	  var baseState, failure, searchParams;

	  if (isBase) {
	    failure = this.parse(urlString);
	    if (failure) throw TypeError$a(failure);
	    this.searchParams = null;
	  } else {
	    if (base !== undefined) baseState = new URLState(base, true);
	    failure = this.parse(urlString, null, baseState);
	    if (failure) throw TypeError$a(failure);
	    searchParams = getInternalSearchParamsState(new URLSearchParams$1());
	    searchParams.bindURL(this);
	    this.searchParams = searchParams;
	  }
	};

	URLState.prototype = {
	  type: 'URL',
	  // https://url.spec.whatwg.org/#url-parsing
	  // eslint-disable-next-line max-statements -- TODO
	  parse: function parse(input, stateOverride, base) {
	    var url = this;
	    var state = stateOverride || SCHEME_START;
	    var pointer = 0;
	    var buffer = '';
	    var seenAt = false;
	    var seenBracket = false;
	    var seenPasswordToken = false;
	    var codePoints, chr, bufferCodePoints, failure;
	    input = toString_1(input);

	    if (!stateOverride) {
	      url.scheme = '';
	      url.username = '';
	      url.password = '';
	      url.host = null;
	      url.port = null;
	      url.path = [];
	      url.query = null;
	      url.fragment = null;
	      url.cannotBeABaseURL = false;
	      input = replace$3(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
	    }

	    input = replace$3(input, TAB_AND_NEW_LINE, '');
	    codePoints = arrayFrom(input);

	    while (pointer <= codePoints.length) {
	      chr = codePoints[pointer];

	      switch (state) {
	        case SCHEME_START:
	          if (chr && exec$4(ALPHA, chr)) {
	            buffer += toLowerCase(chr);
	            state = SCHEME;
	          } else if (!stateOverride) {
	            state = NO_SCHEME;
	            continue;
	          } else return INVALID_SCHEME;

	          break;

	        case SCHEME:
	          if (chr && (exec$4(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) {
	            buffer += toLowerCase(chr);
	          } else if (chr == ':') {
	            if (stateOverride && (url.isSpecial() != hasOwnProperty_1(specialSchemes, buffer) || buffer == 'file' && (url.includesCredentials() || url.port !== null) || url.scheme == 'file' && !url.host)) return;
	            url.scheme = buffer;

	            if (stateOverride) {
	              if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;
	              return;
	            }

	            buffer = '';

	            if (url.scheme == 'file') {
	              state = FILE;
	            } else if (url.isSpecial() && base && base.scheme == url.scheme) {
	              state = SPECIAL_RELATIVE_OR_AUTHORITY;
	            } else if (url.isSpecial()) {
	              state = SPECIAL_AUTHORITY_SLASHES;
	            } else if (codePoints[pointer + 1] == '/') {
	              state = PATH_OR_AUTHORITY;
	              pointer++;
	            } else {
	              url.cannotBeABaseURL = true;
	              push$4(url.path, '');
	              state = CANNOT_BE_A_BASE_URL_PATH;
	            }
	          } else if (!stateOverride) {
	            buffer = '';
	            state = NO_SCHEME;
	            pointer = 0;
	            continue;
	          } else return INVALID_SCHEME;

	          break;

	        case NO_SCHEME:
	          if (!base || base.cannotBeABaseURL && chr != '#') return INVALID_SCHEME;

	          if (base.cannotBeABaseURL && chr == '#') {
	            url.scheme = base.scheme;
	            url.path = arraySliceSimple(base.path);
	            url.query = base.query;
	            url.fragment = '';
	            url.cannotBeABaseURL = true;
	            state = FRAGMENT;
	            break;
	          }

	          state = base.scheme == 'file' ? FILE : RELATIVE;
	          continue;

	        case SPECIAL_RELATIVE_OR_AUTHORITY:
	          if (chr == '/' && codePoints[pointer + 1] == '/') {
	            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	            pointer++;
	          } else {
	            state = RELATIVE;
	            continue;
	          }

	          break;

	        case PATH_OR_AUTHORITY:
	          if (chr == '/') {
	            state = AUTHORITY;
	            break;
	          } else {
	            state = PATH;
	            continue;
	          }

	        case RELATIVE:
	          url.scheme = base.scheme;

	          if (chr == EOF) {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.query = base.query;
	          } else if (chr == '/' || chr == '\\' && url.isSpecial()) {
	            state = RELATIVE_SLASH;
	          } else if (chr == '?') {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.query = '';
	            state = QUERY;
	          } else if (chr == '#') {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.query = base.query;
	            url.fragment = '';
	            state = FRAGMENT;
	          } else {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.path.length--;
	            state = PATH;
	            continue;
	          }

	          break;

	        case RELATIVE_SLASH:
	          if (url.isSpecial() && (chr == '/' || chr == '\\')) {
	            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          } else if (chr == '/') {
	            state = AUTHORITY;
	          } else {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            state = PATH;
	            continue;
	          }

	          break;

	        case SPECIAL_AUTHORITY_SLASHES:
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          if (chr != '/' || charAt$6(buffer, pointer + 1) != '/') continue;
	          pointer++;
	          break;

	        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
	          if (chr != '/' && chr != '\\') {
	            state = AUTHORITY;
	            continue;
	          }

	          break;

	        case AUTHORITY:
	          if (chr == '@') {
	            if (seenAt) buffer = '%40' + buffer;
	            seenAt = true;
	            bufferCodePoints = arrayFrom(buffer);

	            for (var i = 0; i < bufferCodePoints.length; i++) {
	              var codePoint = bufferCodePoints[i];

	              if (codePoint == ':' && !seenPasswordToken) {
	                seenPasswordToken = true;
	                continue;
	              }

	              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
	              if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
	            }

	            buffer = '';
	          } else if (chr == EOF || chr == '/' || chr == '?' || chr == '#' || chr == '\\' && url.isSpecial()) {
	            if (seenAt && buffer == '') return INVALID_AUTHORITY;
	            pointer -= arrayFrom(buffer).length + 1;
	            buffer = '';
	            state = HOST;
	          } else buffer += chr;

	          break;

	        case HOST:
	        case HOSTNAME:
	          if (stateOverride && url.scheme == 'file') {
	            state = FILE_HOST;
	            continue;
	          } else if (chr == ':' && !seenBracket) {
	            if (buffer == '') return INVALID_HOST;
	            failure = url.parseHost(buffer);
	            if (failure) return failure;
	            buffer = '';
	            state = PORT;
	            if (stateOverride == HOSTNAME) return;
	          } else if (chr == EOF || chr == '/' || chr == '?' || chr == '#' || chr == '\\' && url.isSpecial()) {
	            if (url.isSpecial() && buffer == '') return INVALID_HOST;
	            if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;
	            failure = url.parseHost(buffer);
	            if (failure) return failure;
	            buffer = '';
	            state = PATH_START;
	            if (stateOverride) return;
	            continue;
	          } else {
	            if (chr == '[') seenBracket = true;else if (chr == ']') seenBracket = false;
	            buffer += chr;
	          }

	          break;

	        case PORT:
	          if (exec$4(DIGIT, chr)) {
	            buffer += chr;
	          } else if (chr == EOF || chr == '/' || chr == '?' || chr == '#' || chr == '\\' && url.isSpecial() || stateOverride) {
	            if (buffer != '') {
	              var port = parseInt$1(buffer, 10);
	              if (port > 0xFFFF) return INVALID_PORT;
	              url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
	              buffer = '';
	            }

	            if (stateOverride) return;
	            state = PATH_START;
	            continue;
	          } else return INVALID_PORT;

	          break;

	        case FILE:
	          url.scheme = 'file';
	          if (chr == '/' || chr == '\\') state = FILE_SLASH;else if (base && base.scheme == 'file') {
	            if (chr == EOF) {
	              url.host = base.host;
	              url.path = arraySliceSimple(base.path);
	              url.query = base.query;
	            } else if (chr == '?') {
	              url.host = base.host;
	              url.path = arraySliceSimple(base.path);
	              url.query = '';
	              state = QUERY;
	            } else if (chr == '#') {
	              url.host = base.host;
	              url.path = arraySliceSimple(base.path);
	              url.query = base.query;
	              url.fragment = '';
	              state = FRAGMENT;
	            } else {
	              if (!startsWithWindowsDriveLetter(join$4(arraySliceSimple(codePoints, pointer), ''))) {
	                url.host = base.host;
	                url.path = arraySliceSimple(base.path);
	                url.shortenPath();
	              }

	              state = PATH;
	              continue;
	            }
	          } else {
	            state = PATH;
	            continue;
	          }
	          break;

	        case FILE_SLASH:
	          if (chr == '/' || chr == '\\') {
	            state = FILE_HOST;
	            break;
	          }

	          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join$4(arraySliceSimple(codePoints, pointer), ''))) {
	            if (isWindowsDriveLetter(base.path[0], true)) push$4(url.path, base.path[0]);else url.host = base.host;
	          }

	          state = PATH;
	          continue;

	        case FILE_HOST:
	          if (chr == EOF || chr == '/' || chr == '\\' || chr == '?' || chr == '#') {
	            if (!stateOverride && isWindowsDriveLetter(buffer)) {
	              state = PATH;
	            } else if (buffer == '') {
	              url.host = '';
	              if (stateOverride) return;
	              state = PATH_START;
	            } else {
	              failure = url.parseHost(buffer);
	              if (failure) return failure;
	              if (url.host == 'localhost') url.host = '';
	              if (stateOverride) return;
	              buffer = '';
	              state = PATH_START;
	            }

	            continue;
	          } else buffer += chr;

	          break;

	        case PATH_START:
	          if (url.isSpecial()) {
	            state = PATH;
	            if (chr != '/' && chr != '\\') continue;
	          } else if (!stateOverride && chr == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (!stateOverride && chr == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          } else if (chr != EOF) {
	            state = PATH;
	            if (chr != '/') continue;
	          }

	          break;

	        case PATH:
	          if (chr == EOF || chr == '/' || chr == '\\' && url.isSpecial() || !stateOverride && (chr == '?' || chr == '#')) {
	            if (isDoubleDot(buffer)) {
	              url.shortenPath();

	              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
	                push$4(url.path, '');
	              }
	            } else if (isSingleDot(buffer)) {
	              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
	                push$4(url.path, '');
	              }
	            } else {
	              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
	                if (url.host) url.host = '';
	                buffer = charAt$6(buffer, 0) + ':'; // normalize windows drive letter
	              }

	              push$4(url.path, buffer);
	            }

	            buffer = '';

	            if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) {
	              while (url.path.length > 1 && url.path[0] === '') {
	                shift(url.path);
	              }
	            }

	            if (chr == '?') {
	              url.query = '';
	              state = QUERY;
	            } else if (chr == '#') {
	              url.fragment = '';
	              state = FRAGMENT;
	            }
	          } else {
	            buffer += percentEncode(chr, pathPercentEncodeSet);
	          }

	          break;

	        case CANNOT_BE_A_BASE_URL_PATH:
	          if (chr == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (chr == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          } else if (chr != EOF) {
	            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
	          }

	          break;

	        case QUERY:
	          if (!stateOverride && chr == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          } else if (chr != EOF) {
	            if (chr == "'" && url.isSpecial()) url.query += '%27';else if (chr == '#') url.query += '%23';else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
	          }

	          break;

	        case FRAGMENT:
	          if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
	          break;
	      }

	      pointer++;
	    }
	  },
	  // https://url.spec.whatwg.org/#host-parsing
	  parseHost: function parseHost(input) {
	    var result, codePoints, index;

	    if (charAt$6(input, 0) == '[') {
	      if (charAt$6(input, input.length - 1) != ']') return INVALID_HOST;
	      result = parseIPv6(stringSlice$6(input, 1, -1));
	      if (!result) return INVALID_HOST;
	      this.host = result; // opaque host
	    } else if (!this.isSpecial()) {
	      if (exec$4(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
	      result = '';
	      codePoints = arrayFrom(input);

	      for (index = 0; index < codePoints.length; index++) {
	        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
	      }

	      this.host = result;
	    } else {
	      input = stringPunycodeToAscii(input);
	      if (exec$4(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
	      result = parseIPv4(input);
	      if (result === null) return INVALID_HOST;
	      this.host = result;
	    }
	  },
	  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
	  cannotHaveUsernamePasswordPort: function cannotHaveUsernamePasswordPort() {
	    return !this.host || this.cannotBeABaseURL || this.scheme == 'file';
	  },
	  // https://url.spec.whatwg.org/#include-credentials
	  includesCredentials: function includesCredentials() {
	    return this.username != '' || this.password != '';
	  },
	  // https://url.spec.whatwg.org/#is-special
	  isSpecial: function isSpecial() {
	    return hasOwnProperty_1(specialSchemes, this.scheme);
	  },
	  // https://url.spec.whatwg.org/#shorten-a-urls-path
	  shortenPath: function shortenPath() {
	    var path = this.path;
	    var pathSize = path.length;

	    if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
	      path.length--;
	    }
	  },
	  // https://url.spec.whatwg.org/#concept-url-serializer
	  serialize: function serialize() {
	    var url = this;
	    var scheme = url.scheme;
	    var username = url.username;
	    var password = url.password;
	    var host = url.host;
	    var port = url.port;
	    var path = url.path;
	    var query = url.query;
	    var fragment = url.fragment;
	    var output = scheme + ':';

	    if (host !== null) {
	      output += '//';

	      if (url.includesCredentials()) {
	        output += username + (password ? ':' + password : '') + '@';
	      }

	      output += serializeHost(host);
	      if (port !== null) output += ':' + port;
	    } else if (scheme == 'file') output += '//';

	    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join$4(path, '/') : '';
	    if (query !== null) output += '?' + query;
	    if (fragment !== null) output += '#' + fragment;
	    return output;
	  },
	  // https://url.spec.whatwg.org/#dom-url-href
	  setHref: function setHref(href) {
	    var failure = this.parse(href);
	    if (failure) throw TypeError$a(failure);
	    this.searchParams.update();
	  },
	  // https://url.spec.whatwg.org/#dom-url-origin
	  getOrigin: function getOrigin() {
	    var scheme = this.scheme;
	    var port = this.port;
	    if (scheme == 'blob') try {
	      return new URLConstructor(scheme.path[0]).origin;
	    } catch (error) {
	      return 'null';
	    }
	    if (scheme == 'file' || !this.isSpecial()) return 'null';
	    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
	  },
	  // https://url.spec.whatwg.org/#dom-url-protocol
	  getProtocol: function getProtocol() {
	    return this.scheme + ':';
	  },
	  setProtocol: function setProtocol(protocol) {
	    this.parse(toString_1(protocol) + ':', SCHEME_START);
	  },
	  // https://url.spec.whatwg.org/#dom-url-username
	  getUsername: function getUsername() {
	    return this.username;
	  },
	  setUsername: function setUsername(username) {
	    var codePoints = arrayFrom(toString_1(username));
	    if (this.cannotHaveUsernamePasswordPort()) return;
	    this.username = '';

	    for (var i = 0; i < codePoints.length; i++) {
	      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	    }
	  },
	  // https://url.spec.whatwg.org/#dom-url-password
	  getPassword: function getPassword() {
	    return this.password;
	  },
	  setPassword: function setPassword(password) {
	    var codePoints = arrayFrom(toString_1(password));
	    if (this.cannotHaveUsernamePasswordPort()) return;
	    this.password = '';

	    for (var i = 0; i < codePoints.length; i++) {
	      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	    }
	  },
	  // https://url.spec.whatwg.org/#dom-url-host
	  getHost: function getHost() {
	    var host = this.host;
	    var port = this.port;
	    return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
	  },
	  setHost: function setHost(host) {
	    if (this.cannotBeABaseURL) return;
	    this.parse(host, HOST);
	  },
	  // https://url.spec.whatwg.org/#dom-url-hostname
	  getHostname: function getHostname() {
	    var host = this.host;
	    return host === null ? '' : serializeHost(host);
	  },
	  setHostname: function setHostname(hostname) {
	    if (this.cannotBeABaseURL) return;
	    this.parse(hostname, HOSTNAME);
	  },
	  // https://url.spec.whatwg.org/#dom-url-port
	  getPort: function getPort() {
	    var port = this.port;
	    return port === null ? '' : toString_1(port);
	  },
	  setPort: function setPort(port) {
	    if (this.cannotHaveUsernamePasswordPort()) return;
	    port = toString_1(port);
	    if (port == '') this.port = null;else this.parse(port, PORT);
	  },
	  // https://url.spec.whatwg.org/#dom-url-pathname
	  getPathname: function getPathname() {
	    var path = this.path;
	    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join$4(path, '/') : '';
	  },
	  setPathname: function setPathname(pathname) {
	    if (this.cannotBeABaseURL) return;
	    this.path = [];
	    this.parse(pathname, PATH_START);
	  },
	  // https://url.spec.whatwg.org/#dom-url-search
	  getSearch: function getSearch() {
	    var query = this.query;
	    return query ? '?' + query : '';
	  },
	  setSearch: function setSearch(search) {
	    search = toString_1(search);

	    if (search == '') {
	      this.query = null;
	    } else {
	      if ('?' == charAt$6(search, 0)) search = stringSlice$6(search, 1);
	      this.query = '';
	      this.parse(search, QUERY);
	    }

	    this.searchParams.update();
	  },
	  // https://url.spec.whatwg.org/#dom-url-searchparams
	  getSearchParams: function getSearchParams() {
	    return this.searchParams.facade;
	  },
	  // https://url.spec.whatwg.org/#dom-url-hash
	  getHash: function getHash() {
	    var fragment = this.fragment;
	    return fragment ? '#' + fragment : '';
	  },
	  setHash: function setHash(hash) {
	    hash = toString_1(hash);

	    if (hash == '') {
	      this.fragment = null;
	      return;
	    }

	    if ('#' == charAt$6(hash, 0)) hash = stringSlice$6(hash, 1);
	    this.fragment = '';
	    this.parse(hash, FRAGMENT);
	  },
	  update: function update() {
	    this.query = this.searchParams.serialize() || null;
	  }
	}; // `URL` constructor
	// https://url.spec.whatwg.org/#url-class

	var URLConstructor = function URL(url
	/* , base */
	) {
	  var that = anInstance(this, URLPrototype);
	  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;
	  var state = setInternalState$5(that, new URLState(url, false, base));

	  if (!descriptors) {
	    that.href = state.serialize();
	    that.origin = state.getOrigin();
	    that.protocol = state.getProtocol();
	    that.username = state.getUsername();
	    that.password = state.getPassword();
	    that.host = state.getHost();
	    that.hostname = state.getHostname();
	    that.port = state.getPort();
	    that.pathname = state.getPathname();
	    that.search = state.getSearch();
	    that.searchParams = state.getSearchParams();
	    that.hash = state.getHash();
	  }
	};

	var URLPrototype = URLConstructor.prototype;

	var accessorDescriptor = function accessorDescriptor(getter, setter) {
	  return {
	    get: function get() {
	      return getInternalURLState(this)[getter]();
	    },
	    set: setter && function (value) {
	      return getInternalURLState(this)[setter](value);
	    },
	    configurable: true,
	    enumerable: true
	  };
	};

	if (descriptors) {
	  defineProperties$2(URLPrototype, {
	    // `URL.prototype.href` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-href
	    href: accessorDescriptor('serialize', 'setHref'),
	    // `URL.prototype.origin` getter
	    // https://url.spec.whatwg.org/#dom-url-origin
	    origin: accessorDescriptor('getOrigin'),
	    // `URL.prototype.protocol` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-protocol
	    protocol: accessorDescriptor('getProtocol', 'setProtocol'),
	    // `URL.prototype.username` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-username
	    username: accessorDescriptor('getUsername', 'setUsername'),
	    // `URL.prototype.password` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-password
	    password: accessorDescriptor('getPassword', 'setPassword'),
	    // `URL.prototype.host` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-host
	    host: accessorDescriptor('getHost', 'setHost'),
	    // `URL.prototype.hostname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hostname
	    hostname: accessorDescriptor('getHostname', 'setHostname'),
	    // `URL.prototype.port` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-port
	    port: accessorDescriptor('getPort', 'setPort'),
	    // `URL.prototype.pathname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-pathname
	    pathname: accessorDescriptor('getPathname', 'setPathname'),
	    // `URL.prototype.search` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-search
	    search: accessorDescriptor('getSearch', 'setSearch'),
	    // `URL.prototype.searchParams` getter
	    // https://url.spec.whatwg.org/#dom-url-searchparams
	    searchParams: accessorDescriptor('getSearchParams'),
	    // `URL.prototype.hash` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hash
	    hash: accessorDescriptor('getHash', 'setHash')
	  });
	} // `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson


	redefine(URLPrototype, 'toJSON', function toJSON() {
	  return getInternalURLState(this).serialize();
	}, {
	  enumerable: true
	}); // `URL.prototype.toString` method
	// https://url.spec.whatwg.org/#URL-stringification-behavior

	redefine(URLPrototype, 'toString', function toString() {
	  return getInternalURLState(this).serialize();
	}, {
	  enumerable: true
	});

	if (NativeURL) {
	  var nativeCreateObjectURL = NativeURL.createObjectURL;
	  var nativeRevokeObjectURL = NativeURL.revokeObjectURL; // `URL.createObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL

	  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', functionBindContext(nativeCreateObjectURL, NativeURL)); // `URL.revokeObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL

	  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', functionBindContext(nativeRevokeObjectURL, NativeURL));
	}

	setToStringTag(URLConstructor, 'URL');
	_export({
	  global: true,
	  forced: !nativeUrl,
	  sham: !descriptors
	}, {
	  URL: URLConstructor
	});

	var $map$1 = arrayIteration.map;



	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map'); // `Array.prototype.map` method
	// https://tc39.es/ecma262/#sec-array.prototype.map
	// with adding support of @@species

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT$1
	}, {
	  map: function map(callbackfn
	  /* , thisArg */
	  ) {
	    return $map$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Symbol.hasInstance` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.hasinstance


	defineWellKnownSymbol('hasInstance');

	// `Symbol.isConcatSpreadable` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable


	defineWellKnownSymbol('isConcatSpreadable');

	// `Symbol.match` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.match


	defineWellKnownSymbol('match');

	// `Symbol.replace` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.replace


	defineWellKnownSymbol('replace');

	// `Symbol.search` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.search


	defineWellKnownSymbol('search');

	// `Symbol.species` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.species


	defineWellKnownSymbol('species');

	// `Symbol.split` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.split


	defineWellKnownSymbol('split');

	// `Symbol.toPrimitive` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.toprimitive


	defineWellKnownSymbol('toPrimitive');

	// `Symbol.unscopables` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.unscopables


	defineWellKnownSymbol('unscopables');

	var min$4 = Math.min; // `Array.prototype.copyWithin` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.copywithin
	// eslint-disable-next-line es/no-array-prototype-copywithin -- safe

	var arrayCopyWithin = [].copyWithin || function copyWithin(target
	/* = 0 */
	, start
	/* = 0, end = @length */
	) {
	  var O = toObject(this);
	  var len = lengthOfArrayLike(O);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = min$4((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;

	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }

	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }

	  return O;
	};

	// `Array.prototype.copyWithin` method
	// https://tc39.es/ecma262/#sec-array.prototype.copywithin


	_export({
	  target: 'Array',
	  proto: true
	}, {
	  copyWithin: arrayCopyWithin
	}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables('copyWithin');

	var $every$1 = arrayIteration.every;



	var STRICT_METHOD$6 = arrayMethodIsStrict('every'); // `Array.prototype.every` method
	// https://tc39.es/ecma262/#sec-array.prototype.every

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$6
	}, {
	  every: function every(callbackfn
	  /* , thisArg */
	  ) {
	    return $every$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.prototype.fill` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.fill


	var arrayFill = function fill(value
	/* , start = 0, end = @length */
	) {
	  var O = toObject(this);
	  var length = lengthOfArrayLike(O);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

	  while (endPos > index) {
	    O[index++] = value;
	  }

	  return O;
	};

	// `Array.prototype.fill` method
	// https://tc39.es/ecma262/#sec-array.prototype.fill


	_export({
	  target: 'Array',
	  proto: true
	}, {
	  fill: arrayFill
	}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables('fill');

	var $filter$1 = arrayIteration.filter;



	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // `Array.prototype.filter` method
	// https://tc39.es/ecma262/#sec-array.prototype.filter
	// with adding support of @@species

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT
	}, {
	  filter: function filter(callbackfn
	  /* , thisArg */
	  ) {
	    return $filter$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $findIndex$1 = arrayIteration.findIndex;



	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES = true; // Shouldn't skip holes

	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
	  SKIPS_HOLES = false;
	}); // `Array.prototype.findIndex` method
	// https://tc39.es/ecma262/#sec-array.prototype.findindex

	_export({
	  target: 'Array',
	  proto: true,
	  forced: SKIPS_HOLES
	}, {
	  findIndex: function findIndex(callbackfn
	  /* , that = undefined */
	  ) {
	    return $findIndex$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables(FIND_INDEX);

	var TypeError$9 = global_1.TypeError; // `FlattenIntoArray` abstract operation
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

	var flattenIntoArray = function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? functionBindContext(mapper, thisArg) : false;
	  var element, elementLen;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      if (depth > 0 && isArray$1(element)) {
	        elementLen = lengthOfArrayLike(element);
	        targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError$9('Exceed the acceptable array length');
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }

	    sourceIndex++;
	  }

	  return targetIndex;
	};

	var flattenIntoArray_1 = flattenIntoArray;

	// `Array.prototype.flat` method
	// https://tc39.es/ecma262/#sec-array.prototype.flat


	_export({
	  target: 'Array',
	  proto: true
	}, {
	  flat: function
	    /* depthArg = 1 */
	  flat() {
	    var depthArg = arguments.length ? arguments[0] : undefined;
	    var O = toObject(this);
	    var sourceLen = lengthOfArrayLike(O);
	    var A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toIntegerOrInfinity(depthArg));
	    return A;
	  }
	});

	// `Array.prototype.flatMap` method
	// https://tc39.es/ecma262/#sec-array.prototype.flatmap


	_export({
	  target: 'Array',
	  proto: true
	}, {
	  flatMap: function flatMap(callbackfn
	  /* , thisArg */
	  ) {
	    var O = toObject(this);
	    var sourceLen = lengthOfArrayLike(O);
	    var A;
	    aCallable(callbackfn);
	    A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return A;
	  }
	});

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function next() {
	      return {
	        done: !!called++
	      };
	    },
	    'return': function _return() {
	      SAFE_CLOSING = true;
	    }
	  };

	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  }; // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing


	  Array.from(iteratorWithReturn, function () {
	    throw 2;
	  });
	} catch (error) {
	  /* empty */
	}

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;

	  try {
	    var object = {};

	    object[ITERATOR$2] = function () {
	      return {
	        next: function next() {
	          return {
	            done: ITERATION_SUPPORT = true
	          };
	        }
	      };
	    };

	    exec(object);
	  } catch (error) {
	    /* empty */
	  }

	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION$1 = !checkCorrectnessOfIteration(function (iterable) {
	  // eslint-disable-next-line es/no-array-from -- required for testing
	  Array.from(iterable);
	}); // `Array.from` method
	// https://tc39.es/ecma262/#sec-array.from

	_export({
	  target: 'Array',
	  stat: true,
	  forced: INCORRECT_ITERATION$1
	}, {
	  from: arrayFrom
	});

	var $includes$1 = arrayIncludes.includes;

	 // `Array.prototype.includes` method
	// https://tc39.es/ecma262/#sec-array.prototype.includes


	_export({
	  target: 'Array',
	  proto: true
	}, {
	  includes: function includes(el
	  /* , fromIndex = 0 */
	  ) {
	    return $includes$1(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables('includes');

	// `Array.isArray` method
	// https://tc39.es/ecma262/#sec-array.isarray


	_export({
	  target: 'Array',
	  stat: true
	}, {
	  isArray: isArray$1
	});

	var un$Join = functionUncurryThis([].join);
	var ES3_STRINGS = indexedObject != Object;
	var STRICT_METHOD$5 = arrayMethodIsStrict('join', ','); // `Array.prototype.join` method
	// https://tc39.es/ecma262/#sec-array.prototype.join

	_export({
	  target: 'Array',
	  proto: true,
	  forced: ES3_STRINGS || !STRICT_METHOD$5
	}, {
	  join: function join(separator) {
	    return un$Join(toIndexedObject(this), separator === undefined ? ',' : separator);
	  }
	});

	/* eslint-disable es/no-array-prototype-lastindexof -- safe */











	var min$3 = Math.min;
	var $lastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$4 = arrayMethodIsStrict('lastIndexOf');
	var FORCED$j = NEGATIVE_ZERO || !STRICT_METHOD$4; // `Array.prototype.lastIndexOf` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.lastindexof

	var arrayLastIndexOf = FORCED$j ? function lastIndexOf(searchElement
	/* , fromIndex = @[*-1] */
	) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO) return functionApply($lastIndexOf, this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = lengthOfArrayLike(O);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$3(index, toIntegerOrInfinity(arguments[1]));
	  if (index < 0) index = length + index;

	  for (; index >= 0; index--) {
	    if (index in O && O[index] === searchElement) return index || 0;
	  }

	  return -1;
	} : $lastIndexOf;

	// `Array.prototype.lastIndexOf` method
	// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
	// eslint-disable-next-line es/no-array-prototype-lastindexof -- required for testing


	_export({
	  target: 'Array',
	  proto: true,
	  forced: arrayLastIndexOf !== [].lastIndexOf
	}, {
	  lastIndexOf: arrayLastIndexOf
	});

	var Array$5 = global_1.Array;
	var ISNT_GENERIC = fails(function () {
	  function F() {
	    /* empty */
	  }

	  return !(Array$5.of.call(F) instanceof F);
	}); // `Array.of` method
	// https://tc39.es/ecma262/#sec-array.of
	// WebKit Array.of isn't generic

	_export({
	  target: 'Array',
	  stat: true,
	  forced: ISNT_GENERIC
	}, {
	  of: function
	    /* ...args */
	  of() {
	    var index = 0;
	    var argumentsLength = arguments.length;
	    var result = new (isConstructor(this) ? this : Array$5)(argumentsLength);

	    while (argumentsLength > index) {
	      createProperty(result, index, arguments[index++]);
	    }

	    result.length = argumentsLength;
	    return result;
	  }
	});

	var TypeError$8 = global_1.TypeError; // `Array.prototype.{ reduce, reduceRight }` methods implementation

	var createMethod$2 = function createMethod(IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aCallable(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = lengthOfArrayLike(O);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }

	      index += i;

	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError$8('Reduce of empty array with no initial value');
	      }
	    }

	    for (; IS_RIGHT ? index >= 0 : length > index; index += i) {
	      if (index in self) {
	        memo = callbackfn(memo, self[index], index, O);
	      }
	    }

	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.es/ecma262/#sec-array.prototype.reduce
	  left: createMethod$2(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$2(true)
	};

	var engineIsNode = classofRaw(global_1.process) == 'process';

	var $reduce$1 = arrayReduce.left;







	var STRICT_METHOD$3 = arrayMethodIsStrict('reduce'); // Chrome 80-82 has a critical bug
	// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

	var CHROME_BUG$1 = !engineIsNode && engineV8Version > 79 && engineV8Version < 83; // `Array.prototype.reduce` method
	// https://tc39.es/ecma262/#sec-array.prototype.reduce

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$3 || CHROME_BUG$1
	}, {
	  reduce: function reduce(callbackfn
	  /* , initialValue */
	  ) {
	    var length = arguments.length;
	    return $reduce$1(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
	  }
	});

	var $reduceRight$1 = arrayReduce.right;







	var STRICT_METHOD$2 = arrayMethodIsStrict('reduceRight'); // Chrome 80-82 has a critical bug
	// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

	var CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83; // `Array.prototype.reduceRight` method
	// https://tc39.es/ecma262/#sec-array.prototype.reduceright

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$2 || CHROME_BUG
	}, {
	  reduceRight: function reduceRight(callbackfn
	  /* , initialValue */
	  ) {
	    return $reduceRight$1(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $some$1 = arrayIteration.some;



	var STRICT_METHOD$1 = arrayMethodIsStrict('some'); // `Array.prototype.some` method
	// https://tc39.es/ecma262/#sec-array.prototype.some

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$1
	}, {
	  some: function some(callbackfn
	  /* , thisArg */
	  ) {
	    return $some$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var firefox = engineUserAgent.match(/firefox\/(\d+)/i);
	var engineFfVersion = !!firefox && +firefox[1];

	var engineIsIeOrEdge = /MSIE|Trident/.test(engineUserAgent);

	var webkit = engineUserAgent.match(/AppleWebKit\/(\d+)\./);
	var engineWebkitVersion = !!webkit && +webkit[1];

	var test = [];
	var un$Sort$1 = functionUncurryThis(test.sort);
	var push$3 = functionUncurryThis(test.push); // IE8-

	var FAILS_ON_UNDEFINED = fails(function () {
	  test.sort(undefined);
	}); // V8 bug

	var FAILS_ON_NULL = fails(function () {
	  test.sort(null);
	}); // Old WebKit

	var STRICT_METHOD = arrayMethodIsStrict('sort');
	var STABLE_SORT$1 = !fails(function () {
	  // feature detection can be too slow, so check engines versions
	  if (engineV8Version) return engineV8Version < 70;
	  if (engineFfVersion && engineFfVersion > 3) return;
	  if (engineIsIeOrEdge) return true;
	  if (engineWebkitVersion) return engineWebkitVersion < 603;
	  var result = '';
	  var code, chr, value, index; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)

	  for (code = 65; code < 76; code++) {
	    chr = String.fromCharCode(code);

	    switch (code) {
	      case 66:
	      case 69:
	      case 70:
	      case 72:
	        value = 3;
	        break;

	      case 68:
	      case 71:
	        value = 4;
	        break;

	      default:
	        value = 2;
	    }

	    for (index = 0; index < 47; index++) {
	      test.push({
	        k: chr + index,
	        v: value
	      });
	    }
	  }

	  test.sort(function (a, b) {
	    return b.v - a.v;
	  });

	  for (index = 0; index < test.length; index++) {
	    chr = test[index].k.charAt(0);
	    if (result.charAt(result.length - 1) !== chr) result += chr;
	  }

	  return result !== 'DGBEFHACIJK';
	});
	var FORCED$i = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT$1;

	var getSortCompare$1 = function getSortCompare(comparefn) {
	  return function (x, y) {
	    if (y === undefined) return -1;
	    if (x === undefined) return 1;
	    if (comparefn !== undefined) return +comparefn(x, y) || 0;
	    return toString_1(x) > toString_1(y) ? 1 : -1;
	  };
	}; // `Array.prototype.sort` method
	// https://tc39.es/ecma262/#sec-array.prototype.sort


	_export({
	  target: 'Array',
	  proto: true,
	  forced: FORCED$i
	}, {
	  sort: function sort(comparefn) {
	    if (comparefn !== undefined) aCallable(comparefn);
	    var array = toObject(this);
	    if (STABLE_SORT$1) return comparefn === undefined ? un$Sort$1(array) : un$Sort$1(array, comparefn);
	    var items = [];
	    var arrayLength = lengthOfArrayLike(array);
	    var itemsLength, index;

	    for (index = 0; index < arrayLength; index++) {
	      if (index in array) push$3(items, array[index]);
	    }

	    arraySort(items, getSortCompare$1(comparefn));
	    itemsLength = items.length;
	    index = 0;

	    while (index < itemsLength) {
	      array[index] = items[index++];
	    }

	    while (index < arrayLength) {
	      delete array[index++];
	    }

	    return array;
	  }
	});

	var SPECIES$1 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$1]) {
	    defineProperty(Constructor, SPECIES$1, {
	      configurable: true,
	      get: function get() {
	        return this;
	      }
	    });
	  }
	};

	// `Array[@@species]` getter
	// https://tc39.es/ecma262/#sec-get-array-@@species


	setSpecies('Array');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module
	 // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables


	addToUnscopables('flat');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module
	 // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables


	addToUnscopables('flatMap');

	// eslint-disable-next-line es/no-typed-arrays -- safe
	var arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

	var RangeError$8 = global_1.RangeError; // `ToIndex` abstract operation
	// https://tc39.es/ecma262/#sec-toindex

	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toIntegerOrInfinity(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError$8('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754


	var Array$4 = global_1.Array;
	var abs$7 = Math.abs;
	var pow$3 = Math.pow;
	var floor$5 = Math.floor;
	var log$8 = Math.log;
	var LN2$2 = Math.LN2;

	var pack = function pack(number, mantissaLength, bytes) {
	  var buffer = Array$4(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow$3(2, -24) - pow$3(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs$7(number); // eslint-disable-next-line no-self-compare -- NaN check

	  if (number != number || number === Infinity) {
	    // eslint-disable-next-line no-self-compare -- NaN check
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$5(log$8(number) / LN2$2);
	    c = pow$3(2, -exponent);

	    if (number * c < 1) {
	      exponent--;
	      c *= 2;
	    }

	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow$3(2, 1 - eBias);
	    }

	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }

	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow$3(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow$3(2, eBias - 1) * pow$3(2, mantissaLength);
	      exponent = 0;
	    }
	  }

	  while (mantissaLength >= 8) {
	    buffer[index++] = mantissa & 255;
	    mantissa /= 256;
	    mantissaLength -= 8;
	  }

	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;

	  while (exponentLength > 0) {
	    buffer[index++] = exponent & 255;
	    exponent /= 256;
	    exponentLength -= 8;
	  }

	  buffer[--index] |= sign * 128;
	  return buffer;
	};

	var unpack = function unpack(buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;

	  while (nBits > 0) {
	    exponent = exponent * 256 + buffer[index--];
	    nBits -= 8;
	  }

	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;

	  while (nBits > 0) {
	    mantissa = mantissa * 256 + buffer[index--];
	    nBits -= 8;
	  }

	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity : Infinity;
	  } else {
	    mantissa = mantissa + pow$3(2, mantissaLength);
	    exponent = exponent - eBias;
	  }

	  return (sign ? -1 : 1) * mantissa * pow$3(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;

	var defineProperty$7 = objectDefineProperty.f;









	var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
	var getInternalState$4 = internalState.get;
	var setInternalState$4 = internalState.set;
	var ARRAY_BUFFER$1 = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];
	var $ArrayBuffer = NativeArrayBuffer$1;
	var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
	var $DataView = global_1[DATA_VIEW];
	var DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE];
	var ObjectPrototype$2 = Object.prototype;
	var Array$3 = global_1.Array;
	var RangeError$7 = global_1.RangeError;
	var fill = functionUncurryThis(arrayFill);
	var reverse = functionUncurryThis([].reverse);
	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;

	var packInt8 = function packInt8(number) {
	  return [number & 0xFF];
	};

	var packInt16 = function packInt16(number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function packInt32(number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function unpackInt32(buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function packFloat32(number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function packFloat64(number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter = function addGetter(Constructor, key) {
	  defineProperty$7(Constructor[PROTOTYPE], key, {
	    get: function get() {
	      return getInternalState$4(this)[key];
	    }
	  });
	};

	var get$1 = function get(view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$4(view);
	  if (intIndex + count > store.byteLength) throw RangeError$7(WRONG_INDEX);
	  var bytes = getInternalState$4(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = arraySliceSimple(bytes, start, start + count);
	  return isLittleEndian ? pack : reverse(pack);
	};

	var set$2 = function set(view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$4(view);
	  if (intIndex + count > store.byteLength) throw RangeError$7(WRONG_INDEX);
	  var bytes = getInternalState$4(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);

	  for (var i = 0; i < count; i++) {
	    bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	  }
	};

	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, ArrayBufferPrototype);
	    var byteLength = toIndex(length);
	    setInternalState$4(this, {
	      bytes: fill(Array$3(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };

	  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, DataViewPrototype$1);
	    anInstance(buffer, ArrayBufferPrototype);
	    var bufferLength = getInternalState$4(buffer).byteLength;
	    var offset = toIntegerOrInfinity(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$7('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$7(WRONG_LENGTH);
	    setInternalState$4(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });

	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  DataViewPrototype$1 = $DataView[PROTOTYPE];

	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }

	  redefineAll(DataViewPrototype$1, {
	    getInt8: function getInt8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$2(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$2(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$2(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$2(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME$1 && NativeArrayBuffer$1.name !== ARRAY_BUFFER$1;
	  /* eslint-disable no-new -- required for testing */

	  if (!fails(function () {
	    NativeArrayBuffer$1(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer$1(-1);
	  }) || fails(function () {
	    new NativeArrayBuffer$1();
	    new NativeArrayBuffer$1(1.5);
	    new NativeArrayBuffer$1(NaN);
	    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
	  })) {
	    /* eslint-enable no-new -- required for testing */
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, ArrayBufferPrototype);
	      return new NativeArrayBuffer$1(toIndex(length));
	    };

	    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;

	    for (var keys$1 = getOwnPropertyNames$1(NativeArrayBuffer$1), j = 0, key$2; keys$1.length > j;) {
	      if (!((key$2 = keys$1[j++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key$2, NativeArrayBuffer$1[key$2]);
	      }
	    }

	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
	    createNonEnumerableProperty(NativeArrayBuffer$1, 'name', ARRAY_BUFFER$1);
	  } // WebKit bug - the same parent prototype for typed arrays and data view


	  if (objectSetPrototypeOf && objectGetPrototypeOf(DataViewPrototype$1) !== ObjectPrototype$2) {
	    objectSetPrototypeOf(DataViewPrototype$1, ObjectPrototype$2);
	  } // iOS Safari 7.x bug


	  var testView = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = functionUncurryThis(DataViewPrototype$1.setInt8);
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll(DataViewPrototype$1, {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    }
	  }, {
	    unsafe: true
	  });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER$1);
	setToStringTag($DataView, DATA_VIEW);
	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var ARRAY_BUFFER = 'ArrayBuffer';
	var ArrayBuffer$3 = arrayBuffer[ARRAY_BUFFER];
	var NativeArrayBuffer = global_1[ARRAY_BUFFER]; // `ArrayBuffer` constructor
	// https://tc39.es/ecma262/#sec-arraybuffer-constructor

	_export({
	  global: true,
	  forced: NativeArrayBuffer !== ArrayBuffer$3
	}, {
	  ArrayBuffer: ArrayBuffer$3
	});
	setSpecies(ARRAY_BUFFER);

	var defineProperty$6 = objectDefineProperty.f;











	var Int8Array$4 = global_1.Int8Array;
	var Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;
	var Uint8ClampedArray$1 = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
	var TypedArray = Int8Array$4 && objectGetPrototypeOf(Int8Array$4);
	var TypedArrayPrototype$1 = Int8ArrayPrototype$1 && objectGetPrototypeOf(Int8ArrayPrototype$1);
	var ObjectPrototype$1 = Object.prototype;
	var TypeError$7 = global_1.TypeError;
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
	var TYPED_ARRAY_CONSTRUCTOR$1 = uid('TYPED_ARRAY_CONSTRUCTOR'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

	var NATIVE_ARRAY_BUFFER_VIEWS$2 = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQUIRED = false;
	var NAME, Constructor, Prototype;
	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};
	var BigIntArrayConstructorsList = {
	  BigInt64Array: 8,
	  BigUint64Array: 8
	};

	var isView = function isView(it) {
	  if (!isObject$1(it)) return false;
	  var klass = classof(it);
	  return klass === 'DataView' || hasOwnProperty_1(TypedArrayConstructorsList, klass) || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
	};

	var isTypedArray = function isTypedArray(it) {
	  if (!isObject$1(it)) return false;
	  var klass = classof(it);
	  return hasOwnProperty_1(TypedArrayConstructorsList, klass) || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
	};

	var aTypedArray$n = function aTypedArray(it) {
	  if (isTypedArray(it)) return it;
	  throw TypeError$7('Target is not a typed array');
	};

	var aTypedArrayConstructor$3 = function aTypedArrayConstructor(C) {
	  if (isCallable(C) && (!objectSetPrototypeOf || objectIsPrototypeOf(TypedArray, C))) return C;
	  throw TypeError$7(tryToString(C) + ' is not a typed array constructor');
	};

	var exportTypedArrayMethod$o = function exportTypedArrayMethod(KEY, property, forced, options) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor.prototype, KEY)) try {
	      delete TypedArrayConstructor.prototype[KEY];
	    } catch (error) {
	      // old WebKit bug - some methods are non-configurable
	      try {
	        TypedArrayConstructor.prototype[KEY] = property;
	      } catch (error2) {
	        /* empty */
	      }
	    }
	  }

	  if (!TypedArrayPrototype$1[KEY] || forced) {
	    redefine(TypedArrayPrototype$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);
	  }
	};

	var exportTypedArrayStaticMethod$2 = function exportTypedArrayStaticMethod(KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;

	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];
	      if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor, KEY)) try {
	        delete TypedArrayConstructor[KEY];
	      } catch (error) {
	        /* empty */
	      }
	    }

	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray[KEY] || property);
	      } catch (error) {
	        /* empty */
	      }
	    } else return;
	  }

	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME in TypedArrayConstructorsList) {
	  Constructor = global_1[NAME];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR$1, Constructor);else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
	}

	for (NAME in BigIntArrayConstructorsList) {
	  Constructor = global_1[NAME];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR$1, Constructor);
	} // WebKit bug - typed arrays constructors prototype is Object.prototype


	if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable(TypedArray) || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow -- safe
	  TypedArray = function TypedArray() {
	    throw TypeError$7('Incorrect invocation');
	  };

	  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {
	  TypedArrayPrototype$1 = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype$1);
	  }
	} // WebKit bug - one more object in Uint8ClampedArray prototype chain


	if (NATIVE_ARRAY_BUFFER_VIEWS$2 && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);
	}

	if (descriptors && !hasOwnProperty_1(TypedArrayPrototype$1, TO_STRING_TAG)) {
	  TYPED_ARRAY_TAG_REQUIRED = true;
	  defineProperty$6(TypedArrayPrototype$1, TO_STRING_TAG, {
	    get: function get() {
	      return isObject$1(this) ? this[TYPED_ARRAY_TAG] : undefined;
	    }
	  });

	  for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) {
	      createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
	    }
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
	  TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR$1,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray$n,
	  aTypedArrayConstructor: aTypedArrayConstructor$3,
	  exportTypedArrayMethod: exportTypedArrayMethod$o,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$2,
	  isView: isView,
	  isTypedArray: isTypedArray,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype$1
	};

	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS; // `ArrayBuffer.isView` method
	// https://tc39.es/ecma262/#sec-arraybuffer.isview

	_export({
	  target: 'ArrayBuffer',
	  stat: true,
	  forced: !NATIVE_ARRAY_BUFFER_VIEWS$1
	}, {
	  isView: arrayBufferViewCore.isView
	});

	var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
	var DataView$1 = arrayBuffer.DataView;
	var DataViewPrototype = DataView$1.prototype;
	var un$ArrayBufferSlice = functionUncurryThis(ArrayBuffer$2.prototype.slice);
	var getUint8 = functionUncurryThis(DataViewPrototype.getUint8);
	var setUint8 = functionUncurryThis(DataViewPrototype.setUint8);
	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
	}); // `ArrayBuffer.prototype.slice` method
	// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice

	_export({
	  target: 'ArrayBuffer',
	  proto: true,
	  unsafe: true,
	  forced: INCORRECT_SLICE
	}, {
	  slice: function slice(start, end) {
	    if (un$ArrayBufferSlice && end === undefined) {
	      return un$ArrayBufferSlice(anObject(this), start); // FF fix
	    }

	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
	    var viewSource = new DataView$1(this);
	    var viewTarget = new DataView$1(result);
	    var index = 0;

	    while (first < fin) {
	      setUint8(viewTarget, index++, getUint8(viewSource, first++));
	    }

	    return result;
	  }
	});

	// `DataView` constructor
	// https://tc39.es/ecma262/#sec-dataview-constructor


	_export({
	  global: true,
	  forced: !arrayBufferNative
	}, {
	  DataView: arrayBuffer.DataView
	});

	var Date$1 = global_1.Date;
	var getTime$1 = functionUncurryThis(Date$1.prototype.getTime); // `Date.now` method
	// https://tc39.es/ecma262/#sec-date.now

	_export({
	  target: 'Date',
	  stat: true
	}, {
	  now: function now() {
	    return getTime$1(new Date$1());
	  }
	});

	var RangeError$6 = global_1.RangeError; // `String.prototype.repeat` method implementation
	// https://tc39.es/ecma262/#sec-string.prototype.repeat

	var stringRepeat = function repeat(count) {
	  var str = toString_1(requireObjectCoercible(this));
	  var result = '';
	  var n = toIntegerOrInfinity(count);
	  if (n < 0 || n == Infinity) throw RangeError$6('Wrong number of repetitions');

	  for (; n > 0; (n >>>= 1) && (str += str)) {
	    if (n & 1) result += str;
	  }

	  return result;
	};

	// https://github.com/tc39/proposal-string-pad-start-end










	var repeat$1 = functionUncurryThis(stringRepeat);
	var stringSlice$5 = functionUncurryThis(''.slice);
	var ceil$1 = Math.ceil; // `String.prototype.{ padStart, padEnd }` methods implementation

	var createMethod$1 = function createMethod(IS_END) {
	  return function ($this, maxLength, fillString) {
	    var S = toString_1(requireObjectCoercible($this));
	    var intMaxLength = toLength(maxLength);
	    var stringLength = S.length;
	    var fillStr = fillString === undefined ? ' ' : toString_1(fillString);
	    var fillLen, stringFiller;
	    if (intMaxLength <= stringLength || fillStr == '') return S;
	    fillLen = intMaxLength - stringLength;
	    stringFiller = repeat$1(fillStr, ceil$1(fillLen / fillStr.length));
	    if (stringFiller.length > fillLen) stringFiller = stringSlice$5(stringFiller, 0, fillLen);
	    return IS_END ? S + stringFiller : stringFiller + S;
	  };
	};

	var stringPad = {
	  // `String.prototype.padStart` method
	  // https://tc39.es/ecma262/#sec-string.prototype.padstart
	  start: createMethod$1(false),
	  // `String.prototype.padEnd` method
	  // https://tc39.es/ecma262/#sec-string.prototype.padend
	  end: createMethod$1(true)
	};

	var padStart = stringPad.start;

	var RangeError$5 = global_1.RangeError;
	var abs$6 = Math.abs;
	var DatePrototype$1 = Date.prototype;
	var n$DateToISOString = DatePrototype$1.toISOString;
	var getTime = functionUncurryThis(DatePrototype$1.getTime);
	var getUTCDate = functionUncurryThis(DatePrototype$1.getUTCDate);
	var getUTCFullYear = functionUncurryThis(DatePrototype$1.getUTCFullYear);
	var getUTCHours = functionUncurryThis(DatePrototype$1.getUTCHours);
	var getUTCMilliseconds = functionUncurryThis(DatePrototype$1.getUTCMilliseconds);
	var getUTCMinutes = functionUncurryThis(DatePrototype$1.getUTCMinutes);
	var getUTCMonth = functionUncurryThis(DatePrototype$1.getUTCMonth);
	var getUTCSeconds = functionUncurryThis(DatePrototype$1.getUTCSeconds); // `Date.prototype.toISOString` method implementation
	// https://tc39.es/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit fails here:

	var dateToIsoString = fails(function () {
	  return n$DateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  n$DateToISOString.call(new Date(NaN));
	}) ? function toISOString() {
	  if (!isFinite(getTime(this))) throw RangeError$5('Invalid time value');
	  var date = this;
	  var year = getUTCFullYear(date);
	  var milliseconds = getUTCMilliseconds(date);
	  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
	  return sign + padStart(abs$6(year), sign ? 6 : 4, 0) + '-' + padStart(getUTCMonth(date) + 1, 2, 0) + '-' + padStart(getUTCDate(date), 2, 0) + 'T' + padStart(getUTCHours(date), 2, 0) + ':' + padStart(getUTCMinutes(date), 2, 0) + ':' + padStart(getUTCSeconds(date), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
	} : n$DateToISOString;

	// `Date.prototype.toISOString` method
	// https://tc39.es/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit has a broken implementations


	_export({
	  target: 'Date',
	  proto: true,
	  forced: Date.prototype.toISOString !== dateToIsoString
	}, {
	  toISOString: dateToIsoString
	});

	var FORCED$h = fails(function () {
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
	    toISOString: function toISOString() {
	      return 1;
	    }
	  }) !== 1;
	}); // `Date.prototype.toJSON` method
	// https://tc39.es/ecma262/#sec-date.prototype.tojson

	_export({
	  target: 'Date',
	  proto: true,
	  forced: FORCED$h
	}, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O, 'number');
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	var TypeError$6 = global_1.TypeError; // `Date.prototype[@@toPrimitive](hint)` method implementation
	// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive

	var dateToPrimitive = function (hint) {
	  anObject(this);
	  if (hint === 'string' || hint === 'default') hint = 'string';else if (hint !== 'number') throw TypeError$6('Incorrect hint');
	  return ordinaryToPrimitive(this, hint);
	};

	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var DatePrototype = Date.prototype; // `Date.prototype[@@toPrimitive]` method
	// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive

	if (!hasOwnProperty_1(DatePrototype, TO_PRIMITIVE)) {
	  redefine(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
	}

	var Function$2 = global_1.Function;
	var concat = functionUncurryThis([].concat);
	var join$3 = functionUncurryThis([].join);
	var factories = {};

	var construct = function construct(C, argsLength, args) {
	  if (!hasOwnProperty_1(factories, argsLength)) {
	    for (var list = [], i = 0; i < argsLength; i++) {
	      list[i] = 'a[' + i + ']';
	    }

	    factories[argsLength] = Function$2('C,a', 'return new C(' + join$3(list, ',') + ')');
	  }

	  return factories[argsLength](C, args);
	}; // `Function.prototype.bind` method implementation
	// https://tc39.es/ecma262/#sec-function.prototype.bind


	var functionBind = functionBindNative ? Function$2.bind : function bind(that
	/* , ...args */
	) {
	  var F = aCallable(this);
	  var Prototype = F.prototype;
	  var partArgs = arraySlice$1(arguments, 1);

	  var boundFunction = function
	    /* args... */
	  bound() {
	    var args = concat(partArgs, arraySlice$1(arguments));
	    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
	  };

	  if (isObject$1(Prototype)) boundFunction.prototype = Prototype;
	  return boundFunction;
	};

	// `Function.prototype.bind` method
	// https://tc39.es/ecma262/#sec-function.prototype.bind


	_export({
	  target: 'Function',
	  proto: true,
	  forced: Function.bind !== functionBind
	}, {
	  bind: functionBind
	});

	var HAS_INSTANCE = wellKnownSymbol('hasInstance');
	var FunctionPrototype = Function.prototype; // `Function.prototype[@@hasInstance]` method
	// https://tc39.es/ecma262/#sec-function.prototype-@@hasinstance

	if (!(HAS_INSTANCE in FunctionPrototype)) {
	  objectDefineProperty.f(FunctionPrototype, HAS_INSTANCE, {
	    value: function value(O) {
	      if (!isCallable(this) || !isObject$1(O)) return false;
	      var P = this.prototype;
	      if (!isObject$1(P)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

	      while (O = objectGetPrototypeOf(O)) {
	        if (P === O) return true;
	      }

	      return false;
	    }
	  });
	}

	// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it


	var arrayBufferNonExtensible = fails(function () {
	  if (typeof ArrayBuffer == 'function') {
	    var buffer = new ArrayBuffer(8); // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe

	    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
	      value: 8
	    });
	  }
	});

	// eslint-disable-next-line es/no-object-isextensible -- safe


	var $isExtensible = Object.isExtensible;
	var FAILS_ON_PRIMITIVES$7 = fails(function () {
	  $isExtensible(1);
	}); // `Object.isExtensible` method
	// https://tc39.es/ecma262/#sec-object.isextensible

	var objectIsExtensible = FAILS_ON_PRIMITIVES$7 || arrayBufferNonExtensible ? function isExtensible(it) {
	  if (!isObject$1(it)) return false;
	  if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return false;
	  return $isExtensible ? $isExtensible(it) : true;
	} : $isExtensible;

	var freezing = !fails(function () {
	  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var _typeof = require$$0["typeof"];











	var defineProperty = objectDefineProperty.f;











	var REQUIRED = false;
	var METADATA = uid('meta');
	var id = 0;

	var setMetadata = function setMetadata(it) {
	  defineProperty(it, METADATA, {
	    value: {
	      objectID: 'O' + id++,
	      // object ID
	      weakData: {} // weak collections IDs

	    }
	  });
	};

	var fastKey = function fastKey(it, create) {
	  // return a primitive with prefix
	  if (!isObject$1(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

	  if (!hasOwnProperty_1(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!objectIsExtensible(it)) return 'F'; // not necessary to add metadata

	    if (!create) return 'E'; // add missing metadata

	    setMetadata(it); // return object ID
	  }

	  return it[METADATA].objectID;
	};

	var getWeakData = function getWeakData(it, create) {
	  if (!hasOwnProperty_1(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!objectIsExtensible(it)) return true; // not necessary to add metadata

	    if (!create) return false; // add missing metadata

	    setMetadata(it); // return the store of weak collections IDs
	  }

	  return it[METADATA].weakData;
	}; // add metadata on freeze-family methods calling


	var onFreeze = function onFreeze(it) {
	  if (freezing && REQUIRED && objectIsExtensible(it) && !hasOwnProperty_1(it, METADATA)) setMetadata(it);
	  return it;
	};

	var enable = function enable() {
	  meta.enable = function () {
	    /* empty */
	  };

	  REQUIRED = true;
	  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	  var splice = functionUncurryThis([].splice);
	  var test = {};
	  test[METADATA] = 1; // prevent exposing of metadata key

	  if (getOwnPropertyNames(test).length) {
	    objectGetOwnPropertyNames.f = function (it) {
	      var result = getOwnPropertyNames(it);

	      for (var i = 0, length = result.length; i < length; i++) {
	        if (result[i] === METADATA) {
	          splice(result, i, 1);
	          break;
	        }
	      }

	      return result;
	    };

	    _export({
	      target: 'Object',
	      stat: true,
	      forced: true
	    }, {
	      getOwnPropertyNames: objectGetOwnPropertyNamesExternal.f
	    });
	  }
	};

	var meta = module.exports = {
	  enable: enable,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};
	hiddenKeys$1[METADATA] = true;
	});
	internalMetadata.enable;
	internalMetadata.fastKey;
	internalMetadata.getWeakData;
	internalMetadata.onFreeze;

	var _typeof$2 = require$$0["typeof"];























	var TypeError$5 = global_1.TypeError;

	var Result = function Result(stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var ResultPrototype = Result.prototype;

	var iterate = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = functionBindContext(unboundFunction, that);
	  var iterator, iterFn, index, length, result, next, step;

	  var stop = function stop(condition) {
	    if (iterator) iteratorClose(iterator, 'normal', condition);
	    return new Result(true, condition);
	  };

	  var callFn = function callFn(value) {
	    if (AS_ENTRIES) {
	      anObject(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    }

	    return INTERRUPTED ? fn(value, stop) : fn(value);
	  };

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (!iterFn) throw TypeError$5(tryToString(iterable) + ' is not iterable'); // optimisation for array iterators

	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && objectIsPrototypeOf(ResultPrototype, result)) return result;
	      }

	      return new Result(false);
	    }

	    iterator = getIterator(iterable, iterFn);
	  }

	  next = iterator.next;

	  while (!(step = functionCall(next, iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator, 'throw', error);
	    }

	    if (_typeof$2(result) == 'object' && result && objectIsPrototypeOf(ResultPrototype, result)) return result;
	  }

	  return new Result(false);
	};

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var Constructor = NativeConstructor;
	  var exported = {};

	  var fixMethod = function fixMethod(KEY) {
	    var uncurriedNativeMethod = functionUncurryThis(NativePrototype[KEY]);
	    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
	      uncurriedNativeMethod(this, value === 0 ? 0 : value);
	      return this;
	    } : KEY == 'delete' ? function (key) {
	      return IS_WEAK && !isObject$1(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
	    } : KEY == 'get' ? function get(key) {
	      return IS_WEAK && !isObject$1(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
	    } : KEY == 'has' ? function has(key) {
	      return IS_WEAK && !isObject$1(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
	    } : function set(key, value) {
	      uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
	      return this;
	    });
	  };

	  var REPLACE = isForced_1(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
	    new NativeConstructor().entries().next();
	  })));

	  if (REPLACE) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.enable();
	  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
	    var instance = new Constructor(); // early implementations not supports chaining

	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

	    var THROWS_ON_PRIMITIVES = fails(function () {
	      instance.has(1);
	    }); // most early implementations doesn't supports iterables, most modern - not close it correctly
	    // eslint-disable-next-line no-new -- required for testing

	    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
	      new NativeConstructor(iterable);
	    }); // for early implementations -0 and +0 not the same

	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new NativeConstructor();
	      var index = 5;

	      while (index--) {
	        $instance[ADDER](index, index);
	      }

	      return !$instance.has(-0);
	    });

	    if (!ACCEPT_ITERABLES) {
	      Constructor = wrapper(function (dummy, iterable) {
	        anInstance(dummy, NativePrototype);
	        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
	        if (iterable != undefined) iterate(iterable, that[ADDER], {
	          that: that,
	          AS_ENTRIES: IS_MAP
	        });
	        return that;
	      });
	      Constructor.prototype = NativePrototype;
	      NativePrototype.constructor = Constructor;
	    }

	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }

	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

	    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
	  }

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({
	    global: true,
	    forced: Constructor != NativeConstructor
	  }, exported);
	  setToStringTag(Constructor, CONSTRUCTOR_NAME);
	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
	  return Constructor;
	};

	var defineProperty$5 = objectDefineProperty.f;

















	var fastKey = internalMetadata.fastKey;



	var setInternalState$3 = internalState.set;
	var internalStateGetterFor$1 = internalState.getterFor;
	var collectionStrong = {
	  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var Constructor = wrapper(function (that, iterable) {
	      anInstance(that, Prototype);
	      setInternalState$3(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate(iterable, that[ADDER], {
	        that: that,
	        AS_ENTRIES: IS_MAP
	      });
	    });
	    var Prototype = Constructor.prototype;
	    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

	    var define = function define(that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index; // change existing entry

	      if (entry) {
	        entry.value = value; // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;else that.size++; // add to index

	        if (index !== 'F') state.index[index] = entry;
	      }

	      return that;
	    };

	    var getEntry = function getEntry(that, key) {
	      var state = getInternalState(that); // fast case

	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index]; // frozen object case

	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };

	    redefineAll(Prototype, {
	      // `{ Map, Set }.prototype.clear()` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.clear
	      // https://tc39.es/ecma262/#sec-set.prototype.clear
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;

	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }

	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;else that.size = 0;
	      },
	      // `{ Map, Set }.prototype.delete(key)` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.delete
	      // https://tc39.es/ecma262/#sec-set.prototype.delete
	      'delete': function _delete(key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);

	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;else that.size--;
	        }

	        return !!entry;
	      },
	      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.foreach
	      // https://tc39.es/ecma262/#sec-set.prototype.foreach
	      forEach: function forEach(callbackfn
	      /* , that = undefined */
	      ) {
	        var state = getInternalState(this);
	        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	        var entry;

	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

	          while (entry && entry.removed) {
	            entry = entry.previous;
	          }
	        }
	      },
	      // `{ Map, Set}.prototype.has(key)` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.has
	      // https://tc39.es/ecma262/#sec-set.prototype.has
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });
	    redefineAll(Prototype, IS_MAP ? {
	      // `Map.prototype.get(key)` method
	      // https://tc39.es/ecma262/#sec-map.prototype.get
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // `Map.prototype.set(key, value)` method
	      // https://tc39.es/ecma262/#sec-map.prototype.set
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // `Set.prototype.add(value)` method
	      // https://tc39.es/ecma262/#sec-set.prototype.add
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$5(Prototype, 'size', {
	      get: function get() {
	        return getInternalState(this).size;
	      }
	    });
	    return Constructor;
	  },
	  setStrong: function setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME); // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
	    // https://tc39.es/ecma262/#sec-map.prototype.entries
	    // https://tc39.es/ecma262/#sec-map.prototype.keys
	    // https://tc39.es/ecma262/#sec-map.prototype.values
	    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
	    // https://tc39.es/ecma262/#sec-set.prototype.entries
	    // https://tc39.es/ecma262/#sec-set.prototype.keys
	    // https://tc39.es/ecma262/#sec-set.prototype.values
	    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator

	    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$3(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last; // revert to the last existing entry

	      while (entry && entry.removed) {
	        entry = entry.previous;
	      } // get next entry


	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return {
	          value: undefined,
	          done: true
	        };
	      } // return step by kind


	      if (kind == 'keys') return {
	        value: entry.key,
	        done: false
	      };
	      if (kind == 'values') return {
	        value: entry.value,
	        done: false
	      };
	      return {
	        value: [entry.key, entry.value],
	        done: false
	      };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // `{ Map, Set }.prototype[@@species]` accessors
	    // https://tc39.es/ecma262/#sec-get-map-@@species
	    // https://tc39.es/ecma262/#sec-get-set-@@species

	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};
	collectionStrong.getConstructor;
	collectionStrong.setStrong;

	// `Map` constructor
	// https://tc39.es/ecma262/#sec-map-objects


	collection('Map', function (init) {
	  return function Map() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	}, collectionStrong);

	var log$7 = Math.log; // `Math.log1p` method implementation
	// https://tc39.es/ecma262/#sec-math.log1p
	// eslint-disable-next-line es/no-math-log1p -- safe

	var mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$7(1 + x);
	};

	// eslint-disable-next-line es/no-math-acosh -- required for testing


	var $acosh = Math.acosh;
	var log$6 = Math.log;
	var sqrt$2 = Math.sqrt;
	var LN2$1 = Math.LN2;
	var FORCED$g = !$acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	|| Math.floor($acosh(Number.MAX_VALUE)) != 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
	|| $acosh(Infinity) != Infinity; // `Math.acosh` method
	// https://tc39.es/ecma262/#sec-math.acosh

	_export({
	  target: 'Math',
	  stat: true,
	  forced: FORCED$g
	}, {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? log$6(x) + LN2$1 : mathLog1p(x - 1 + sqrt$2(x - 1) * sqrt$2(x + 1));
	  }
	});

	// eslint-disable-next-line es/no-math-asinh -- required for testing


	var $asinh = Math.asinh;
	var log$5 = Math.log;
	var sqrt$1 = Math.sqrt;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log$5(x + sqrt$1(x * x + 1));
	} // `Math.asinh` method
	// https://tc39.es/ecma262/#sec-math.asinh
	// Tor Browser bug: Math.asinh(0) -> -0


	_export({
	  target: 'Math',
	  stat: true,
	  forced: !($asinh && 1 / $asinh(0) > 0)
	}, {
	  asinh: asinh
	});

	// eslint-disable-next-line es/no-math-atanh -- required for testing


	var $atanh = Math.atanh;
	var log$4 = Math.log; // `Math.atanh` method
	// https://tc39.es/ecma262/#sec-math.atanh
	// Tor Browser bug: Math.atanh(-0) -> 0

	_export({
	  target: 'Math',
	  stat: true,
	  forced: !($atanh && 1 / $atanh(-0) < 0)
	}, {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : log$4((1 + x) / (1 - x)) / 2;
	  }
	});

	// `Math.sign` method implementation
	// https://tc39.es/ecma262/#sec-math.sign
	// eslint-disable-next-line es/no-math-sign -- safe
	var mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var abs$5 = Math.abs;
	var pow$2 = Math.pow; // `Math.cbrt` method
	// https://tc39.es/ecma262/#sec-math.cbrt

	_export({
	  target: 'Math',
	  stat: true
	}, {
	  cbrt: function cbrt(x) {
	    return mathSign(x = +x) * pow$2(abs$5(x), 1 / 3);
	  }
	});

	var floor$4 = Math.floor;
	var log$3 = Math.log;
	var LOG2E = Math.LOG2E; // `Math.clz32` method
	// https://tc39.es/ecma262/#sec-math.clz32

	_export({
	  target: 'Math',
	  stat: true
	}, {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - floor$4(log$3(x + 0.5) * LOG2E) : 32;
	  }
	});

	// eslint-disable-next-line es/no-math-expm1 -- safe
	var $expm1 = Math.expm1;
	var exp$2 = Math.exp; // `Math.expm1` method implementation
	// https://tc39.es/ecma262/#sec-math.expm1

	var mathExpm1 = !$expm1 // Old FF bug
	|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
	|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp$2(x) - 1;
	} : $expm1;

	// eslint-disable-next-line es/no-math-cosh -- required for testing


	var $cosh = Math.cosh;
	var abs$4 = Math.abs;
	var E$1 = Math.E; // `Math.cosh` method
	// https://tc39.es/ecma262/#sec-math.cosh

	_export({
	  target: 'Math',
	  stat: true,
	  forced: !$cosh || $cosh(710) === Infinity
	}, {
	  cosh: function cosh(x) {
	    var t = mathExpm1(abs$4(x) - 1) + 1;
	    return (t + 1 / (t * E$1 * E$1)) * (E$1 / 2);
	  }
	});

	// `Math.expm1` method
	// https://tc39.es/ecma262/#sec-math.expm1
	// eslint-disable-next-line es/no-math-expm1 -- required for testing


	_export({
	  target: 'Math',
	  stat: true,
	  forced: mathExpm1 != Math.expm1
	}, {
	  expm1: mathExpm1
	});

	var abs$3 = Math.abs;
	var pow$1 = Math.pow;
	var EPSILON = pow$1(2, -52);
	var EPSILON32 = pow$1(2, -23);
	var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$1(2, -126);

	var roundTiesToEven = function roundTiesToEven(n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	}; // `Math.fround` method implementation
	// https://tc39.es/ecma262/#sec-math.fround
	// eslint-disable-next-line es/no-math-fround -- safe


	var mathFround = Math.fround || function fround(x) {
	  var $abs = abs$3(x);
	  var $sign = mathSign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs); // eslint-disable-next-line no-self-compare -- NaN check

	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	// `Math.fround` method
	// https://tc39.es/ecma262/#sec-math.fround


	_export({
	  target: 'Math',
	  stat: true
	}, {
	  fround: mathFround
	});

	// eslint-disable-next-line es/no-math-hypot -- required for testing


	var $hypot = Math.hypot;
	var abs$2 = Math.abs;
	var sqrt = Math.sqrt; // Chrome 77 bug
	// https://bugs.chromium.org/p/v8/issues/detail?id=9546

	var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method
	// https://tc39.es/ecma262/#sec-math.hypot

	_export({
	  target: 'Math',
	  stat: true,
	  forced: BUGGY
	}, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  hypot: function hypot(value1, value2) {
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;

	    while (i < aLen) {
	      arg = abs$2(arguments[i++]);

	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }

	    return larg === Infinity ? Infinity : larg * sqrt(sum);
	  }
	});

	// eslint-disable-next-line es/no-math-imul -- required for testing


	var $imul = Math.imul;
	var FORCED$f = fails(function () {
	  return $imul(0xFFFFFFFF, 5) != -5 || $imul.length != 2;
	}); // `Math.imul` method
	// https://tc39.es/ecma262/#sec-math.imul
	// some WebKit versions fails with big numbers, some has wrong arity

	_export({
	  target: 'Math',
	  stat: true,
	  forced: FORCED$f
	}, {
	  imul: function imul(x, y) {
	    var UINT16 = 0xFFFF;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	var log$2 = Math.log;
	var LOG10E = Math.LOG10E; // eslint-disable-next-line es/no-math-log10 -- safe

	var mathLog10 = Math.log10 || function log10(x) {
	  return log$2(x) * LOG10E;
	};

	// `Math.log10` method
	// https://tc39.es/ecma262/#sec-math.log10


	_export({
	  target: 'Math',
	  stat: true
	}, {
	  log10: mathLog10
	});

	// `Math.log1p` method
	// https://tc39.es/ecma262/#sec-math.log1p


	_export({
	  target: 'Math',
	  stat: true
	}, {
	  log1p: mathLog1p
	});

	var log$1 = Math.log;
	var LN2 = Math.LN2; // `Math.log2` method
	// https://tc39.es/ecma262/#sec-math.log2

	_export({
	  target: 'Math',
	  stat: true
	}, {
	  log2: function log2(x) {
	    return log$1(x) / LN2;
	  }
	});

	// `Math.sign` method
	// https://tc39.es/ecma262/#sec-math.sign


	_export({
	  target: 'Math',
	  stat: true
	}, {
	  sign: mathSign
	});

	var abs$1 = Math.abs;
	var exp$1 = Math.exp;
	var E = Math.E;
	var FORCED$e = fails(function () {
	  // eslint-disable-next-line es/no-math-sinh -- required for testing
	  return Math.sinh(-2e-17) != -2e-17;
	}); // `Math.sinh` method
	// https://tc39.es/ecma262/#sec-math.sinh
	// V8 near Chromium 38 has a problem with very small numbers

	_export({
	  target: 'Math',
	  stat: true,
	  forced: FORCED$e
	}, {
	  sinh: function sinh(x) {
	    return abs$1(x = +x) < 1 ? (mathExpm1(x) - mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (E / 2);
	  }
	});

	var exp = Math.exp; // `Math.tanh` method
	// https://tc39.es/ecma262/#sec-math.tanh

	_export({
	  target: 'Math',
	  stat: true
	}, {
	  tanh: function tanh(x) {
	    var a = mathExpm1(x = +x);
	    var b = mathExpm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

	var ceil = Math.ceil;
	var floor$3 = Math.floor; // `Math.trunc` method
	// https://tc39.es/ecma262/#sec-math.trunc

	_export({
	  target: 'Math',
	  stat: true
	}, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$3 : ceil)(it);
	  }
	});

	// `Number.EPSILON` constant
	// https://tc39.es/ecma262/#sec-number.epsilon


	_export({
	  target: 'Number',
	  stat: true
	}, {
	  EPSILON: Math.pow(2, -52)
	});

	var globalIsFinite = global_1.isFinite; // `Number.isFinite` method
	// https://tc39.es/ecma262/#sec-number.isfinite
	// eslint-disable-next-line es/no-number-isfinite -- safe

	var numberIsFinite = Number.isFinite || function isFinite(it) {
	  return typeof it == 'number' && globalIsFinite(it);
	};

	// `Number.isFinite` method
	// https://tc39.es/ecma262/#sec-number.isfinite


	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isFinite: numberIsFinite
	});

	var floor$2 = Math.floor; // `IsIntegralNumber` abstract operation
	// https://tc39.es/ecma262/#sec-isintegralnumber
	// eslint-disable-next-line es/no-number-isinteger -- safe

	var isIntegralNumber = Number.isInteger || function isInteger(it) {
	  return !isObject$1(it) && isFinite(it) && floor$2(it) === it;
	};

	// `Number.isInteger` method
	// https://tc39.es/ecma262/#sec-number.isinteger


	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isInteger: isIntegralNumber
	});

	// `Number.isNaN` method
	// https://tc39.es/ecma262/#sec-number.isnan


	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare -- NaN check
	    return number != number;
	  }
	});

	var abs = Math.abs; // `Number.isSafeInteger` method
	// https://tc39.es/ecma262/#sec-number.issafeinteger

	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isSafeInteger: function isSafeInteger(number) {
	    return isIntegralNumber(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
	  }
	});

	// `Number.MAX_SAFE_INTEGER` constant
	// https://tc39.es/ecma262/#sec-number.max_safe_integer


	_export({
	  target: 'Number',
	  stat: true
	}, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	// `Number.MIN_SAFE_INTEGER` constant
	// https://tc39.es/ecma262/#sec-number.min_safe_integer


	_export({
	  target: 'Number',
	  stat: true
	}, {
	  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
	});

	var trim$1 = stringTrim.trim;



	var charAt$5 = functionUncurryThis(''.charAt);
	var n$ParseFloat = global_1.parseFloat;
	var _Symbol = global_1.Symbol;
	var ITERATOR$1 = _Symbol && _Symbol.iterator;
	var FORCED$d = 1 / n$ParseFloat(whitespaces + '-0') !== -Infinity // MS Edge 18- broken with boxed symbols
	|| ITERATOR$1 && !fails(function () {
	  n$ParseFloat(Object(ITERATOR$1));
	}); // `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string

	var numberParseFloat = FORCED$d ? function parseFloat(string) {
	  var trimmedString = trim$1(toString_1(string));
	  var result = n$ParseFloat(trimmedString);
	  return result === 0 && charAt$5(trimmedString, 0) == '-' ? -0 : result;
	} : n$ParseFloat;

	// `Number.parseFloat` method
	// https://tc39.es/ecma262/#sec-number.parseFloat
	// eslint-disable-next-line es/no-number-parsefloat -- required for testing


	_export({
	  target: 'Number',
	  stat: true,
	  forced: Number.parseFloat != numberParseFloat
	}, {
	  parseFloat: numberParseFloat
	});

	// `Number.parseInt` method
	// https://tc39.es/ecma262/#sec-number.parseint
	// eslint-disable-next-line es/no-number-parseint -- required for testing


	_export({
	  target: 'Number',
	  stat: true,
	  forced: Number.parseInt != numberParseInt
	}, {
	  parseInt: numberParseInt
	});

	var RangeError$4 = global_1.RangeError;
	var String$2 = global_1.String;
	var floor$1 = Math.floor;
	var repeat = functionUncurryThis(stringRepeat);
	var stringSlice$4 = functionUncurryThis(''.slice);
	var un$ToFixed = functionUncurryThis(1.0.toFixed);

	var pow = function pow(x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};

	var log = function log(x) {
	  var n = 0;
	  var x2 = x;

	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }

	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  }

	  return n;
	};

	var multiply = function multiply(data, n, c) {
	  var index = -1;
	  var c2 = c;

	  while (++index < 6) {
	    c2 += n * data[index];
	    data[index] = c2 % 1e7;
	    c2 = floor$1(c2 / 1e7);
	  }
	};

	var divide = function divide(data, n) {
	  var index = 6;
	  var c = 0;

	  while (--index >= 0) {
	    c += data[index];
	    data[index] = floor$1(c / n);
	    c = c % n * 1e7;
	  }
	};

	var dataToString = function dataToString(data) {
	  var index = 6;
	  var s = '';

	  while (--index >= 0) {
	    if (s !== '' || index === 0 || data[index] !== 0) {
	      var t = String$2(data[index]);
	      s = s === '' ? t : s + repeat('0', 7 - t.length) + t;
	    }
	  }

	  return s;
	};

	var FORCED$c = fails(function () {
	  return un$ToFixed(0.00008, 3) !== '0.000' || un$ToFixed(0.9, 0) !== '1' || un$ToFixed(1.255, 2) !== '1.25' || un$ToFixed(1000000000000000128.0, 0) !== '1000000000000000128';
	}) || !fails(function () {
	  // V8 ~ Android 4.3-
	  un$ToFixed({});
	}); // `Number.prototype.toFixed` method
	// https://tc39.es/ecma262/#sec-number.prototype.tofixed

	_export({
	  target: 'Number',
	  proto: true,
	  forced: FORCED$c
	}, {
	  toFixed: function toFixed(fractionDigits) {
	    var number = thisNumberValue(this);
	    var fractDigits = toIntegerOrInfinity(fractionDigits);
	    var data = [0, 0, 0, 0, 0, 0];
	    var sign = '';
	    var result = '0';
	    var e, z, j, k; // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation

	    if (fractDigits < 0 || fractDigits > 20) throw RangeError$4('Incorrect fraction digits'); // eslint-disable-next-line no-self-compare -- NaN check

	    if (number != number) return 'NaN';
	    if (number <= -1e21 || number >= 1e21) return String$2(number);

	    if (number < 0) {
	      sign = '-';
	      number = -number;
	    }

	    if (number > 1e-21) {
	      e = log(number * pow(2, 69, 1)) - 69;
	      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;

	      if (e > 0) {
	        multiply(data, 0, z);
	        j = fractDigits;

	        while (j >= 7) {
	          multiply(data, 1e7, 0);
	          j -= 7;
	        }

	        multiply(data, pow(10, j, 1), 0);
	        j = e - 1;

	        while (j >= 23) {
	          divide(data, 1 << 23);
	          j -= 23;
	        }

	        divide(data, 1 << j);
	        multiply(data, 1, 1);
	        divide(data, 2);
	        result = dataToString(data);
	      } else {
	        multiply(data, 0, z);
	        multiply(data, 1 << -e, 0);
	        result = dataToString(data) + repeat('0', fractDigits);
	      }
	    }

	    if (fractDigits > 0) {
	      k = result.length;
	      result = sign + (k <= fractDigits ? '0.' + repeat('0', fractDigits - k) + result : stringSlice$4(result, 0, k - fractDigits) + '.' + stringSlice$4(result, k - fractDigits));
	    } else {
	      result = sign + result;
	    }

	    return result;
	  }
	});

	var un$ToPrecision = functionUncurryThis(1.0.toPrecision);
	var FORCED$b = fails(function () {
	  // IE7-
	  return un$ToPrecision(1, undefined) !== '1';
	}) || !fails(function () {
	  // V8 ~ Android 4.3-
	  un$ToPrecision({});
	}); // `Number.prototype.toPrecision` method
	// https://tc39.es/ecma262/#sec-number.prototype.toprecision

	_export({
	  target: 'Number',
	  proto: true,
	  forced: FORCED$b
	}, {
	  toPrecision: function toPrecision(precision) {
	    return precision === undefined ? un$ToPrecision(thisNumberValue(this)) : un$ToPrecision(thisNumberValue(this), precision);
	  }
	});

	// `Object.assign` method
	// https://tc39.es/ecma262/#sec-object.assign
	// eslint-disable-next-line es/no-object-assign -- required for testing


	_export({
	  target: 'Object',
	  stat: true,
	  forced: Object.assign !== objectAssign
	}, {
	  assign: objectAssign
	});

	// Forced replacement object prototype accessors methods


	var objectPrototypeAccessorsForced = !fails(function () {
	  // This feature detection crashes old WebKit
	  // https://github.com/zloirock/core-js/issues/232
	  if (engineWebkitVersion && engineWebkitVersion < 535) return;
	  var key = Math.random(); // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call -- required for testing

	  __defineSetter__.call(null, key, function () {
	    /* empty */
	  });

	  delete global_1[key];
	});

	// `Object.prototype.__defineGetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__defineGetter__


	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __defineGetter__: function __defineGetter__(P, getter) {
	      objectDefineProperty.f(toObject(this), P, {
	        get: aCallable(getter),
	        enumerable: true,
	        configurable: true
	      });
	    }
	  });
	}

	var defineProperties$1 = objectDefineProperties.f; // `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es/no-object-defineproperties -- safe


	_export({
	  target: 'Object',
	  stat: true,
	  forced: Object.defineProperties !== defineProperties$1,
	  sham: !descriptors
	}, {
	  defineProperties: defineProperties$1
	});

	// `Object.prototype.__defineSetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__defineSetter__


	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __defineSetter__: function __defineSetter__(P, setter) {
	      objectDefineProperty.f(toObject(this), P, {
	        set: aCallable(setter),
	        enumerable: true,
	        configurable: true
	      });
	    }
	  });
	}

	var $propertyIsEnumerable = objectPropertyIsEnumerable.f;

	var propertyIsEnumerable = functionUncurryThis($propertyIsEnumerable);
	var push$2 = functionUncurryThis([].push); // `Object.{ entries, values }` methods implementation

	var createMethod = function createMethod(TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;

	    while (length > i) {
	      key = keys[i++];

	      if (!descriptors || propertyIsEnumerable(O, key)) {
	        push$2(result, TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }

	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.es/ecma262/#sec-object.entries
	  entries: createMethod(true),
	  // `Object.values` method
	  // https://tc39.es/ecma262/#sec-object.values
	  values: createMethod(false)
	};

	var $entries = objectToArray.entries; // `Object.entries` method
	// https://tc39.es/ecma262/#sec-object.entries


	_export({
	  target: 'Object',
	  stat: true
	}, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var onFreeze$2 = internalMetadata.onFreeze; // eslint-disable-next-line es/no-object-freeze -- safe


	var $freeze = Object.freeze;
	var FAILS_ON_PRIMITIVES$6 = fails(function () {
	  $freeze(1);
	}); // `Object.freeze` method
	// https://tc39.es/ecma262/#sec-object.freeze

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$6,
	  sham: !freezing
	}, {
	  freeze: function freeze(it) {
	    return $freeze && isObject$1(it) ? $freeze(onFreeze$2(it)) : it;
	  }
	});

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries


	_export({
	  target: 'Object',
	  stat: true
	}, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, {
	      AS_ENTRIES: true
	    });
	    return obj;
	  }
	});

	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;



	var FAILS_ON_PRIMITIVES$5 = fails(function () {
	  nativeGetOwnPropertyDescriptor(1);
	});
	var FORCED$a = !descriptors || FAILS_ON_PRIMITIVES$5; // `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FORCED$a,
	  sham: !descriptors
	}, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
	  }
	});

	// `Object.getOwnPropertyDescriptors` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors


	_export({
	  target: 'Object',
	  stat: true,
	  sham: !descriptors
	}, {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIndexedObject(object);
	    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var index = 0;
	    var key, descriptor;

	    while (keys.length > index) {
	      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
	      if (descriptor !== undefined) createProperty(result, key, descriptor);
	    }

	    return result;
	  }
	});

	// `SameValue` abstract operation
	// https://tc39.es/ecma262/#sec-samevalue
	// eslint-disable-next-line es/no-object-is -- safe
	var sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// `Object.is` method
	// https://tc39.es/ecma262/#sec-object.is


	_export({
	  target: 'Object',
	  stat: true
	}, {
	  is: sameValue
	});

	// `Object.isExtensible` method
	// https://tc39.es/ecma262/#sec-object.isextensible
	// eslint-disable-next-line es/no-object-isextensible -- safe


	_export({
	  target: 'Object',
	  stat: true,
	  forced: Object.isExtensible !== objectIsExtensible
	}, {
	  isExtensible: objectIsExtensible
	});

	// eslint-disable-next-line es/no-object-isfrozen -- safe


	var $isFrozen = Object.isFrozen;
	var FAILS_ON_PRIMITIVES$4 = fails(function () {
	  $isFrozen(1);
	}); // `Object.isFrozen` method
	// https://tc39.es/ecma262/#sec-object.isfrozen

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$4 || arrayBufferNonExtensible
	}, {
	  isFrozen: function isFrozen(it) {
	    if (!isObject$1(it)) return true;
	    if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return true;
	    return $isFrozen ? $isFrozen(it) : false;
	  }
	});

	// eslint-disable-next-line es/no-object-issealed -- safe


	var $isSealed = Object.isSealed;
	var FAILS_ON_PRIMITIVES$3 = fails(function () {
	  $isSealed(1);
	}); // `Object.isSealed` method
	// https://tc39.es/ecma262/#sec-object.issealed

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$3 || arrayBufferNonExtensible
	}, {
	  isSealed: function isSealed(it) {
	    if (!isObject$1(it)) return true;
	    if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return true;
	    return $isSealed ? $isSealed(it) : false;
	  }
	});

	var FAILS_ON_PRIMITIVES$2 = fails(function () {
	  objectKeys(1);
	}); // `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$2
	}, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f; // `Object.prototype.__lookupGetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__lookupGetter__


	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __lookupGetter__: function __lookupGetter__(P) {
	      var O = toObject(this);
	      var key = toPropertyKey(P);
	      var desc;

	      do {
	        if (desc = getOwnPropertyDescriptor$5(O, key)) return desc.get;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f; // `Object.prototype.__lookupSetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__lookupSetter__


	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __lookupSetter__: function __lookupSetter__(P) {
	      var O = toObject(this);
	      var key = toPropertyKey(P);
	      var desc;

	      do {
	        if (desc = getOwnPropertyDescriptor$4(O, key)) return desc.set;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var onFreeze$1 = internalMetadata.onFreeze;



	 // eslint-disable-next-line es/no-object-preventextensions -- safe


	var $preventExtensions = Object.preventExtensions;
	var FAILS_ON_PRIMITIVES$1 = fails(function () {
	  $preventExtensions(1);
	}); // `Object.preventExtensions` method
	// https://tc39.es/ecma262/#sec-object.preventextensions

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$1,
	  sham: !freezing
	}, {
	  preventExtensions: function preventExtensions(it) {
	    return $preventExtensions && isObject$1(it) ? $preventExtensions(onFreeze$1(it)) : it;
	  }
	});

	var onFreeze = internalMetadata.onFreeze;



	 // eslint-disable-next-line es/no-object-seal -- safe


	var $seal = Object.seal;
	var FAILS_ON_PRIMITIVES = fails(function () {
	  $seal(1);
	}); // `Object.seal` method
	// https://tc39.es/ecma262/#sec-object.seal

	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES,
	  sham: !freezing
	}, {
	  seal: function seal(it) {
	    return $seal && isObject$1(it) ? $seal(onFreeze(it)) : it;
	  }
	});

	var $values = objectToArray.values; // `Object.values` method
	// https://tc39.es/ecma262/#sec-object.values


	_export({
	  target: 'Object',
	  stat: true
	}, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string


	_export({
	  global: true,
	  forced: parseFloat != numberParseFloat
	}, {
	  parseFloat: numberParseFloat
	});

	var nativePromiseConstructor = global_1.Promise;

	var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent);

	var set$1 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$4 = global_1.process;
	var Dispatch = global_1.Dispatch;
	var Function$1 = global_1.Function;
	var MessageChannel = global_1.MessageChannel;
	var String$1 = global_1.String;
	var counter = 0;
	var queue$1 = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var location$1, defer, channel, port;

	try {
	  // Deno throws a ReferenceError on `location` access without `--location` flag
	  location$1 = global_1.location;
	} catch (error) {
	  /* empty */
	}

	var run = function run(id) {
	  if (hasOwnProperty_1(queue$1, id)) {
	    var fn = queue$1[id];
	    delete queue$1[id];
	    fn();
	  }
	};

	var runner = function runner(id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function listener(event) {
	  run(event.data);
	};

	var post = function post(id) {
	  // old engines have not location.origin
	  global_1.postMessage(String$1(id), location$1.protocol + '//' + location$1.host);
	}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


	if (!set$1 || !clear) {
	  set$1 = function setImmediate(handler) {
	    validateArgumentsLength(arguments.length, 1);
	    var fn = isCallable(handler) ? handler : Function$1(handler);
	    var args = arraySlice$1(arguments, 1);

	    queue$1[++counter] = function () {
	      functionApply(fn, undefined, args);
	    };

	    defer(counter);
	    return counter;
	  };

	  clear = function clearImmediate(id) {
	    delete queue$1[id];
	  }; // Node.js 0.8-


	  if (engineIsNode) {
	    defer = function defer(id) {
	      process$4.nextTick(runner(id));
	    }; // Sphere (JS game engine) Dispatch API

	  } else if (Dispatch && Dispatch.now) {
	    defer = function defer(id) {
	      Dispatch.now(runner(id));
	    }; // Browsers with MessageChannel, includes WebWorkers
	    // except iOS - https://github.com/zloirock/core-js/issues/624

	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port); // Browsers with postMessage, skip WebWorkers
	    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global_1.addEventListener && isCallable(global_1.postMessage) && !global_1.importScripts && location$1 && location$1.protocol !== 'file:' && !fails(post)) {
	    defer = post;
	    global_1.addEventListener('message', listener, false); // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function defer(id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    }; // Rest old browsers

	  } else {
	    defer = function defer(id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task$1 = {
	  set: set$1,
	  clear: clear
	};

	var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent) && global_1.Pebble !== undefined;

	var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

	var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task$1.set;









	var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var document$2 = global_1.document;
	var process$3 = global_1.process;
	var Promise$1 = global_1.Promise; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
	var flush, head, last, notify$1, toggle, node, promise, then; // modern engines have queueMicrotask method

	if (!queueMicrotask) {
	  flush = function flush() {
	    var parent, fn;
	    if (engineIsNode && (parent = process$3.domain)) parent.exit();

	    while (head) {
	      fn = head.fn;
	      head = head.next;

	      try {
	        fn();
	      } catch (error) {
	        if (head) notify$1();else last = undefined;
	        throw error;
	      }
	    }

	    last = undefined;
	    if (parent) parent.enter();
	  }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898


	  if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver$1 && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver$1(flush).observe(node, {
	      characterData: true
	    });

	    notify$1 = function notify() {
	      node.data = toggle = !toggle;
	    }; // environments with maybe non-completely correct, but existent Promise

	  } else if (!engineIsIosPebble && Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$1.resolve(undefined); // workaround of WebKit ~ iOS Safari 10.1 bug

	    promise.constructor = Promise$1;
	    then = functionBindContext(promise.then, promise);

	    notify$1 = function notify() {
	      then(flush);
	    }; // Node.js without promises

	  } else if (engineIsNode) {
	    notify$1 = function notify() {
	      process$3.nextTick(flush);
	    }; // for other environments - macrotask based on:
	    // - setImmediate
	    // - MessageChannel
	    // - window.postMessag
	    // - onreadystatechange
	    // - setTimeout

	  } else {
	    // strange IE + webpack dev server bug - use .bind(global)
	    macrotask = functionBindContext(macrotask, global_1);

	    notify$1 = function notify() {
	      macrotask(flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = {
	    fn: fn,
	    next: undefined
	  };
	  if (last) last.next = task;

	  if (!head) {
	    head = task;
	    notify$1();
	  }

	  last = task;
	};

	var PromiseCapability = function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aCallable(resolve);
	  this.reject = aCallable(reject);
	}; // `NewPromiseCapability` abstract operation
	// https://tc39.es/ecma262/#sec-newpromisecapability


	var f = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability$1 = {
		f: f
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject$1(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability$1.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;

	  if (console && console.error) {
	    arguments.length == 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return {
	      error: false,
	      value: exec()
	    };
	  } catch (error) {
	    return {
	      error: true,
	      value: error
	    };
	  }
	};

	var Queue = function Queue() {
	  this.head = null;
	  this.tail = null;
	};

	Queue.prototype = {
	  add: function add(item) {
	    var entry = {
	      item: item,
	      next: null
	    };
	    if (this.head) this.tail.next = entry;else this.head = entry;
	    this.tail = entry;
	  },
	  get: function get() {
	    var entry = this.head;

	    if (entry) {
	      this.head = entry.next;
	      if (this.tail === entry) this.tail = null;
	      return entry.item;
	    }
	  }
	};
	var queue = Queue;

	var _typeof$1 = require$$0["typeof"];

	var engineIsBrowser = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) == 'object';

	var task = task$1.set;

























	var SPECIES = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$3 = internalState.getterFor(PROMISE);
	var setInternalState$2 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var NativePromisePrototype = nativePromiseConstructor && nativePromiseConstructor.prototype;
	var PromiseConstructor = nativePromiseConstructor;
	var PromisePrototype = NativePromisePrototype;
	var TypeError$4 = global_1.TypeError;
	var document$1 = global_1.document;
	var process$2 = global_1.process;
	var newPromiseCapability = newPromiseCapability$1.f;
	var newGenericPromiseCapability = newPromiseCapability;
	var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global_1.dispatchEvent);
	var NATIVE_REJECTION_EVENT = isCallable(global_1.PromiseRejectionEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var SUBCLASSING = false;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
	var FORCED$9 = isForced_1(PROMISE, function () {
	  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
	  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor); // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	  // We can't detect it synchronously, so just check versions

	  if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66) return true; // We need Promise#finally in the pure version for preventing prototype pollution
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679

	  if (engineV8Version >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false; // Detect correctness of subclassing with @@species support

	  var promise = new PromiseConstructor(function (resolve) {
	    resolve(1);
	  });

	  var FakePromise = function FakePromise(exec) {
	    exec(function () {
	      /* empty */
	    }, function () {
	      /* empty */
	    });
	  };

	  var constructor = promise.constructor = {};
	  constructor[SPECIES] = FakePromise;
	  SUBCLASSING = promise.then(function () {
	    /* empty */
	  }) instanceof FakePromise;
	  if (!SUBCLASSING) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

	  return !GLOBAL_CORE_JS_PROMISE && engineIsBrowser && !NATIVE_REJECTION_EVENT;
	});
	var INCORRECT_ITERATION = FORCED$9 || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () {
	    /* empty */
	  });
	}); // helpers

	var isThenable = function isThenable(it) {
	  var then;
	  return isObject$1(it) && isCallable(then = it.then) ? then : false;
	};

	var callReaction = function callReaction(reaction, state) {
	  var value = state.value;
	  var ok = state.state == FULFILLED;
	  var handler = ok ? reaction.ok : reaction.fail;
	  var resolve = reaction.resolve;
	  var reject = reaction.reject;
	  var domain = reaction.domain;
	  var result, then, exited;

	  try {
	    if (handler) {
	      if (!ok) {
	        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
	        state.rejection = HANDLED;
	      }

	      if (handler === true) result = value;else {
	        if (domain) domain.enter();
	        result = handler(value); // can throw

	        if (domain) {
	          domain.exit();
	          exited = true;
	        }
	      }

	      if (result === reaction.promise) {
	        reject(TypeError$4('Promise-chain cycle'));
	      } else if (then = isThenable(result)) {
	        functionCall(then, result, resolve, reject);
	      } else resolve(result);
	    } else reject(value);
	  } catch (error) {
	    if (domain && !exited) domain.exit();
	    reject(error);
	  }
	};

	var notify = function notify(state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  microtask(function () {
	    var reactions = state.reactions;
	    var reaction;

	    while (reaction = reactions.get()) {
	      callReaction(reaction, state);
	    }

	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(state);
	  });
	};

	var dispatchEvent = function dispatchEvent(name, promise, reason) {
	  var event, handler;

	  if (DISPATCH_EVENT) {
	    event = document$1.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = {
	    promise: promise,
	    reason: reason
	  };

	  if (!NATIVE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function onUnhandled(state) {
	  functionCall(task, global_1, function () {
	    var promise = state.facade;
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;

	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (engineIsNode) {
	          process$2.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

	      state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function isUnhandled(state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function onHandleUnhandled(state) {
	  functionCall(task, global_1, function () {
	    var promise = state.facade;

	    if (engineIsNode) {
	      process$2.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind$1 = function bind(fn, state, unwrap) {
	  return function (value) {
	    fn(state, value, unwrap);
	  };
	};

	var internalReject = function internalReject(state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify(state, true);
	};

	var internalResolve = function internalResolve(state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;

	  try {
	    if (state.facade === value) throw TypeError$4("Promise can't be resolved itself");
	    var then = isThenable(value);

	    if (then) {
	      microtask(function () {
	        var wrapper = {
	          done: false
	        };

	        try {
	          functionCall(then, value, bind$1(internalResolve, wrapper, state), bind$1(internalReject, wrapper, state));
	        } catch (error) {
	          internalReject(wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify(state, false);
	    }
	  } catch (error) {
	    internalReject({
	      done: false
	    }, error, state);
	  }
	}; // constructor polyfill


	if (FORCED$9) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromisePrototype);
	    aCallable(executor);
	    functionCall(Internal, this);
	    var state = getInternalState$3(this);

	    try {
	      executor(bind$1(internalResolve, state), bind$1(internalReject, state));
	    } catch (error) {
	      internalReject(state, error);
	    }
	  };

	  PromisePrototype = PromiseConstructor.prototype; // eslint-disable-next-line no-unused-vars -- required for `.length`

	  Internal = function Promise(executor) {
	    setInternalState$2(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: new queue(),
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };

	  Internal.prototype = redefineAll(PromisePrototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.es/ecma262/#sec-promise.prototype.then
	    // eslint-disable-next-line unicorn/no-thenable -- safe
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
	      state.parent = true;
	      reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
	      reaction.fail = isCallable(onRejected) && onRejected;
	      reaction.domain = engineIsNode ? process$2.domain : undefined;
	      if (state.state == PENDING) state.reactions.add(reaction);else microtask(function () {
	        callReaction(reaction, state);
	      });
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.es/ecma262/#sec-promise.prototype.catch
	    'catch': function _catch(onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });

	  OwnPromiseCapability = function OwnPromiseCapability() {
	    var promise = new Internal();
	    var state = getInternalState$3(promise);
	    this.promise = promise;
	    this.resolve = bind$1(internalResolve, state);
	    this.reject = bind$1(internalReject, state);
	  };

	  newPromiseCapability$1.f = newPromiseCapability = function newPromiseCapability(C) {
	    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
	  };

	  if (isCallable(nativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
	    nativeThen = NativePromisePrototype.then;

	    if (!SUBCLASSING) {
	      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
	      redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
	        var that = this;
	        return new PromiseConstructor(function (resolve, reject) {
	          functionCall(nativeThen, that, resolve, reject);
	        }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
	      }, {
	        unsafe: true
	      }); // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`

	      redefine(NativePromisePrototype, 'catch', PromisePrototype['catch'], {
	        unsafe: true
	      });
	    } // make `.constructor === Promise` work for native promise-based APIs


	    try {
	      delete NativePromisePrototype.constructor;
	    } catch (error) {
	      /* empty */
	    } // make `instanceof Promise` work for native promise-based APIs


	    if (objectSetPrototypeOf) {
	      objectSetPrototypeOf(NativePromisePrototype, PromisePrototype);
	    }
	  }
	}

	_export({
	  global: true,
	  wrap: true,
	  forced: FORCED$9
	}, {
	  Promise: PromiseConstructor
	});
	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);
	PromiseWrapper = getBuiltIn(PROMISE); // statics

	_export({
	  target: PROMISE,
	  stat: true,
	  forced: FORCED$9
	}, {
	  // `Promise.reject` method
	  // https://tc39.es/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    functionCall(capability.reject, undefined, r);
	    return capability.promise;
	  }
	});
	_export({
	  target: PROMISE,
	  stat: true,
	  forced: FORCED$9
	}, {
	  // `Promise.resolve` method
	  // https://tc39.es/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve(this, x);
	  }
	});
	_export({
	  target: PROMISE,
	  stat: true,
	  forced: INCORRECT_ITERATION
	}, {
	  // `Promise.all` method
	  // https://tc39.es/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aCallable(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        remaining++;
	        functionCall($promiseResolve, C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.es/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aCallable(C.resolve);
	      iterate(iterable, function (promise) {
	        functionCall($promiseResolve, C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829


	var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
	  // eslint-disable-next-line unicorn/no-thenable -- required for testing
	  nativePromiseConstructor.prototype['finally'].call({
	    then: function then() {
	      /* empty */
	    }
	  }, function () {
	    /* empty */
	  });
	}); // `Promise.prototype.finally` method
	// https://tc39.es/ecma262/#sec-promise.prototype.finally

	_export({
	  target: 'Promise',
	  proto: true,
	  real: true,
	  forced: NON_GENERIC
	}, {
	  'finally': function _finally(onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = isCallable(onFinally);
	    return this.then(isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () {
	        return x;
	      });
	    } : onFinally, isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () {
	        throw e;
	      });
	    } : onFinally);
	  }
	}); // makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`

	if (isCallable(nativePromiseConstructor)) {
	  var method = getBuiltIn('Promise').prototype['finally'];

	  if (nativePromiseConstructor.prototype['finally'] !== method) {
	    redefine(nativePromiseConstructor.prototype, 'finally', method, {
	      unsafe: true
	    });
	  }
	}

	// MS Edge argumentsList argument is optional


	var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
	  // eslint-disable-next-line es/no-reflect -- required for testing
	  Reflect.apply(function () {
	    /* empty */
	  });
	}); // `Reflect.apply` method
	// https://tc39.es/ecma262/#sec-reflect.apply

	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: OPTIONAL_ARGUMENTS_LIST
	}, {
	  apply: function apply(target, thisArgument, argumentsList) {
	    return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
	  }
	});

	var nativeConstruct = getBuiltIn('Reflect', 'construct');
	var ObjectPrototype = Object.prototype;
	var push$1 = [].push; // `Reflect.construct` method
	// https://tc39.es/ecma262/#sec-reflect.construct
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it

	var NEW_TARGET_BUG = fails(function () {
	  function F() {
	    /* empty */
	  }

	  return !(nativeConstruct(function () {
	    /* empty */
	  }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  nativeConstruct(function () {
	    /* empty */
	  });
	});
	var FORCED$8 = NEW_TARGET_BUG || ARGS_BUG;
	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: FORCED$8,
	  sham: FORCED$8
	}, {
	  construct: function construct(Target, args
	  /* , newTarget */
	  ) {
	    aConstructor(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0:
	          return new Target();

	        case 1:
	          return new Target(args[0]);

	        case 2:
	          return new Target(args[0], args[1]);

	        case 3:
	          return new Target(args[0], args[1], args[2]);

	        case 4:
	          return new Target(args[0], args[1], args[2], args[3]);
	      } // w/o altered newTarget, lot of arguments case


	      var $args = [null];
	      functionApply(push$1, $args, args);
	      return new (functionApply(functionBind, Target, $args))();
	    } // with altered newTarget, not support built-in constructors


	    var proto = newTarget.prototype;
	    var instance = objectCreate(isObject$1(proto) ? proto : ObjectPrototype);
	    var result = functionApply(Target, instance, args);
	    return isObject$1(result) ? result : instance;
	  }
	});

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false


	var ERROR_INSTEAD_OF_FALSE = fails(function () {
	  // eslint-disable-next-line es/no-reflect -- required for testing
	  Reflect.defineProperty(objectDefineProperty.f({}, 1, {
	    value: 1
	  }), 1, {
	    value: 2
	  });
	}); // `Reflect.defineProperty` method
	// https://tc39.es/ecma262/#sec-reflect.defineproperty

	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: ERROR_INSTEAD_OF_FALSE,
	  sham: !descriptors
	}, {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    var key = toPropertyKey(propertyKey);
	    anObject(attributes);

	    try {
	      objectDefineProperty.f(target, key, attributes);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f; // `Reflect.deleteProperty` method
	// https://tc39.es/ecma262/#sec-reflect.deleteproperty


	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var descriptor = getOwnPropertyDescriptor$2(anObject(target), propertyKey);
	    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
	  }
	});

	var isDataDescriptor = function (descriptor) {
	  return descriptor !== undefined && (hasOwnProperty_1(descriptor, 'value') || hasOwnProperty_1(descriptor, 'writable'));
	};

	// `Reflect.get` method
	// https://tc39.es/ecma262/#sec-reflect.get


	function get(target, propertyKey
	/* , receiver */
	) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var descriptor, prototype;
	  if (anObject(target) === receiver) return target[propertyKey];
	  descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey);
	  if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === undefined ? undefined : functionCall(descriptor.get, receiver);
	  if (isObject$1(prototype = objectGetPrototypeOf(target))) return get(prototype, propertyKey, receiver);
	}

	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  get: get
	});

	// `Reflect.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor


	_export({
	  target: 'Reflect',
	  stat: true,
	  sham: !descriptors
	}, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  }
	});

	// `Reflect.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-reflect.getprototypeof


	_export({
	  target: 'Reflect',
	  stat: true,
	  sham: !correctPrototypeGetter
	}, {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return objectGetPrototypeOf(anObject(target));
	  }
	});

	// `Reflect.has` method
	// https://tc39.es/ecma262/#sec-reflect.has


	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	// `Reflect.isExtensible` method
	// https://tc39.es/ecma262/#sec-reflect.isextensible


	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return objectIsExtensible(target);
	  }
	});

	// `Reflect.ownKeys` method
	// https://tc39.es/ecma262/#sec-reflect.ownkeys


	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  ownKeys: ownKeys
	});

	// `Reflect.preventExtensions` method
	// https://tc39.es/ecma262/#sec-reflect.preventextensions


	_export({
	  target: 'Reflect',
	  stat: true,
	  sham: !freezing
	}, {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);

	    try {
	      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
	      if (objectPreventExtensions) objectPreventExtensions(target);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	// `Reflect.set` method
	// https://tc39.es/ecma262/#sec-reflect.set


	function set(target, propertyKey, V
	/* , receiver */
	) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  var existingDescriptor, prototype, setter;

	  if (!ownDescriptor) {
	    if (isObject$1(prototype = objectGetPrototypeOf(target))) {
	      return set(prototype, propertyKey, V, receiver);
	    }

	    ownDescriptor = createPropertyDescriptor(0);
	  }

	  if (isDataDescriptor(ownDescriptor)) {
	    if (ownDescriptor.writable === false || !isObject$1(receiver)) return false;

	    if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
	    } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));
	  } else {
	    setter = ownDescriptor.set;
	    if (setter === undefined) return false;
	    functionCall(setter, receiver, V);
	  }

	  return true;
	} // MS Edge 17-18 Reflect.set allows setting the property to object
	// with non-writable property on the prototype


	var MS_EDGE_BUG = fails(function () {
	  var Constructor = function Constructor() {
	    /* empty */
	  };

	  var object = objectDefineProperty.f(new Constructor(), 'a', {
	    configurable: true
	  }); // eslint-disable-next-line es/no-reflect -- required for testing

	  return Reflect.set(Constructor.prototype, 'a', 1, object) !== false;
	});
	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: MS_EDGE_BUG
	}, {
	  set: set
	});

	// `Reflect.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-reflect.setprototypeof


	if (objectSetPrototypeOf) _export({
	  target: 'Reflect',
	  stat: true
	}, {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    anObject(target);
	    aPossiblePrototype(proto);

	    try {
	      objectSetPrototypeOf(target, proto);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	var defineProperty$4 = objectDefineProperty.f;

	var getOwnPropertyNames = objectGetOwnPropertyNames.f;

















	var enforceInternalState$1 = internalState.enforce;









	var MATCH$1 = wellKnownSymbol('match');
	var NativeRegExp = global_1.RegExp;
	var RegExpPrototype$3 = NativeRegExp.prototype;
	var SyntaxError = global_1.SyntaxError;
	var getFlags = functionUncurryThis(regexpFlags);
	var exec$3 = functionUncurryThis(RegExpPrototype$3.exec);
	var charAt$4 = functionUncurryThis(''.charAt);
	var replace$2 = functionUncurryThis(''.replace);
	var stringIndexOf$1 = functionUncurryThis(''.indexOf);
	var stringSlice$3 = functionUncurryThis(''.slice); // TODO: Use only propper RegExpIdentifierName

	var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
	var re1 = /a/g;
	var re2 = /a/g; // "new" should create a new object, old webkit bug

	var CORRECT_NEW = new NativeRegExp(re1) !== re1;
	var MISSED_STICKY$1 = regexpStickyHelpers.MISSED_STICKY;
	var UNSUPPORTED_Y = regexpStickyHelpers.UNSUPPORTED_Y;
	var BASE_FORCED = descriptors && (!CORRECT_NEW || MISSED_STICKY$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg || fails(function () {
	  re2[MATCH$1] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

	  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
	}));

	var handleDotAll = function handleDotAll(string) {
	  var length = string.length;
	  var index = 0;
	  var result = '';
	  var brackets = false;
	  var chr;

	  for (; index <= length; index++) {
	    chr = charAt$4(string, index);

	    if (chr === '\\') {
	      result += chr + charAt$4(string, ++index);
	      continue;
	    }

	    if (!brackets && chr === '.') {
	      result += '[\\s\\S]';
	    } else {
	      if (chr === '[') {
	        brackets = true;
	      } else if (chr === ']') {
	        brackets = false;
	      }

	      result += chr;
	    }
	  }

	  return result;
	};

	var handleNCG = function handleNCG(string) {
	  var length = string.length;
	  var index = 0;
	  var result = '';
	  var named = [];
	  var names = {};
	  var brackets = false;
	  var ncg = false;
	  var groupid = 0;
	  var groupname = '';
	  var chr;

	  for (; index <= length; index++) {
	    chr = charAt$4(string, index);

	    if (chr === '\\') {
	      chr = chr + charAt$4(string, ++index);
	    } else if (chr === ']') {
	      brackets = false;
	    } else if (!brackets) switch (true) {
	      case chr === '[':
	        brackets = true;
	        break;

	      case chr === '(':
	        if (exec$3(IS_NCG, stringSlice$3(string, index + 1))) {
	          index += 2;
	          ncg = true;
	        }

	        result += chr;
	        groupid++;
	        continue;

	      case chr === '>' && ncg:
	        if (groupname === '' || hasOwnProperty_1(names, groupname)) {
	          throw new SyntaxError('Invalid capture group name');
	        }

	        names[groupname] = true;
	        named[named.length] = [groupname, groupid];
	        ncg = false;
	        groupname = '';
	        continue;
	    }

	    if (ncg) groupname += chr;else result += chr;
	  }

	  return [result, named];
	}; // `RegExp` constructor
	// https://tc39.es/ecma262/#sec-regexp-constructor


	if (isForced_1('RegExp', BASE_FORCED)) {
	  var RegExpWrapper = function RegExp(pattern, flags) {
	    var thisIsRegExp = objectIsPrototypeOf(RegExpPrototype$3, this);
	    var patternIsRegExp = isRegexp(pattern);
	    var flagsAreUndefined = flags === undefined;
	    var groups = [];
	    var rawPattern = pattern;
	    var rawFlags, dotAll, sticky, handled, result, state;

	    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
	      return pattern;
	    }

	    if (patternIsRegExp || objectIsPrototypeOf(RegExpPrototype$3, pattern)) {
	      pattern = pattern.source;
	      if (flagsAreUndefined) flags = 'flags' in rawPattern ? rawPattern.flags : getFlags(rawPattern);
	    }

	    pattern = pattern === undefined ? '' : toString_1(pattern);
	    flags = flags === undefined ? '' : toString_1(flags);
	    rawPattern = pattern;

	    if (regexpUnsupportedDotAll && 'dotAll' in re1) {
	      dotAll = !!flags && stringIndexOf$1(flags, 's') > -1;
	      if (dotAll) flags = replace$2(flags, /s/g, '');
	    }

	    rawFlags = flags;

	    if (MISSED_STICKY$1 && 'sticky' in re1) {
	      sticky = !!flags && stringIndexOf$1(flags, 'y') > -1;
	      if (sticky && UNSUPPORTED_Y) flags = replace$2(flags, /y/g, '');
	    }

	    if (regexpUnsupportedNcg) {
	      handled = handleNCG(pattern);
	      pattern = handled[0];
	      groups = handled[1];
	    }

	    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$3, RegExpWrapper);

	    if (dotAll || sticky || groups.length) {
	      state = enforceInternalState$1(result);

	      if (dotAll) {
	        state.dotAll = true;
	        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
	      }

	      if (sticky) state.sticky = true;
	      if (groups.length) state.groups = groups;
	    }

	    if (pattern !== rawPattern) try {
	      // fails in old engines, but we have no alternatives for unsupported regex syntax
	      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
	    } catch (error) {
	      /* empty */
	    }
	    return result;
	  };

	  var proxy = function proxy(key) {
	    key in RegExpWrapper || defineProperty$4(RegExpWrapper, key, {
	      configurable: true,
	      get: function get() {
	        return NativeRegExp[key];
	      },
	      set: function set(it) {
	        NativeRegExp[key] = it;
	      }
	    });
	  };

	  for (var keys = getOwnPropertyNames(NativeRegExp), index$1 = 0; keys.length > index$1;) {
	    proxy(keys[index$1++]);
	  }

	  RegExpPrototype$3.constructor = RegExpWrapper;
	  RegExpWrapper.prototype = RegExpPrototype$3;
	  redefine(global_1, 'RegExp', RegExpWrapper);
	} // https://tc39.es/ecma262/#sec-get-regexp-@@species


	setSpecies('RegExp');

	var RegExpPrototype$2 = RegExp.prototype;
	var FORCED$7 = descriptors && fails(function () {
	  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	  return Object.getOwnPropertyDescriptor(RegExpPrototype$2, 'flags').get.call({
	    dotAll: true,
	    sticky: true
	  }) !== 'sy';
	}); // `RegExp.prototype.flags` getter
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags

	if (FORCED$7) objectDefineProperty.f(RegExpPrototype$2, 'flags', {
	  configurable: true,
	  get: regexpFlags
	});

	// `Set` constructor
	// https://tc39.es/ecma262/#sec-set-objects


	collection('Set', function (init) {
	  return function Set() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	}, collectionStrong);

	var codeAt = stringMultibyte.codeAt; // `String.prototype.codePointAt` method
	// https://tc39.es/ecma262/#sec-string.prototype.codepointat


	_export({
	  target: 'String',
	  proto: true
	}, {
	  codePointAt: function codePointAt(pos) {
	    return codeAt(this, pos);
	  }
	});

	var TypeError$3 = global_1.TypeError;

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError$3("The method doesn't accept regular expressions");
	  }

	  return it;
	};

	var MATCH = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;

	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (error1) {
	    try {
	      regexp[MATCH] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (error2) {
	      /* empty */
	    }
	  }

	  return false;
	};

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;











	 // eslint-disable-next-line es/no-string-prototype-endswith -- safe


	var un$EndsWith = functionUncurryThis(''.endsWith);
	var slice = functionUncurryThis(''.slice);
	var min$2 = Math.min;
	var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('endsWith'); // https://github.com/zloirock/core-js/pull/702

	var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
	  var descriptor = getOwnPropertyDescriptor$1(String.prototype, 'endsWith');
	  return descriptor && !descriptor.writable;
	}(); // `String.prototype.endsWith` method
	// https://tc39.es/ecma262/#sec-string.prototype.endswith

	_export({
	  target: 'String',
	  proto: true,
	  forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1
	}, {
	  endsWith: function endsWith(searchString
	  /* , endPosition = @length */
	  ) {
	    var that = toString_1(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = that.length;
	    var end = endPosition === undefined ? len : min$2(toLength(endPosition), len);
	    var search = toString_1(searchString);
	    return un$EndsWith ? un$EndsWith(that, search, end) : slice(that, end - search.length, end) === search;
	  }
	});

	var RangeError$3 = global_1.RangeError;
	var fromCharCode$1 = String.fromCharCode; // eslint-disable-next-line es/no-string-fromcodepoint -- required for testing

	var $fromCodePoint = String.fromCodePoint;
	var join$2 = functionUncurryThis([].join); // length should be 1, old FF problem

	var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length != 1; // `String.fromCodePoint` method
	// https://tc39.es/ecma262/#sec-string.fromcodepoint

	_export({
	  target: 'String',
	  stat: true,
	  forced: INCORRECT_LENGTH
	}, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  fromCodePoint: function fromCodePoint(x) {
	    var elements = [];
	    var length = arguments.length;
	    var i = 0;
	    var code;

	    while (length > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError$3(code + ' is not a valid code point');
	      elements[i] = code < 0x10000 ? fromCharCode$1(code) : fromCharCode$1(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00);
	    }

	    return join$2(elements, '');
	  }
	});

	var stringIndexOf = functionUncurryThis(''.indexOf); // `String.prototype.includes` method
	// https://tc39.es/ecma262/#sec-string.prototype.includes

	_export({
	  target: 'String',
	  proto: true,
	  forced: !correctIsRegexpLogic('includes')
	}, {
	  includes: function includes(searchString
	  /* , position = 0 */
	  ) {
	    return !!~stringIndexOf(toString_1(requireObjectCoercible(this)), toString_1(notARegexp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://github.com/zloirock/core-js/issues/280


	var stringPadWebkitBug = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(engineUserAgent);

	var $padEnd = stringPad.end;

	 // `String.prototype.padEnd` method
	// https://tc39.es/ecma262/#sec-string.prototype.padend


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringPadWebkitBug
	}, {
	  padEnd: function padEnd(maxLength
	  /* , fillString = ' ' */
	  ) {
	    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $padStart = stringPad.start;

	 // `String.prototype.padStart` method
	// https://tc39.es/ecma262/#sec-string.prototype.padstart


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringPadWebkitBug
	}, {
	  padStart: function padStart(maxLength
	  /* , fillString = ' ' */
	  ) {
	    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var push = functionUncurryThis([].push);
	var join$1 = functionUncurryThis([].join); // `String.raw` method
	// https://tc39.es/ecma262/#sec-string.raw

	_export({
	  target: 'String',
	  stat: true
	}, {
	  raw: function raw(template) {
	    var rawTemplate = toIndexedObject(toObject(template).raw);
	    var literalSegments = lengthOfArrayLike(rawTemplate);
	    var argumentsLength = arguments.length;
	    var elements = [];
	    var i = 0;

	    while (literalSegments > i) {
	      push(elements, toString_1(rawTemplate[i++]));
	      if (i === literalSegments) return join$1(elements, '');
	      if (i < argumentsLength) push(elements, toString_1(arguments[i]));
	    }
	  }
	});

	// `String.prototype.repeat` method
	// https://tc39.es/ecma262/#sec-string.prototype.repeat


	_export({
	  target: 'String',
	  proto: true
	}, {
	  repeat: stringRepeat
	});

	// @@search logic


	fixRegexpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
	  return [// `String.prototype.search` method
	  // https://tc39.es/ecma262/#sec-string.prototype.search
	  function search(regexp) {
	    var O = requireObjectCoercible(this);
	    var searcher = regexp == undefined ? undefined : getMethod(regexp, SEARCH);
	    return searcher ? functionCall(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString_1(O));
	  }, // `RegExp.prototype[@@search]` method
	  // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
	  function (string) {
	    var rx = anObject(this);
	    var S = toString_1(string);
	    var res = maybeCallNative(nativeSearch, rx, S);
	    if (res.done) return res.value;
	    var previousLastIndex = rx.lastIndex;
	    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	    var result = regexpExecAbstract(rx, S);
	    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	    return result === null ? -1 : result.index;
	  }];
	});

	var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;











	 // eslint-disable-next-line es/no-string-prototype-startswith -- safe


	var un$StartsWith = functionUncurryThis(''.startsWith);
	var stringSlice$2 = functionUncurryThis(''.slice);
	var min$1 = Math.min;
	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith'); // https://github.com/zloirock/core-js/pull/702

	var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}(); // `String.prototype.startsWith` method
	// https://tc39.es/ecma262/#sec-string.prototype.startswith

	_export({
	  target: 'String',
	  proto: true,
	  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
	}, {
	  startsWith: function startsWith(searchString
	  /* , position = 0 */
	  ) {
	    var that = toString_1(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$1(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = toString_1(searchString);
	    return un$StartsWith ? un$StartsWith(that, search, index) : stringSlice$2(that, index, index + search.length) === search;
	  }
	});

	var PROPER_FUNCTION_NAME = functionName.PROPER;





	var non = "\u200B\x85\u180E"; // check that a method works with the correct list
	// of whitespaces and has a correct name

	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;

	 // `String.prototype.trim` method
	// https://tc39.es/ecma262/#sec-string.prototype.trim


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringTrimForced('trim')
	}, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var $trimEnd = stringTrim.end;



	var FORCED$6 = stringTrimForced('trimEnd');
	var trimEnd = FORCED$6 ? function trimEnd() {
	  return $trimEnd(this); // eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
	} : ''.trimEnd; // `String.prototype.{ trimEnd, trimRight }` methods
	// https://tc39.es/ecma262/#sec-string.prototype.trimend
	// https://tc39.es/ecma262/#String.prototype.trimright

	_export({
	  target: 'String',
	  proto: true,
	  name: 'trimEnd',
	  forced: FORCED$6
	}, {
	  trimEnd: trimEnd,
	  trimRight: trimEnd
	});

	var $trimStart = stringTrim.start;



	var FORCED$5 = stringTrimForced('trimStart');
	var trimStart = FORCED$5 ? function trimStart() {
	  return $trimStart(this); // eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
	} : ''.trimStart; // `String.prototype.{ trimStart, trimLeft }` methods
	// https://tc39.es/ecma262/#sec-string.prototype.trimstart
	// https://tc39.es/ecma262/#String.prototype.trimleft

	_export({
	  target: 'String',
	  proto: true,
	  name: 'trimStart',
	  forced: FORCED$5
	}, {
	  trimStart: trimStart,
	  trimLeft: trimStart
	});

	var quot = /"/g;
	var replace$1 = functionUncurryThis(''.replace); // `CreateHTML` abstract operation
	// https://tc39.es/ecma262/#sec-createhtml

	var createHtml = function (string, tag, attribute, value) {
	  var S = toString_1(requireObjectCoercible(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + replace$1(toString_1(value), quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};

	// check the existence of a method, lowercase
	// of a tag and escaping quotes in arguments


	var stringHtmlForced = function (METHOD_NAME) {
	  return fails(function () {
	    var test = ''[METHOD_NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  });
	};

	// `String.prototype.anchor` method
	// https://tc39.es/ecma262/#sec-string.prototype.anchor


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('anchor')
	}, {
	  anchor: function anchor(name) {
	    return createHtml(this, 'a', 'name', name);
	  }
	});

	// `String.prototype.big` method
	// https://tc39.es/ecma262/#sec-string.prototype.big


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('big')
	}, {
	  big: function big() {
	    return createHtml(this, 'big', '', '');
	  }
	});

	// `String.prototype.blink` method
	// https://tc39.es/ecma262/#sec-string.prototype.blink


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('blink')
	}, {
	  blink: function blink() {
	    return createHtml(this, 'blink', '', '');
	  }
	});

	// `String.prototype.bold` method
	// https://tc39.es/ecma262/#sec-string.prototype.bold


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('bold')
	}, {
	  bold: function bold() {
	    return createHtml(this, 'b', '', '');
	  }
	});

	// `String.prototype.fixed` method
	// https://tc39.es/ecma262/#sec-string.prototype.fixed


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('fixed')
	}, {
	  fixed: function fixed() {
	    return createHtml(this, 'tt', '', '');
	  }
	});

	// `String.prototype.fontcolor` method
	// https://tc39.es/ecma262/#sec-string.prototype.fontcolor


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('fontcolor')
	}, {
	  fontcolor: function fontcolor(color) {
	    return createHtml(this, 'font', 'color', color);
	  }
	});

	// `String.prototype.fontsize` method
	// https://tc39.es/ecma262/#sec-string.prototype.fontsize


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('fontsize')
	}, {
	  fontsize: function fontsize(size) {
	    return createHtml(this, 'font', 'size', size);
	  }
	});

	// `String.prototype.italics` method
	// https://tc39.es/ecma262/#sec-string.prototype.italics


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('italics')
	}, {
	  italics: function italics() {
	    return createHtml(this, 'i', '', '');
	  }
	});

	// `String.prototype.link` method
	// https://tc39.es/ecma262/#sec-string.prototype.link


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('link')
	}, {
	  link: function link(url) {
	    return createHtml(this, 'a', 'href', url);
	  }
	});

	// `String.prototype.small` method
	// https://tc39.es/ecma262/#sec-string.prototype.small


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('small')
	}, {
	  small: function small() {
	    return createHtml(this, 'small', '', '');
	  }
	});

	// `String.prototype.strike` method
	// https://tc39.es/ecma262/#sec-string.prototype.strike


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('strike')
	}, {
	  strike: function strike() {
	    return createHtml(this, 'strike', '', '');
	  }
	});

	// `String.prototype.sub` method
	// https://tc39.es/ecma262/#sec-string.prototype.sub


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('sub')
	}, {
	  sub: function sub() {
	    return createHtml(this, 'sub', '', '');
	  }
	});

	// `String.prototype.sup` method
	// https://tc39.es/ecma262/#sec-string.prototype.sup


	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('sup')
	}, {
	  sup: function sup() {
	    return createHtml(this, 'sup', '', '');
	  }
	});

	/* eslint-disable no-new -- required for testing */






	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	var ArrayBuffer$1 = global_1.ArrayBuffer;
	var Int8Array$3 = global_1.Int8Array;
	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
	  Int8Array$3(1);
	}) || !fails(function () {
	  new Int8Array$3(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$3();
	  new Int8Array$3(null);
	  new Int8Array$3(1.5);
	  new Int8Array$3(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$3(new ArrayBuffer$1(2), 1, undefined).length !== 1;
	});

	var RangeError$2 = global_1.RangeError;

	var toPositiveInteger = function (it) {
	  var result = toIntegerOrInfinity(it);
	  if (result < 0) throw RangeError$2("The argument can't be less than 0");
	  return result;
	};

	var RangeError$1 = global_1.RangeError;

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError$1('Wrong offset');
	  return offset;
	};

	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;

	var typedArrayFrom = function from(source
	/* , mapfn, thisArg */
	) {
	  var C = aConstructor(this);
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;

	  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = getIterator(O, iteratorMethod);
	    next = iterator.next;
	    O = [];

	    while (!(step = functionCall(next, iterator)).done) {
	      O.push(step.value);
	    }
	  }

	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2]);
	  }

	  length = lengthOfArrayLike(O);
	  result = new (aTypedArrayConstructor$2(C))(length);

	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }

	  return result;
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {













































	var getOwnPropertyNames = objectGetOwnPropertyNames.f;



	var forEach = arrayIteration.forEach;











	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var round = Math.round;
	var RangeError = global_1.RangeError;
	var ArrayBuffer = arrayBuffer.ArrayBuffer;
	var ArrayBufferPrototype = ArrayBuffer.prototype;
	var DataView = arrayBuffer.DataView;
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var TYPED_ARRAY_CONSTRUCTOR = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
	var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	var TypedArray = arrayBufferViewCore.TypedArray;
	var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var isTypedArray = arrayBufferViewCore.isTypedArray;
	var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	var WRONG_LENGTH = 'Wrong length';

	var fromList = function fromList(C, list) {
	  aTypedArrayConstructor(C);
	  var index = 0;
	  var length = list.length;
	  var result = new C(length);

	  while (length > index) {
	    result[index] = list[index++];
	  }

	  return result;
	};

	var addGetter = function addGetter(it, key) {
	  nativeDefineProperty(it, key, {
	    get: function get() {
	      return getInternalState(this)[key];
	    }
	  });
	};

	var isArrayBuffer = function isArrayBuffer(it) {
	  var klass;
	  return objectIsPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	};

	var isTypedArrayIndex = function isTypedArrayIndex(target, key) {
	  return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
	};

	var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	  key = toPropertyKey(key);
	  return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
	};

	var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	  key = toPropertyKey(key);

	  if (isTypedArrayIndex(target, key) && isObject$1(descriptor) && hasOwnProperty_1(descriptor, 'value') && !hasOwnProperty_1(descriptor, 'get') && !hasOwnProperty_1(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
	  && !descriptor.configurable && (!hasOwnProperty_1(descriptor, 'writable') || descriptor.writable) && (!hasOwnProperty_1(descriptor, 'enumerable') || descriptor.enumerable)) {
	    target[key] = descriptor.value;
	    return target;
	  }

	  return nativeDefineProperty(target, key, descriptor);
	};

	if (descriptors) {
	  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	    objectDefineProperty.f = wrappedDefineProperty;
	    addGetter(TypedArrayPrototype, 'buffer');
	    addGetter(TypedArrayPrototype, 'byteOffset');
	    addGetter(TypedArrayPrototype, 'byteLength');
	    addGetter(TypedArrayPrototype, 'length');
	  }

	  _export({
	    target: 'Object',
	    stat: true,
	    forced: !NATIVE_ARRAY_BUFFER_VIEWS
	  }, {
	    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	    defineProperty: wrappedDefineProperty
	  });

	  module.exports = function (TYPE, wrapper, CLAMPED) {
	    var BYTES = TYPE.match(/\d+$/)[0] / 8;
	    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + TYPE;
	    var SETTER = 'set' + TYPE;
	    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	    var TypedArrayConstructor = NativeTypedArrayConstructor;
	    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	    var exported = {};

	    var getter = function getter(that, index) {
	      var data = getInternalState(that);
	      return data.view[GETTER](index * BYTES + data.byteOffset, true);
	    };

	    var setter = function setter(that, index, value) {
	      var data = getInternalState(that);
	      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	    };

	    var addElement = function addElement(that, index) {
	      nativeDefineProperty(that, index, {
	        get: function get() {
	          return getter(this, index);
	        },
	        set: function set(value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };

	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	        anInstance(that, TypedArrayConstructorPrototype);
	        var index = 0;
	        var byteOffset = 0;
	        var buffer, byteLength, length;

	        if (!isObject$1(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new ArrayBuffer(byteLength);
	        } else if (isArrayBuffer(data)) {
	          buffer = data;
	          byteOffset = toOffset(offset, BYTES);
	          var $len = data.byteLength;

	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - byteOffset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	          }

	          length = byteLength / BYTES;
	        } else if (isTypedArray(data)) {
	          return fromList(TypedArrayConstructor, data);
	        } else {
	          return functionCall(typedArrayFrom, TypedArrayConstructor, data);
	        }

	        setInternalState(that, {
	          buffer: buffer,
	          byteOffset: byteOffset,
	          byteLength: byteLength,
	          length: length,
	          view: new DataView(buffer)
	        });

	        while (index < length) {
	          addElement(that, index++);
	        }
	      });
	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
	    } else if (typedArrayConstructorsRequireWrappers) {
	      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	        anInstance(dummy, TypedArrayConstructorPrototype);
	        return inheritIfRequired(function () {
	          if (!isObject$1(data)) return new NativeTypedArrayConstructor(toIndex(data));
	          if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
	          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	          return functionCall(typedArrayFrom, TypedArrayConstructor, data);
	        }(), dummy, TypedArrayConstructor);
	      });
	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	        if (!(key in TypedArrayConstructor)) {
	          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	        }
	      });
	      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	    }

	    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	    }

	    createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);

	    if (TYPED_ARRAY_TAG) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	    }

	    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
	    _export({
	      global: true,
	      forced: TypedArrayConstructor != NativeTypedArrayConstructor,
	      sham: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, exported);

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	    }

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	    }

	    setSpecies(CONSTRUCTOR_NAME);
	  };
	} else module.exports = function () {
	  /* empty */
	};
	});

	// `Float32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float64Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Float64', function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int8Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Int8', function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int16Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Int16', function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Int32', function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8ClampedArray` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	// `Uint16Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint16', function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint32', function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var u$ArrayCopyWithin = functionUncurryThis(arrayCopyWithin);
	var aTypedArray$m = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.copyWithin` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin

	exportTypedArrayMethod$n('copyWithin', function copyWithin(target, start
	/* , end */
	) {
	  return u$ArrayCopyWithin(aTypedArray$m(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	});

	var $every = arrayIteration.every;

	var aTypedArray$l = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.every` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every

	exportTypedArrayMethod$m('every', function every(callbackfn
	/* , thisArg */
	) {
	  return $every(aTypedArray$l(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$k = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.fill` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill

	exportTypedArrayMethod$l('fill', function fill(value
	/* , start, end */
	) {
	  var length = arguments.length;
	  return functionCall(arrayFill, aTypedArray$k(this), value, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
	});

	var arrayFromConstructorAndList = function (Constructor, list) {
	  var index = 0;
	  var length = lengthOfArrayLike(list);
	  var result = new Constructor(length);

	  while (length > index) {
	    result[index] = list[index++];
	  }

	  return result;
	};

	var TYPED_ARRAY_CONSTRUCTOR = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor; // a part of `TypedArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#typedarray-species-create

	var typedArraySpeciesConstructor = function (originalArray) {
	  return aTypedArrayConstructor$1(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
	};

	var typedArrayFromSpeciesAndList = function (instance, list) {
	  return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
	};

	var $filter = arrayIteration.filter;



	var aTypedArray$j = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.filter` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter

	exportTypedArrayMethod$k('filter', function filter(callbackfn
	/* , thisArg */
	) {
	  var list = $filter(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  return typedArrayFromSpeciesAndList(this, list);
	});

	var $find = arrayIteration.find;

	var aTypedArray$i = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.find` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find

	exportTypedArrayMethod$j('find', function find(predicate
	/* , thisArg */
	) {
	  return $find(aTypedArray$i(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findIndex = arrayIteration.findIndex;

	var aTypedArray$h = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.findIndex` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex

	exportTypedArrayMethod$i('findIndex', function findIndex(predicate
	/* , thisArg */
	) {
	  return $findIndex(aTypedArray$h(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $forEach = arrayIteration.forEach;

	var aTypedArray$g = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.forEach` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach

	exportTypedArrayMethod$h('forEach', function forEach(callbackfn
	/* , thisArg */
	) {
	  $forEach(aTypedArray$g(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;

	 // `%TypedArray%.from` method
	// https://tc39.es/ecma262/#sec-%typedarray%.from


	exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

	var $includes = arrayIncludes.includes;

	var aTypedArray$f = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.includes` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes

	exportTypedArrayMethod$g('includes', function includes(searchElement
	/* , fromIndex */
	) {
	  return $includes(aTypedArray$f(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $indexOf = arrayIncludes.indexOf;

	var aTypedArray$e = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.indexOf` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof

	exportTypedArrayMethod$f('indexOf', function indexOf(searchElement
	/* , fromIndex */
	) {
	  return $indexOf(aTypedArray$e(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var ITERATOR = wellKnownSymbol('iterator');
	var Uint8Array$2 = global_1.Uint8Array;
	var arrayValues = functionUncurryThis(es_array_iterator.values);
	var arrayKeys = functionUncurryThis(es_array_iterator.keys);
	var arrayEntries = functionUncurryThis(es_array_iterator.entries);
	var aTypedArray$d = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;
	var TypedArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype;
	var GENERIC = !fails(function () {
	  TypedArrayPrototype[ITERATOR].call([1]);
	});
	var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === 'values';

	var typedArrayValues = function values() {
	  return arrayValues(aTypedArray$d(this));
	}; // `%TypedArray%.prototype.entries` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries


	exportTypedArrayMethod$e('entries', function entries() {
	  return arrayEntries(aTypedArray$d(this));
	}, GENERIC); // `%TypedArray%.prototype.keys` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys

	exportTypedArrayMethod$e('keys', function keys() {
	  return arrayKeys(aTypedArray$d(this));
	}, GENERIC); // `%TypedArray%.prototype.values` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values

	exportTypedArrayMethod$e('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
	  name: 'values'
	}); // `%TypedArray%.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator

	exportTypedArrayMethod$e(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
	  name: 'values'
	});

	var aTypedArray$c = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;
	var $join = functionUncurryThis([].join); // `%TypedArray%.prototype.join` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join

	exportTypedArrayMethod$d('join', function join(separator) {
	  return $join(aTypedArray$c(this), separator);
	});

	var aTypedArray$b = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.lastIndexOf` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof

	exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement
	/* , fromIndex */
	) {
	  var length = arguments.length;
	  return functionApply(arrayLastIndexOf, aTypedArray$b(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
	});

	var $map = arrayIteration.map;



	var aTypedArray$a = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.map` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map

	exportTypedArrayMethod$b('map', function map(mapfn
	/* , thisArg */
	) {
	  return $map(aTypedArray$a(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
	    return new (typedArraySpeciesConstructor(O))(length);
	  });
	});

	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod; // `%TypedArray%.of` method
	// https://tc39.es/ecma262/#sec-%typedarray%.of

	exportTypedArrayStaticMethod('of', function
	  /* ...items */
	of() {
	  var index = 0;
	  var length = arguments.length;
	  var result = new (aTypedArrayConstructor(this))(length);

	  while (length > index) {
	    result[index] = arguments[index++];
	  }

	  return result;
	}, typedArrayConstructorsRequireWrappers);

	var $reduce = arrayReduce.left;

	var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduce` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce

	exportTypedArrayMethod$a('reduce', function reduce(callbackfn
	/* , initialValue */
	) {
	  var length = arguments.length;
	  return $reduce(aTypedArray$9(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
	});

	var $reduceRight = arrayReduce.right;

	var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduceRicht` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright

	exportTypedArrayMethod$9('reduceRight', function reduceRight(callbackfn
	/* , initialValue */
	) {
	  var length = arguments.length;
	  return $reduceRight(aTypedArray$8(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;
	var floor = Math.floor; // `%TypedArray%.prototype.reverse` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse

	exportTypedArrayMethod$8('reverse', function reverse() {
	  var that = this;
	  var length = aTypedArray$7(that).length;
	  var middle = floor(length / 2);
	  var index = 0;
	  var value;

	  while (index < middle) {
	    value = that[index];
	    that[index++] = that[--length];
	    that[length] = value;
	  }

	  return that;
	});

	var RangeError = global_1.RangeError;
	var Int8Array$2 = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
	var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
	var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;
	var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function () {
	  // eslint-disable-next-line es/no-typed-arrays -- required for testing
	  var array = new Uint8ClampedArray(2);
	  functionCall($set, array, {
	    length: 1,
	    0: 3
	  }, 1);
	  return array[1] !== 3;
	}); // https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other

	var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
	  var array = new Int8Array$2(2);
	  array.set(1);
	  array.set('2', 1);
	  return array[0] !== 0 || array[1] !== 2;
	}); // `%TypedArray%.prototype.set` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set

	exportTypedArrayMethod$7('set', function set(arrayLike
	/* , offset */
	) {
	  aTypedArray$6(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var src = toObject(arrayLike);
	  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return functionCall($set, this, src, offset);
	  var length = this.length;
	  var len = lengthOfArrayLike(src);
	  var index = 0;
	  if (len + offset > length) throw RangeError('Wrong length');

	  while (index < len) {
	    this[offset + index] = src[index++];
	  }
	}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);

	var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;
	var FORCED$4 = fails(function () {
	  // eslint-disable-next-line es/no-typed-arrays -- required for testing
	  new Int8Array(1).slice();
	}); // `%TypedArray%.prototype.slice` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice

	exportTypedArrayMethod$6('slice', function slice(start, end) {
	  var list = arraySlice$1(aTypedArray$5(this), start, end);
	  var C = typedArraySpeciesConstructor(this);
	  var index = 0;
	  var length = list.length;
	  var result = new C(length);

	  while (length > index) {
	    result[index] = list[index++];
	  }

	  return result;
	}, FORCED$4);

	var $some = arrayIteration.some;

	var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.some` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some

	exportTypedArrayMethod$5('some', function some(callbackfn
	/* , thisArg */
	) {
	  return $some(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var Array$2 = global_1.Array;
	var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;
	var Uint16Array$1 = global_1.Uint16Array;
	var un$Sort = Uint16Array$1 && functionUncurryThis(Uint16Array$1.prototype.sort); // WebKit

	var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function () {
	  un$Sort(new Uint16Array$1(2), null);
	}) && fails(function () {
	  un$Sort(new Uint16Array$1(2), {});
	}));
	var STABLE_SORT = !!un$Sort && !fails(function () {
	  // feature detection can be too slow, so check engines versions
	  if (engineV8Version) return engineV8Version < 74;
	  if (engineFfVersion) return engineFfVersion < 67;
	  if (engineIsIeOrEdge) return true;
	  if (engineWebkitVersion) return engineWebkitVersion < 602;
	  var array = new Uint16Array$1(516);
	  var expected = Array$2(516);
	  var index, mod;

	  for (index = 0; index < 516; index++) {
	    mod = index % 4;
	    array[index] = 515 - index;
	    expected[index] = index - 2 * mod + 3;
	  }

	  un$Sort(array, function (a, b) {
	    return (a / 4 | 0) - (b / 4 | 0);
	  });

	  for (index = 0; index < 516; index++) {
	    if (array[index] !== expected[index]) return true;
	  }
	});

	var getSortCompare = function getSortCompare(comparefn) {
	  return function (x, y) {
	    if (comparefn !== undefined) return +comparefn(x, y) || 0; // eslint-disable-next-line no-self-compare -- NaN check

	    if (y !== y) return -1; // eslint-disable-next-line no-self-compare -- NaN check

	    if (x !== x) return 1;
	    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
	    return x > y;
	  };
	}; // `%TypedArray%.prototype.sort` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort


	exportTypedArrayMethod$4('sort', function sort(comparefn) {
	  if (comparefn !== undefined) aCallable(comparefn);
	  if (STABLE_SORT) return un$Sort(this, comparefn);
	  return arraySort(aTypedArray$3(this), getSortCompare(comparefn));
	}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.subarray` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray

	exportTypedArrayMethod$3('subarray', function subarray(begin, end) {
	  var O = aTypedArray$2(this);
	  var length = O.length;
	  var beginIndex = toAbsoluteIndex(begin, length);
	  var C = typedArraySpeciesConstructor(O);
	  return new C(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
	});

	var Int8Array$1 = global_1.Int8Array;
	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;
	var $toLocaleString = [].toLocaleString; // iOS Safari 6.x fails here

	var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails(function () {
	  $toLocaleString.call(new Int8Array$1(1));
	});
	var FORCED$3 = fails(function () {
	  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();
	}) || !fails(function () {
	  Int8Array$1.prototype.toLocaleString.call([1, 2]);
	}); // `%TypedArray%.prototype.toLocaleString` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring

	exportTypedArrayMethod$2('toLocaleString', function toLocaleString() {
	  return functionApply($toLocaleString, TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray$1(this)) : aTypedArray$1(this), arraySlice$1(arguments));
	}, FORCED$3);

	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;







	var Uint8Array$1 = global_1.Uint8Array;
	var Uint8ArrayPrototype = Uint8Array$1 && Uint8Array$1.prototype || {};
	var arrayToString = [].toString;
	var join = functionUncurryThis([].join);

	if (fails(function () {
	  arrayToString.call({});
	})) {
	  arrayToString = function toString() {
	    return join(this);
	  };
	}

	var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString; // `%TypedArray%.prototype.toString` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring

	exportTypedArrayMethod$1('toString', arrayToString, IS_NOT_ARRAY_METHOD);

	var getWeakData = internalMetadata.getWeakData;















	var setInternalState$1 = internalState.set;
	var internalStateGetterFor = internalState.getterFor;
	var find = arrayIteration.find;
	var findIndex = arrayIteration.findIndex;
	var splice = functionUncurryThis([].splice);
	var id = 0; // fallback for uncaught frozen keys

	var uncaughtFrozenStore = function uncaughtFrozenStore(store) {
	  return store.frozen || (store.frozen = new UncaughtFrozenStore());
	};

	var UncaughtFrozenStore = function UncaughtFrozenStore() {
	  this.entries = [];
	};

	var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
	  return find(store.entries, function (it) {
	    return it[0] === key;
	  });
	};

	UncaughtFrozenStore.prototype = {
	  get: function get(key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function has(key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function set(key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;else this.entries.push([key, value]);
	  },
	  'delete': function _delete(key) {
	    var index = findIndex(this.entries, function (it) {
	      return it[0] === key;
	    });
	    if (~index) splice(this.entries, index, 1);
	    return !!~index;
	  }
	};
	var collectionWeak = {
	  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var Constructor = wrapper(function (that, iterable) {
	      anInstance(that, Prototype);
	      setInternalState$1(that, {
	        type: CONSTRUCTOR_NAME,
	        id: id++,
	        frozen: undefined
	      });
	      if (iterable != undefined) iterate(iterable, that[ADDER], {
	        that: that,
	        AS_ENTRIES: IS_MAP
	      });
	    });
	    var Prototype = Constructor.prototype;
	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    var define = function define(that, key, value) {
	      var state = getInternalState(that);
	      var data = getWeakData(anObject(key), true);
	      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
	      return that;
	    };

	    redefineAll(Prototype, {
	      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
	      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
	      'delete': function _delete(key) {
	        var state = getInternalState(this);
	        if (!isObject$1(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
	        return data && hasOwnProperty_1(data, state.id) && delete data[state.id];
	      },
	      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
	      // https://tc39.es/ecma262/#sec-weakset.prototype.has
	      has: function has(key) {
	        var state = getInternalState(this);
	        if (!isObject$1(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state).has(key);
	        return data && hasOwnProperty_1(data, state.id);
	      }
	    });
	    redefineAll(Prototype, IS_MAP ? {
	      // `WeakMap.prototype.get(key)` method
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
	      get: function get(key) {
	        var state = getInternalState(this);

	        if (isObject$1(key)) {
	          var data = getWeakData(key);
	          if (data === true) return uncaughtFrozenStore(state).get(key);
	          return data ? data[state.id] : undefined;
	        }
	      },
	      // `WeakMap.prototype.set(key, value)` method
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
	      set: function set(key, value) {
	        return define(this, key, value);
	      }
	    } : {
	      // `WeakSet.prototype.add(value)` method
	      // https://tc39.es/ecma262/#sec-weakset.prototype.add
	      add: function add(value) {
	        return define(this, value, true);
	      }
	    });
	    return Constructor;
	  }
	};
	collectionWeak.getConstructor;

	var enforceInternalState = internalState.enforce;



	var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;
	var InternalWeakMap;

	var wrapper = function wrapper(init) {
	  return function WeakMap() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	}; // `WeakMap` constructor
	// https://tc39.es/ecma262/#sec-weakmap-constructor


	var $WeakMap = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
	// We can't use feature detection because it crash some old IE builds
	// https://github.com/zloirock/core-js/issues/485

	if (nativeWeakMap && IS_IE11) {
	  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
	  internalMetadata.enable();
	  var WeakMapPrototype = $WeakMap.prototype;
	  var nativeDelete = functionUncurryThis(WeakMapPrototype['delete']);
	  var nativeHas = functionUncurryThis(WeakMapPrototype.has);
	  var nativeGet = functionUncurryThis(WeakMapPrototype.get);
	  var nativeSet = functionUncurryThis(WeakMapPrototype.set);
	  redefineAll(WeakMapPrototype, {
	    'delete': function _delete(key) {
	      if (isObject$1(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeDelete(this, key) || state.frozen['delete'](key);
	      }

	      return nativeDelete(this, key);
	    },
	    has: function has(key) {
	      if (isObject$1(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas(this, key) || state.frozen.has(key);
	      }

	      return nativeHas(this, key);
	    },
	    get: function get(key) {
	      if (isObject$1(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
	      }

	      return nativeGet(this, key);
	    },
	    set: function set(key, value) {
	      if (isObject$1(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
	      } else nativeSet(this, key, value);

	      return this;
	    }
	  });
	}

	// `WeakSet` constructor
	// https://tc39.es/ecma262/#sec-weakset-constructor


	collection('WeakSet', function (init) {
	  return function WeakSet() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	}, collectionWeak);

	var FORCED$2 = !global_1.setImmediate || !global_1.clearImmediate; // http://w3c.github.io/setImmediate/

	_export({
	  global: true,
	  bind: true,
	  enumerable: true,
	  forced: FORCED$2
	}, {
	  // `setImmediate` method
	  // http://w3c.github.io/setImmediate/#si-setImmediate
	  setImmediate: task$1.set,
	  // `clearImmediate` method
	  // http://w3c.github.io/setImmediate/#si-clearImmediate
	  clearImmediate: task$1.clear
	});

	var process$1 = global_1.process; // `queueMicrotask` method
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask

	_export({
	  global: true,
	  enumerable: true,
	  noTargetGet: true
	}, {
	  queueMicrotask: function queueMicrotask(fn) {
	    validateArgumentsLength(arguments.length, 1);
	    aCallable(fn);
	    var domain = engineIsNode && process$1.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson


	_export({
	  target: 'URL',
	  proto: true,
	  enumerable: true
	}, {
	  toJSON: function toJSON() {
	    return functionCall(URL.prototype.toString, this);
	  }
	});

	var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	function int2char(n) {
	  return BI_RM.charAt(n);
	} //#region BIT_OPERATIONS
	// (public) this & a

	function op_and(x, y) {
	  return x & y;
	} // (public) this | a

	function op_or(x, y) {
	  return x | y;
	} // (public) this ^ a

	function op_xor(x, y) {
	  return x ^ y;
	} // (public) this & ~a

	function op_andnot(x, y) {
	  return x & ~y;
	} // return index of lowest 1-bit in x, x < 2^31

	function lbit(x) {
	  if (x == 0) {
	    return -1;
	  }

	  var r = 0;

	  if ((x & 0xffff) == 0) {
	    x >>= 16;
	    r += 16;
	  }

	  if ((x & 0xff) == 0) {
	    x >>= 8;
	    r += 8;
	  }

	  if ((x & 0xf) == 0) {
	    x >>= 4;
	    r += 4;
	  }

	  if ((x & 3) == 0) {
	    x >>= 2;
	    r += 2;
	  }

	  if ((x & 1) == 0) {
	    ++r;
	  }

	  return r;
	} // return number of 1 bits in x

	function cbit(x) {
	  var r = 0;

	  while (x != 0) {
	    x &= x - 1;
	    ++r;
	  }

	  return r;
	} //#endregion BIT_OPERATIONS

	var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	var b64pad = "=";
	function hex2b64(h) {
	  var i;
	  var c;
	  var ret = "";

	  for (i = 0; i + 3 <= h.length; i += 3) {
	    c = parseInt(h.substring(i, i + 3), 16);
	    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
	  }

	  if (i + 1 == h.length) {
	    c = parseInt(h.substring(i, i + 1), 16);
	    ret += b64map.charAt(c << 2);
	  } else if (i + 2 == h.length) {
	    c = parseInt(h.substring(i, i + 2), 16);
	    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
	  }

	  while ((ret.length & 3) > 0) {
	    ret += b64pad;
	  }

	  return ret;
	} // convert a base64 string to hex

	function b64tohex(s) {
	  var ret = "";
	  var i;
	  var k = 0; // b64 state, 0-3

	  var slop = 0;

	  for (i = 0; i < s.length; ++i) {
	    if (s.charAt(i) == b64pad) {
	      break;
	    }

	    var v = b64map.indexOf(s.charAt(i));

	    if (v < 0) {
	      continue;
	    }

	    if (k == 0) {
	      ret += int2char(v >> 2);
	      slop = v & 3;
	      k = 1;
	    } else if (k == 1) {
	      ret += int2char(slop << 2 | v >> 4);
	      slop = v & 0xf;
	      k = 2;
	    } else if (k == 2) {
	      ret += int2char(slop);
	      ret += int2char(v >> 2);
	      slop = v & 3;
	      k = 3;
	    } else {
	      ret += int2char(slop << 2 | v >> 4);
	      ret += int2char(v & 0xf);
	      k = 0;
	    }
	  }

	  if (k == 1) {
	    ret += int2char(slop << 2);
	  }

	  return ret;
	} // convert a base64 string to a byte/number array

	// Hex JavaScript decoder
	// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
	// Permission to use, copy, modify, and/or distribute this software for any
	// purpose with or without fee is hereby granted, provided that the above
	// copyright notice and this permission notice appear in all copies.
	//
	// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

	/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
	var decoder$1;
	var Hex = {
	  decode: function decode(a) {
	    var i;

	    if (decoder$1 === undefined) {
	      var hex = "0123456789ABCDEF";
	      var ignore = " \f\n\r\t\xA0\u2028\u2029";
	      decoder$1 = {};

	      for (i = 0; i < 16; ++i) {
	        decoder$1[hex.charAt(i)] = i;
	      }

	      hex = hex.toLowerCase();

	      for (i = 10; i < 16; ++i) {
	        decoder$1[hex.charAt(i)] = i;
	      }

	      for (i = 0; i < ignore.length; ++i) {
	        decoder$1[ignore.charAt(i)] = -1;
	      }
	    }

	    var out = [];
	    var bits = 0;
	    var char_count = 0;

	    for (i = 0; i < a.length; ++i) {
	      var c = a.charAt(i);

	      if (c == "=") {
	        break;
	      }

	      c = decoder$1[c];

	      if (c == -1) {
	        continue;
	      }

	      if (c === undefined) {
	        throw new Error("Illegal character at offset " + i);
	      }

	      bits |= c;

	      if (++char_count >= 2) {
	        out[out.length] = bits;
	        bits = 0;
	        char_count = 0;
	      } else {
	        bits <<= 4;
	      }
	    }

	    if (char_count) {
	      throw new Error("Hex encoding incomplete: 4 bits missing");
	    }

	    return out;
	  }
	};

	// Base64 JavaScript decoder
	// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
	// Permission to use, copy, modify, and/or distribute this software for any
	// purpose with or without fee is hereby granted, provided that the above
	// copyright notice and this permission notice appear in all copies.
	//
	// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

	/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
	var decoder;
	var Base64 = {
	  decode: function decode(a) {
	    var i;

	    if (decoder === undefined) {
	      var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	      var ignore = "= \f\n\r\t\xA0\u2028\u2029";
	      decoder = Object.create(null);

	      for (i = 0; i < 64; ++i) {
	        decoder[b64.charAt(i)] = i;
	      }

	      decoder['-'] = 62; //+

	      decoder['_'] = 63; //-

	      for (i = 0; i < ignore.length; ++i) {
	        decoder[ignore.charAt(i)] = -1;
	      }
	    }

	    var out = [];
	    var bits = 0;
	    var char_count = 0;

	    for (i = 0; i < a.length; ++i) {
	      var c = a.charAt(i);

	      if (c == "=") {
	        break;
	      }

	      c = decoder[c];

	      if (c == -1) {
	        continue;
	      }

	      if (c === undefined) {
	        throw new Error("Illegal character at offset " + i);
	      }

	      bits |= c;

	      if (++char_count >= 4) {
	        out[out.length] = bits >> 16;
	        out[out.length] = bits >> 8 & 0xFF;
	        out[out.length] = bits & 0xFF;
	        bits = 0;
	        char_count = 0;
	      } else {
	        bits <<= 6;
	      }
	    }

	    switch (char_count) {
	      case 1:
	        throw new Error("Base64 encoding incomplete: at least 2 bits missing");

	      case 2:
	        out[out.length] = bits >> 10;
	        break;

	      case 3:
	        out[out.length] = bits >> 16;
	        out[out.length] = bits >> 8 & 0xFF;
	        break;
	    }

	    return out;
	  },
	  re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
	  unarmor: function unarmor(a) {
	    var m = Base64.re.exec(a);

	    if (m) {
	      if (m[1]) {
	        a = m[1];
	      } else if (m[2]) {
	        a = m[2];
	      } else {
	        throw new Error("RegExp out of sync");
	      }
	    }

	    return Base64.decode(a);
	  }
	};

	// Big integer base-10 printing library
	// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
	// Permission to use, copy, modify, and/or distribute this software for any
	// purpose with or without fee is hereby granted, provided that the above
	// copyright notice and this permission notice appear in all copies.
	//
	// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

	/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
	var max$1 = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256

	var Int10 =
	/** @class */
	function () {
	  function Int10(value) {
	    this.buf = [+value || 0];
	  }

	  Int10.prototype.mulAdd = function (m, c) {
	    // assert(m <= 256)
	    var b = this.buf;
	    var l = b.length;
	    var i;
	    var t;

	    for (i = 0; i < l; ++i) {
	      t = b[i] * m + c;

	      if (t < max$1) {
	        c = 0;
	      } else {
	        c = 0 | t / max$1;
	        t -= c * max$1;
	      }

	      b[i] = t;
	    }

	    if (c > 0) {
	      b[i] = c;
	    }
	  };

	  Int10.prototype.sub = function (c) {
	    // assert(m <= 256)
	    var b = this.buf;
	    var l = b.length;
	    var i;
	    var t;

	    for (i = 0; i < l; ++i) {
	      t = b[i] - c;

	      if (t < 0) {
	        t += max$1;
	        c = 1;
	      } else {
	        c = 0;
	      }

	      b[i] = t;
	    }

	    while (b[b.length - 1] === 0) {
	      b.pop();
	    }
	  };

	  Int10.prototype.toString = function (base) {
	    if ((base || 10) != 10) {
	      throw new Error("only base 10 is supported");
	    }

	    var b = this.buf;
	    var s = b[b.length - 1].toString();

	    for (var i = b.length - 2; i >= 0; --i) {
	      s += (max$1 + b[i]).toString().substring(1);
	    }

	    return s;
	  };

	  Int10.prototype.valueOf = function () {
	    var b = this.buf;
	    var v = 0;

	    for (var i = b.length - 1; i >= 0; --i) {
	      v = v * max$1 + b[i];
	    }

	    return v;
	  };

	  Int10.prototype.simplify = function () {
	    var b = this.buf;
	    return b.length == 1 ? b[0] : this;
	  };

	  return Int10;
	}();

	var ellipsis = "\u2026";
	var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
	var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;

	function stringCut(str, len) {
	  if (str.length > len) {
	    str = str.substring(0, len) + ellipsis;
	  }

	  return str;
	}

	var Stream =
	/** @class */
	function () {
	  function Stream(enc, pos) {
	    this.hexDigits = "0123456789ABCDEF";

	    if (enc instanceof Stream) {
	      this.enc = enc.enc;
	      this.pos = enc.pos;
	    } else {
	      // enc should be an array or a binary string
	      this.enc = enc;
	      this.pos = pos;
	    }
	  }

	  Stream.prototype.get = function (pos) {
	    if (pos === undefined) {
	      pos = this.pos++;
	    }

	    if (pos >= this.enc.length) {
	      throw new Error("Requesting byte offset " + pos + " on a stream of length " + this.enc.length);
	    }

	    return "string" === typeof this.enc ? this.enc.charCodeAt(pos) : this.enc[pos];
	  };

	  Stream.prototype.hexByte = function (b) {
	    return this.hexDigits.charAt(b >> 4 & 0xF) + this.hexDigits.charAt(b & 0xF);
	  };

	  Stream.prototype.hexDump = function (start, end, raw) {
	    var s = "";

	    for (var i = start; i < end; ++i) {
	      s += this.hexByte(this.get(i));

	      if (raw !== true) {
	        switch (i & 0xF) {
	          case 0x7:
	            s += "  ";
	            break;

	          case 0xF:
	            s += "\n";
	            break;

	          default:
	            s += " ";
	        }
	      }
	    }

	    return s;
	  };

	  Stream.prototype.isASCII = function (start, end) {
	    for (var i = start; i < end; ++i) {
	      var c = this.get(i);

	      if (c < 32 || c > 176) {
	        return false;
	      }
	    }

	    return true;
	  };

	  Stream.prototype.parseStringISO = function (start, end) {
	    var s = "";

	    for (var i = start; i < end; ++i) {
	      s += String.fromCharCode(this.get(i));
	    }

	    return s;
	  };

	  Stream.prototype.parseStringUTF = function (start, end) {
	    var s = "";

	    for (var i = start; i < end;) {
	      var c = this.get(i++);

	      if (c < 128) {
	        s += String.fromCharCode(c);
	      } else if (c > 191 && c < 224) {
	        s += String.fromCharCode((c & 0x1F) << 6 | this.get(i++) & 0x3F);
	      } else {
	        s += String.fromCharCode((c & 0x0F) << 12 | (this.get(i++) & 0x3F) << 6 | this.get(i++) & 0x3F);
	      }
	    }

	    return s;
	  };

	  Stream.prototype.parseStringBMP = function (start, end) {
	    var str = "";
	    var hi;
	    var lo;

	    for (var i = start; i < end;) {
	      hi = this.get(i++);
	      lo = this.get(i++);
	      str += String.fromCharCode(hi << 8 | lo);
	    }

	    return str;
	  };

	  Stream.prototype.parseTime = function (start, end, shortYear) {
	    var s = this.parseStringISO(start, end);
	    var m = (shortYear ? reTimeS : reTimeL).exec(s);

	    if (!m) {
	      return "Unrecognized time: " + s;
	    }

	    if (shortYear) {
	      // to avoid querying the timer, use the fixed range [1970, 2069]
	      // it will conform with ITU X.400 [-10, +40] sliding window until 2030
	      m[1] = +m[1];
	      m[1] += +m[1] < 70 ? 2000 : 1900;
	    }

	    s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];

	    if (m[5]) {
	      s += ":" + m[5];

	      if (m[6]) {
	        s += ":" + m[6];

	        if (m[7]) {
	          s += "." + m[7];
	        }
	      }
	    }

	    if (m[8]) {
	      s += " UTC";

	      if (m[8] != "Z") {
	        s += m[8];

	        if (m[9]) {
	          s += ":" + m[9];
	        }
	      }
	    }

	    return s;
	  };

	  Stream.prototype.parseInteger = function (start, end) {
	    var v = this.get(start);
	    var neg = v > 127;
	    var pad = neg ? 255 : 0;
	    var len;
	    var s = ""; // skip unuseful bits (not allowed in DER)

	    while (v == pad && ++start < end) {
	      v = this.get(start);
	    }

	    len = end - start;

	    if (len === 0) {
	      return neg ? -1 : 0;
	    } // show bit length of huge integers


	    if (len > 4) {
	      s = v;
	      len <<= 3;

	      while (((+s ^ pad) & 0x80) == 0) {
	        s = +s << 1;
	        --len;
	      }

	      s = "(" + len + " bit)\n";
	    } // decode the integer


	    if (neg) {
	      v = v - 256;
	    }

	    var n = new Int10(v);

	    for (var i = start + 1; i < end; ++i) {
	      n.mulAdd(256, this.get(i));
	    }

	    return s + n.toString();
	  };

	  Stream.prototype.parseBitString = function (start, end, maxLength) {
	    var unusedBit = this.get(start);
	    var lenBit = (end - start - 1 << 3) - unusedBit;
	    var intro = "(" + lenBit + " bit)\n";
	    var s = "";

	    for (var i = start + 1; i < end; ++i) {
	      var b = this.get(i);
	      var skip = i == end - 1 ? unusedBit : 0;

	      for (var j = 7; j >= skip; --j) {
	        s += b >> j & 1 ? "1" : "0";
	      }

	      if (s.length > maxLength) {
	        return intro + stringCut(s, maxLength);
	      }
	    }

	    return intro + s;
	  };

	  Stream.prototype.parseOctetString = function (start, end, maxLength) {
	    if (this.isASCII(start, end)) {
	      return stringCut(this.parseStringISO(start, end), maxLength);
	    }

	    var len = end - start;
	    var s = "(" + len + " byte)\n";
	    maxLength /= 2; // we work in bytes

	    if (len > maxLength) {
	      end = start + maxLength;
	    }

	    for (var i = start; i < end; ++i) {
	      s += this.hexByte(this.get(i));
	    }

	    if (len > maxLength) {
	      s += ellipsis;
	    }

	    return s;
	  };

	  Stream.prototype.parseOID = function (start, end, maxLength) {
	    var s = "";
	    var n = new Int10();
	    var bits = 0;

	    for (var i = start; i < end; ++i) {
	      var v = this.get(i);
	      n.mulAdd(128, v & 0x7F);
	      bits += 7;

	      if (!(v & 0x80)) {
	        // finished
	        if (s === "") {
	          n = n.simplify();

	          if (n instanceof Int10) {
	            n.sub(80);
	            s = "2." + n.toString();
	          } else {
	            var m = n < 80 ? n < 40 ? 0 : 1 : 2;
	            s = m + "." + (n - m * 40);
	          }
	        } else {
	          s += "." + n.toString();
	        }

	        if (s.length > maxLength) {
	          return stringCut(s, maxLength);
	        }

	        n = new Int10();
	        bits = 0;
	      }
	    }

	    if (bits > 0) {
	      s += ".incomplete";
	    }

	    return s;
	  };

	  return Stream;
	}();

	var ASN1 =
	/** @class */
	function () {
	  function ASN1(stream, header, length, tag, sub) {
	    if (!(tag instanceof ASN1Tag)) {
	      throw new Error("Invalid tag value.");
	    }

	    this.stream = stream;
	    this.header = header;
	    this.length = length;
	    this.tag = tag;
	    this.sub = sub;
	  }

	  ASN1.prototype.typeName = function () {
	    switch (this.tag.tagClass) {
	      case 0:
	        // universal
	        switch (this.tag.tagNumber) {
	          case 0x00:
	            return "EOC";

	          case 0x01:
	            return "BOOLEAN";

	          case 0x02:
	            return "INTEGER";

	          case 0x03:
	            return "BIT_STRING";

	          case 0x04:
	            return "OCTET_STRING";

	          case 0x05:
	            return "NULL";

	          case 0x06:
	            return "OBJECT_IDENTIFIER";

	          case 0x07:
	            return "ObjectDescriptor";

	          case 0x08:
	            return "EXTERNAL";

	          case 0x09:
	            return "REAL";

	          case 0x0A:
	            return "ENUMERATED";

	          case 0x0B:
	            return "EMBEDDED_PDV";

	          case 0x0C:
	            return "UTF8String";

	          case 0x10:
	            return "SEQUENCE";

	          case 0x11:
	            return "SET";

	          case 0x12:
	            return "NumericString";

	          case 0x13:
	            return "PrintableString";
	          // ASCII subset

	          case 0x14:
	            return "TeletexString";
	          // aka T61String

	          case 0x15:
	            return "VideotexString";

	          case 0x16:
	            return "IA5String";
	          // ASCII

	          case 0x17:
	            return "UTCTime";

	          case 0x18:
	            return "GeneralizedTime";

	          case 0x19:
	            return "GraphicString";

	          case 0x1A:
	            return "VisibleString";
	          // ASCII subset

	          case 0x1B:
	            return "GeneralString";

	          case 0x1C:
	            return "UniversalString";

	          case 0x1E:
	            return "BMPString";
	        }

	        return "Universal_" + this.tag.tagNumber.toString();

	      case 1:
	        return "Application_" + this.tag.tagNumber.toString();

	      case 2:
	        return "[" + this.tag.tagNumber.toString() + "]";
	      // Context

	      case 3:
	        return "Private_" + this.tag.tagNumber.toString();
	    }
	  };

	  ASN1.prototype.content = function (maxLength) {
	    if (this.tag === undefined) {
	      return null;
	    }

	    if (maxLength === undefined) {
	      maxLength = Infinity;
	    }

	    var content = this.posContent();
	    var len = Math.abs(this.length);

	    if (!this.tag.isUniversal()) {
	      if (this.sub !== null) {
	        return "(" + this.sub.length + " elem)";
	      }

	      return this.stream.parseOctetString(content, content + len, maxLength);
	    }

	    switch (this.tag.tagNumber) {
	      case 0x01:
	        // BOOLEAN
	        return this.stream.get(content) === 0 ? "false" : "true";

	      case 0x02:
	        // INTEGER
	        return this.stream.parseInteger(content, content + len);

	      case 0x03:
	        // BIT_STRING
	        return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(content, content + len, maxLength);

	      case 0x04:
	        // OCTET_STRING
	        return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(content, content + len, maxLength);
	      // case 0x05: // NULL

	      case 0x06:
	        // OBJECT_IDENTIFIER
	        return this.stream.parseOID(content, content + len, maxLength);
	      // case 0x07: // ObjectDescriptor
	      // case 0x08: // EXTERNAL
	      // case 0x09: // REAL
	      // case 0x0A: // ENUMERATED
	      // case 0x0B: // EMBEDDED_PDV

	      case 0x10: // SEQUENCE

	      case 0x11:
	        // SET
	        if (this.sub !== null) {
	          return "(" + this.sub.length + " elem)";
	        } else {
	          return "(no elem)";
	        }

	      case 0x0C:
	        // UTF8String
	        return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);

	      case 0x12: // NumericString

	      case 0x13: // PrintableString

	      case 0x14: // TeletexString

	      case 0x15: // VideotexString

	      case 0x16: // IA5String
	      // case 0x19: // GraphicString

	      case 0x1A:
	        // VisibleString
	        // case 0x1B: // GeneralString
	        // case 0x1C: // UniversalString
	        return stringCut(this.stream.parseStringISO(content, content + len), maxLength);

	      case 0x1E:
	        // BMPString
	        return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);

	      case 0x17: // UTCTime

	      case 0x18:
	        // GeneralizedTime
	        return this.stream.parseTime(content, content + len, this.tag.tagNumber == 0x17);
	    }

	    return null;
	  };

	  ASN1.prototype.toString = function () {
	    return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + (this.sub === null ? "null" : this.sub.length) + "]";
	  };

	  ASN1.prototype.toPrettyString = function (indent) {
	    if (indent === undefined) {
	      indent = "";
	    }

	    var s = indent + this.typeName() + " @" + this.stream.pos;

	    if (this.length >= 0) {
	      s += "+";
	    }

	    s += this.length;

	    if (this.tag.tagConstructed) {
	      s += " (constructed)";
	    } else if (this.tag.isUniversal() && (this.tag.tagNumber == 0x03 || this.tag.tagNumber == 0x04) && this.sub !== null) {
	      s += " (encapsulates)";
	    }

	    s += "\n";

	    if (this.sub !== null) {
	      indent += "  ";

	      for (var i = 0, max = this.sub.length; i < max; ++i) {
	        s += this.sub[i].toPrettyString(indent);
	      }
	    }

	    return s;
	  };

	  ASN1.prototype.posStart = function () {
	    return this.stream.pos;
	  };

	  ASN1.prototype.posContent = function () {
	    return this.stream.pos + this.header;
	  };

	  ASN1.prototype.posEnd = function () {
	    return this.stream.pos + this.header + Math.abs(this.length);
	  };

	  ASN1.prototype.toHexString = function () {
	    return this.stream.hexDump(this.posStart(), this.posEnd(), true);
	  };

	  ASN1.decodeLength = function (stream) {
	    var buf = stream.get();
	    var len = buf & 0x7F;

	    if (len == buf) {
	      return len;
	    } // no reason to use Int10, as it would be a huge buffer anyways


	    if (len > 6) {
	      throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
	    }

	    if (len === 0) {
	      return null;
	    } // undefined


	    buf = 0;

	    for (var i = 0; i < len; ++i) {
	      buf = buf * 256 + stream.get();
	    }

	    return buf;
	  };
	  /**
	   * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
	   * @returns {string}
	   * @public
	   */


	  ASN1.prototype.getHexStringValue = function () {
	    var hexString = this.toHexString();
	    var offset = this.header * 2;
	    var length = this.length * 2;
	    return hexString.substr(offset, length);
	  };

	  ASN1.decode = function (str) {
	    var stream;

	    if (!(str instanceof Stream)) {
	      stream = new Stream(str, 0);
	    } else {
	      stream = str;
	    }

	    var streamStart = new Stream(stream);
	    var tag = new ASN1Tag(stream);
	    var len = ASN1.decodeLength(stream);
	    var start = stream.pos;
	    var header = start - streamStart.pos;
	    var sub = null;

	    var getSub = function getSub() {
	      var ret = [];

	      if (len !== null) {
	        // definite length
	        var end = start + len;

	        while (stream.pos < end) {
	          ret[ret.length] = ASN1.decode(stream);
	        }

	        if (stream.pos != end) {
	          throw new Error("Content size is not correct for container starting at offset " + start);
	        }
	      } else {
	        // undefined length
	        try {
	          for (;;) {
	            var s = ASN1.decode(stream);

	            if (s.tag.isEOC()) {
	              break;
	            }

	            ret[ret.length] = s;
	          }

	          len = start - stream.pos; // undefined lengths are represented as negative values
	        } catch (e) {
	          throw new Error("Exception while decoding undefined length content: " + e);
	        }
	      }

	      return ret;
	    };

	    if (tag.tagConstructed) {
	      // must have valid content
	      sub = getSub();
	    } else if (tag.isUniversal() && (tag.tagNumber == 0x03 || tag.tagNumber == 0x04)) {
	      // sometimes BitString and OctetString are used to encapsulate ASN.1
	      try {
	        if (tag.tagNumber == 0x03) {
	          if (stream.get() != 0) {
	            throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
	          }
	        }

	        sub = getSub();

	        for (var i = 0; i < sub.length; ++i) {
	          if (sub[i].tag.isEOC()) {
	            throw new Error("EOC is not supposed to be actual content.");
	          }
	        }
	      } catch (e) {
	        // but silently ignore when they don't
	        sub = null;
	      }
	    }

	    if (sub === null) {
	      if (len === null) {
	        throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
	      }

	      stream.pos = start + Math.abs(len);
	    }

	    return new ASN1(streamStart, header, len, tag, sub);
	  };

	  return ASN1;
	}();

	var ASN1Tag =
	/** @class */
	function () {
	  function ASN1Tag(stream) {
	    var buf = stream.get();
	    this.tagClass = buf >> 6;
	    this.tagConstructed = (buf & 0x20) !== 0;
	    this.tagNumber = buf & 0x1F;

	    if (this.tagNumber == 0x1F) {
	      // long tag
	      var n = new Int10();

	      do {
	        buf = stream.get();
	        n.mulAdd(128, buf & 0x7F);
	      } while (buf & 0x80);

	      this.tagNumber = n.simplify();
	    }
	  }

	  ASN1Tag.prototype.isUniversal = function () {
	    return this.tagClass === 0x00;
	  };

	  ASN1Tag.prototype.isEOC = function () {
	    return this.tagClass === 0x00 && this.tagNumber === 0x00;
	  };

	  return ASN1Tag;
	}();

	var dbits; // JavaScript engine analysis

	var canary = 0xdeadbeefcafe;
	var j_lm = (canary & 0xffffff) == 0xefcafe; //#region

	var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; //#endregion
	// (public) Constructor

	var BigInteger =
	/** @class */
	function () {
	  function BigInteger(a, b, c) {
	    if (a != null) {
	      if ("number" == typeof a) {
	        this.fromNumber(a, b, c);
	      } else if (b == null && "string" != typeof a) {
	        this.fromString(a, 256);
	      } else {
	        this.fromString(a, b);
	      }
	    }
	  } //#region PUBLIC
	  // BigInteger.prototype.toString = bnToString;
	  // (public) return string representation in given radix


	  BigInteger.prototype.toString = function (b) {
	    if (this.s < 0) {
	      return "-" + this.negate().toString(b);
	    }

	    var k;

	    if (b == 16) {
	      k = 4;
	    } else if (b == 8) {
	      k = 3;
	    } else if (b == 2) {
	      k = 1;
	    } else if (b == 32) {
	      k = 5;
	    } else if (b == 4) {
	      k = 2;
	    } else {
	      return this.toRadix(b);
	    }

	    var km = (1 << k) - 1;
	    var d;
	    var m = false;
	    var r = "";
	    var i = this.t;
	    var p = this.DB - i * this.DB % k;

	    if (i-- > 0) {
	      if (p < this.DB && (d = this[i] >> p) > 0) {
	        m = true;
	        r = int2char(d);
	      }

	      while (i >= 0) {
	        if (p < k) {
	          d = (this[i] & (1 << p) - 1) << k - p;
	          d |= this[--i] >> (p += this.DB - k);
	        } else {
	          d = this[i] >> (p -= k) & km;

	          if (p <= 0) {
	            p += this.DB;
	            --i;
	          }
	        }

	        if (d > 0) {
	          m = true;
	        }

	        if (m) {
	          r += int2char(d);
	        }
	      }
	    }

	    return m ? r : "0";
	  }; // BigInteger.prototype.negate = bnNegate;
	  // (public) -this


	  BigInteger.prototype.negate = function () {
	    var r = nbi();
	    BigInteger.ZERO.subTo(this, r);
	    return r;
	  }; // BigInteger.prototype.abs = bnAbs;
	  // (public) |this|


	  BigInteger.prototype.abs = function () {
	    return this.s < 0 ? this.negate() : this;
	  }; // BigInteger.prototype.compareTo = bnCompareTo;
	  // (public) return + if this > a, - if this < a, 0 if equal


	  BigInteger.prototype.compareTo = function (a) {
	    var r = this.s - a.s;

	    if (r != 0) {
	      return r;
	    }

	    var i = this.t;
	    r = i - a.t;

	    if (r != 0) {
	      return this.s < 0 ? -r : r;
	    }

	    while (--i >= 0) {
	      if ((r = this[i] - a[i]) != 0) {
	        return r;
	      }
	    }

	    return 0;
	  }; // BigInteger.prototype.bitLength = bnBitLength;
	  // (public) return the number of bits in "this"


	  BigInteger.prototype.bitLength = function () {
	    if (this.t <= 0) {
	      return 0;
	    }

	    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
	  }; // BigInteger.prototype.mod = bnMod;
	  // (public) this mod a


	  BigInteger.prototype.mod = function (a) {
	    var r = nbi();
	    this.abs().divRemTo(a, null, r);

	    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
	      a.subTo(r, r);
	    }

	    return r;
	  }; // BigInteger.prototype.modPowInt = bnModPowInt;
	  // (public) this^e % m, 0 <= e < 2^32


	  BigInteger.prototype.modPowInt = function (e, m) {
	    var z;

	    if (e < 256 || m.isEven()) {
	      z = new Classic(m);
	    } else {
	      z = new Montgomery(m);
	    }

	    return this.exp(e, z);
	  }; // BigInteger.prototype.clone = bnClone;
	  // (public)


	  BigInteger.prototype.clone = function () {
	    var r = nbi();
	    this.copyTo(r);
	    return r;
	  }; // BigInteger.prototype.intValue = bnIntValue;
	  // (public) return value as integer


	  BigInteger.prototype.intValue = function () {
	    if (this.s < 0) {
	      if (this.t == 1) {
	        return this[0] - this.DV;
	      } else if (this.t == 0) {
	        return -1;
	      }
	    } else if (this.t == 1) {
	      return this[0];
	    } else if (this.t == 0) {
	      return 0;
	    } // assumes 16 < DB < 32


	    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
	  }; // BigInteger.prototype.byteValue = bnByteValue;
	  // (public) return value as byte


	  BigInteger.prototype.byteValue = function () {
	    return this.t == 0 ? this.s : this[0] << 24 >> 24;
	  }; // BigInteger.prototype.shortValue = bnShortValue;
	  // (public) return value as short (assumes DB>=16)


	  BigInteger.prototype.shortValue = function () {
	    return this.t == 0 ? this.s : this[0] << 16 >> 16;
	  }; // BigInteger.prototype.signum = bnSigNum;
	  // (public) 0 if this == 0, 1 if this > 0


	  BigInteger.prototype.signum = function () {
	    if (this.s < 0) {
	      return -1;
	    } else if (this.t <= 0 || this.t == 1 && this[0] <= 0) {
	      return 0;
	    } else {
	      return 1;
	    }
	  }; // BigInteger.prototype.toByteArray = bnToByteArray;
	  // (public) convert to bigendian byte array


	  BigInteger.prototype.toByteArray = function () {
	    var i = this.t;
	    var r = [];
	    r[0] = this.s;
	    var p = this.DB - i * this.DB % 8;
	    var d;
	    var k = 0;

	    if (i-- > 0) {
	      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
	        r[k++] = d | this.s << this.DB - p;
	      }

	      while (i >= 0) {
	        if (p < 8) {
	          d = (this[i] & (1 << p) - 1) << 8 - p;
	          d |= this[--i] >> (p += this.DB - 8);
	        } else {
	          d = this[i] >> (p -= 8) & 0xff;

	          if (p <= 0) {
	            p += this.DB;
	            --i;
	          }
	        }

	        if ((d & 0x80) != 0) {
	          d |= -256;
	        }

	        if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
	          ++k;
	        }

	        if (k > 0 || d != this.s) {
	          r[k++] = d;
	        }
	      }
	    }

	    return r;
	  }; // BigInteger.prototype.equals = bnEquals;


	  BigInteger.prototype.equals = function (a) {
	    return this.compareTo(a) == 0;
	  }; // BigInteger.prototype.min = bnMin;


	  BigInteger.prototype.min = function (a) {
	    return this.compareTo(a) < 0 ? this : a;
	  }; // BigInteger.prototype.max = bnMax;


	  BigInteger.prototype.max = function (a) {
	    return this.compareTo(a) > 0 ? this : a;
	  }; // BigInteger.prototype.and = bnAnd;


	  BigInteger.prototype.and = function (a) {
	    var r = nbi();
	    this.bitwiseTo(a, op_and, r);
	    return r;
	  }; // BigInteger.prototype.or = bnOr;


	  BigInteger.prototype.or = function (a) {
	    var r = nbi();
	    this.bitwiseTo(a, op_or, r);
	    return r;
	  }; // BigInteger.prototype.xor = bnXor;


	  BigInteger.prototype.xor = function (a) {
	    var r = nbi();
	    this.bitwiseTo(a, op_xor, r);
	    return r;
	  }; // BigInteger.prototype.andNot = bnAndNot;


	  BigInteger.prototype.andNot = function (a) {
	    var r = nbi();
	    this.bitwiseTo(a, op_andnot, r);
	    return r;
	  }; // BigInteger.prototype.not = bnNot;
	  // (public) ~this


	  BigInteger.prototype.not = function () {
	    var r = nbi();

	    for (var i = 0; i < this.t; ++i) {
	      r[i] = this.DM & ~this[i];
	    }

	    r.t = this.t;
	    r.s = ~this.s;
	    return r;
	  }; // BigInteger.prototype.shiftLeft = bnShiftLeft;
	  // (public) this << n


	  BigInteger.prototype.shiftLeft = function (n) {
	    var r = nbi();

	    if (n < 0) {
	      this.rShiftTo(-n, r);
	    } else {
	      this.lShiftTo(n, r);
	    }

	    return r;
	  }; // BigInteger.prototype.shiftRight = bnShiftRight;
	  // (public) this >> n


	  BigInteger.prototype.shiftRight = function (n) {
	    var r = nbi();

	    if (n < 0) {
	      this.lShiftTo(-n, r);
	    } else {
	      this.rShiftTo(n, r);
	    }

	    return r;
	  }; // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	  // (public) returns index of lowest 1-bit (or -1 if none)


	  BigInteger.prototype.getLowestSetBit = function () {
	    for (var i = 0; i < this.t; ++i) {
	      if (this[i] != 0) {
	        return i * this.DB + lbit(this[i]);
	      }
	    }

	    if (this.s < 0) {
	      return this.t * this.DB;
	    }

	    return -1;
	  }; // BigInteger.prototype.bitCount = bnBitCount;
	  // (public) return number of set bits


	  BigInteger.prototype.bitCount = function () {
	    var r = 0;
	    var x = this.s & this.DM;

	    for (var i = 0; i < this.t; ++i) {
	      r += cbit(this[i] ^ x);
	    }

	    return r;
	  }; // BigInteger.prototype.testBit = bnTestBit;
	  // (public) true iff nth bit is set


	  BigInteger.prototype.testBit = function (n) {
	    var j = Math.floor(n / this.DB);

	    if (j >= this.t) {
	      return this.s != 0;
	    }

	    return (this[j] & 1 << n % this.DB) != 0;
	  }; // BigInteger.prototype.setBit = bnSetBit;
	  // (public) this | (1<<n)


	  BigInteger.prototype.setBit = function (n) {
	    return this.changeBit(n, op_or);
	  }; // BigInteger.prototype.clearBit = bnClearBit;
	  // (public) this & ~(1<<n)


	  BigInteger.prototype.clearBit = function (n) {
	    return this.changeBit(n, op_andnot);
	  }; // BigInteger.prototype.flipBit = bnFlipBit;
	  // (public) this ^ (1<<n)


	  BigInteger.prototype.flipBit = function (n) {
	    return this.changeBit(n, op_xor);
	  }; // BigInteger.prototype.add = bnAdd;
	  // (public) this + a


	  BigInteger.prototype.add = function (a) {
	    var r = nbi();
	    this.addTo(a, r);
	    return r;
	  }; // BigInteger.prototype.subtract = bnSubtract;
	  // (public) this - a


	  BigInteger.prototype.subtract = function (a) {
	    var r = nbi();
	    this.subTo(a, r);
	    return r;
	  }; // BigInteger.prototype.multiply = bnMultiply;
	  // (public) this * a


	  BigInteger.prototype.multiply = function (a) {
	    var r = nbi();
	    this.multiplyTo(a, r);
	    return r;
	  }; // BigInteger.prototype.divide = bnDivide;
	  // (public) this / a


	  BigInteger.prototype.divide = function (a) {
	    var r = nbi();
	    this.divRemTo(a, r, null);
	    return r;
	  }; // BigInteger.prototype.remainder = bnRemainder;
	  // (public) this % a


	  BigInteger.prototype.remainder = function (a) {
	    var r = nbi();
	    this.divRemTo(a, null, r);
	    return r;
	  }; // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	  // (public) [this/a,this%a]


	  BigInteger.prototype.divideAndRemainder = function (a) {
	    var q = nbi();
	    var r = nbi();
	    this.divRemTo(a, q, r);
	    return [q, r];
	  }; // BigInteger.prototype.modPow = bnModPow;
	  // (public) this^e % m (HAC 14.85)


	  BigInteger.prototype.modPow = function (e, m) {
	    var i = e.bitLength();
	    var k;
	    var r = nbv(1);
	    var z;

	    if (i <= 0) {
	      return r;
	    } else if (i < 18) {
	      k = 1;
	    } else if (i < 48) {
	      k = 3;
	    } else if (i < 144) {
	      k = 4;
	    } else if (i < 768) {
	      k = 5;
	    } else {
	      k = 6;
	    }

	    if (i < 8) {
	      z = new Classic(m);
	    } else if (m.isEven()) {
	      z = new Barrett(m);
	    } else {
	      z = new Montgomery(m);
	    } // precomputation


	    var g = [];
	    var n = 3;
	    var k1 = k - 1;
	    var km = (1 << k) - 1;
	    g[1] = z.convert(this);

	    if (k > 1) {
	      var g2 = nbi();
	      z.sqrTo(g[1], g2);

	      while (n <= km) {
	        g[n] = nbi();
	        z.mulTo(g2, g[n - 2], g[n]);
	        n += 2;
	      }
	    }

	    var j = e.t - 1;
	    var w;
	    var is1 = true;
	    var r2 = nbi();
	    var t;
	    i = nbits(e[j]) - 1;

	    while (j >= 0) {
	      if (i >= k1) {
	        w = e[j] >> i - k1 & km;
	      } else {
	        w = (e[j] & (1 << i + 1) - 1) << k1 - i;

	        if (j > 0) {
	          w |= e[j - 1] >> this.DB + i - k1;
	        }
	      }

	      n = k;

	      while ((w & 1) == 0) {
	        w >>= 1;
	        --n;
	      }

	      if ((i -= n) < 0) {
	        i += this.DB;
	        --j;
	      }

	      if (is1) {
	        // ret == 1, don't bother squaring or multiplying it
	        g[w].copyTo(r);
	        is1 = false;
	      } else {
	        while (n > 1) {
	          z.sqrTo(r, r2);
	          z.sqrTo(r2, r);
	          n -= 2;
	        }

	        if (n > 0) {
	          z.sqrTo(r, r2);
	        } else {
	          t = r;
	          r = r2;
	          r2 = t;
	        }

	        z.mulTo(r2, g[w], r);
	      }

	      while (j >= 0 && (e[j] & 1 << i) == 0) {
	        z.sqrTo(r, r2);
	        t = r;
	        r = r2;
	        r2 = t;

	        if (--i < 0) {
	          i = this.DB - 1;
	          --j;
	        }
	      }
	    }

	    return z.revert(r);
	  }; // BigInteger.prototype.modInverse = bnModInverse;
	  // (public) 1/this % m (HAC 14.61)


	  BigInteger.prototype.modInverse = function (m) {
	    var ac = m.isEven();

	    if (this.isEven() && ac || m.signum() == 0) {
	      return BigInteger.ZERO;
	    }

	    var u = m.clone();
	    var v = this.clone();
	    var a = nbv(1);
	    var b = nbv(0);
	    var c = nbv(0);
	    var d = nbv(1);

	    while (u.signum() != 0) {
	      while (u.isEven()) {
	        u.rShiftTo(1, u);

	        if (ac) {
	          if (!a.isEven() || !b.isEven()) {
	            a.addTo(this, a);
	            b.subTo(m, b);
	          }

	          a.rShiftTo(1, a);
	        } else if (!b.isEven()) {
	          b.subTo(m, b);
	        }

	        b.rShiftTo(1, b);
	      }

	      while (v.isEven()) {
	        v.rShiftTo(1, v);

	        if (ac) {
	          if (!c.isEven() || !d.isEven()) {
	            c.addTo(this, c);
	            d.subTo(m, d);
	          }

	          c.rShiftTo(1, c);
	        } else if (!d.isEven()) {
	          d.subTo(m, d);
	        }

	        d.rShiftTo(1, d);
	      }

	      if (u.compareTo(v) >= 0) {
	        u.subTo(v, u);

	        if (ac) {
	          a.subTo(c, a);
	        }

	        b.subTo(d, b);
	      } else {
	        v.subTo(u, v);

	        if (ac) {
	          c.subTo(a, c);
	        }

	        d.subTo(b, d);
	      }
	    }

	    if (v.compareTo(BigInteger.ONE) != 0) {
	      return BigInteger.ZERO;
	    }

	    if (d.compareTo(m) >= 0) {
	      return d.subtract(m);
	    }

	    if (d.signum() < 0) {
	      d.addTo(m, d);
	    } else {
	      return d;
	    }

	    if (d.signum() < 0) {
	      return d.add(m);
	    } else {
	      return d;
	    }
	  }; // BigInteger.prototype.pow = bnPow;
	  // (public) this^e


	  BigInteger.prototype.pow = function (e) {
	    return this.exp(e, new NullExp());
	  }; // BigInteger.prototype.gcd = bnGCD;
	  // (public) gcd(this,a) (HAC 14.54)


	  BigInteger.prototype.gcd = function (a) {
	    var x = this.s < 0 ? this.negate() : this.clone();
	    var y = a.s < 0 ? a.negate() : a.clone();

	    if (x.compareTo(y) < 0) {
	      var t = x;
	      x = y;
	      y = t;
	    }

	    var i = x.getLowestSetBit();
	    var g = y.getLowestSetBit();

	    if (g < 0) {
	      return x;
	    }

	    if (i < g) {
	      g = i;
	    }

	    if (g > 0) {
	      x.rShiftTo(g, x);
	      y.rShiftTo(g, y);
	    }

	    while (x.signum() > 0) {
	      if ((i = x.getLowestSetBit()) > 0) {
	        x.rShiftTo(i, x);
	      }

	      if ((i = y.getLowestSetBit()) > 0) {
	        y.rShiftTo(i, y);
	      }

	      if (x.compareTo(y) >= 0) {
	        x.subTo(y, x);
	        x.rShiftTo(1, x);
	      } else {
	        y.subTo(x, y);
	        y.rShiftTo(1, y);
	      }
	    }

	    if (g > 0) {
	      y.lShiftTo(g, y);
	    }

	    return y;
	  }; // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
	  // (public) test primality with certainty >= 1-.5^t


	  BigInteger.prototype.isProbablePrime = function (t) {
	    var i;
	    var x = this.abs();

	    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
	      for (i = 0; i < lowprimes.length; ++i) {
	        if (x[0] == lowprimes[i]) {
	          return true;
	        }
	      }

	      return false;
	    }

	    if (x.isEven()) {
	      return false;
	    }

	    i = 1;

	    while (i < lowprimes.length) {
	      var m = lowprimes[i];
	      var j = i + 1;

	      while (j < lowprimes.length && m < lplim) {
	        m *= lowprimes[j++];
	      }

	      m = x.modInt(m);

	      while (i < j) {
	        if (m % lowprimes[i++] == 0) {
	          return false;
	        }
	      }
	    }

	    return x.millerRabin(t);
	  }; //#endregion PUBLIC
	  //#region PROTECTED
	  // BigInteger.prototype.copyTo = bnpCopyTo;
	  // (protected) copy this to r


	  BigInteger.prototype.copyTo = function (r) {
	    for (var i = this.t - 1; i >= 0; --i) {
	      r[i] = this[i];
	    }

	    r.t = this.t;
	    r.s = this.s;
	  }; // BigInteger.prototype.fromInt = bnpFromInt;
	  // (protected) set from integer value x, -DV <= x < DV


	  BigInteger.prototype.fromInt = function (x) {
	    this.t = 1;
	    this.s = x < 0 ? -1 : 0;

	    if (x > 0) {
	      this[0] = x;
	    } else if (x < -1) {
	      this[0] = x + this.DV;
	    } else {
	      this.t = 0;
	    }
	  }; // BigInteger.prototype.fromString = bnpFromString;
	  // (protected) set from string and radix


	  BigInteger.prototype.fromString = function (s, b) {
	    var k;

	    if (b == 16) {
	      k = 4;
	    } else if (b == 8) {
	      k = 3;
	    } else if (b == 256) {
	      k = 8;
	      /* byte array */
	    } else if (b == 2) {
	      k = 1;
	    } else if (b == 32) {
	      k = 5;
	    } else if (b == 4) {
	      k = 2;
	    } else {
	      this.fromRadix(s, b);
	      return;
	    }

	    this.t = 0;
	    this.s = 0;
	    var i = s.length;
	    var mi = false;
	    var sh = 0;

	    while (--i >= 0) {
	      var x = k == 8 ? +s[i] & 0xff : intAt(s, i);

	      if (x < 0) {
	        if (s.charAt(i) == "-") {
	          mi = true;
	        }

	        continue;
	      }

	      mi = false;

	      if (sh == 0) {
	        this[this.t++] = x;
	      } else if (sh + k > this.DB) {
	        this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
	        this[this.t++] = x >> this.DB - sh;
	      } else {
	        this[this.t - 1] |= x << sh;
	      }

	      sh += k;

	      if (sh >= this.DB) {
	        sh -= this.DB;
	      }
	    }

	    if (k == 8 && (+s[0] & 0x80) != 0) {
	      this.s = -1;

	      if (sh > 0) {
	        this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
	      }
	    }

	    this.clamp();

	    if (mi) {
	      BigInteger.ZERO.subTo(this, this);
	    }
	  }; // BigInteger.prototype.clamp = bnpClamp;
	  // (protected) clamp off excess high words


	  BigInteger.prototype.clamp = function () {
	    var c = this.s & this.DM;

	    while (this.t > 0 && this[this.t - 1] == c) {
	      --this.t;
	    }
	  }; // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	  // (protected) r = this << n*DB


	  BigInteger.prototype.dlShiftTo = function (n, r) {
	    var i;

	    for (i = this.t - 1; i >= 0; --i) {
	      r[i + n] = this[i];
	    }

	    for (i = n - 1; i >= 0; --i) {
	      r[i] = 0;
	    }

	    r.t = this.t + n;
	    r.s = this.s;
	  }; // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	  // (protected) r = this >> n*DB


	  BigInteger.prototype.drShiftTo = function (n, r) {
	    for (var i = n; i < this.t; ++i) {
	      r[i - n] = this[i];
	    }

	    r.t = Math.max(this.t - n, 0);
	    r.s = this.s;
	  }; // BigInteger.prototype.lShiftTo = bnpLShiftTo;
	  // (protected) r = this << n


	  BigInteger.prototype.lShiftTo = function (n, r) {
	    var bs = n % this.DB;
	    var cbs = this.DB - bs;
	    var bm = (1 << cbs) - 1;
	    var ds = Math.floor(n / this.DB);
	    var c = this.s << bs & this.DM;

	    for (var i = this.t - 1; i >= 0; --i) {
	      r[i + ds + 1] = this[i] >> cbs | c;
	      c = (this[i] & bm) << bs;
	    }

	    for (var i = ds - 1; i >= 0; --i) {
	      r[i] = 0;
	    }

	    r[ds] = c;
	    r.t = this.t + ds + 1;
	    r.s = this.s;
	    r.clamp();
	  }; // BigInteger.prototype.rShiftTo = bnpRShiftTo;
	  // (protected) r = this >> n


	  BigInteger.prototype.rShiftTo = function (n, r) {
	    r.s = this.s;
	    var ds = Math.floor(n / this.DB);

	    if (ds >= this.t) {
	      r.t = 0;
	      return;
	    }

	    var bs = n % this.DB;
	    var cbs = this.DB - bs;
	    var bm = (1 << bs) - 1;
	    r[0] = this[ds] >> bs;

	    for (var i = ds + 1; i < this.t; ++i) {
	      r[i - ds - 1] |= (this[i] & bm) << cbs;
	      r[i - ds] = this[i] >> bs;
	    }

	    if (bs > 0) {
	      r[this.t - ds - 1] |= (this.s & bm) << cbs;
	    }

	    r.t = this.t - ds;
	    r.clamp();
	  }; // BigInteger.prototype.subTo = bnpSubTo;
	  // (protected) r = this - a


	  BigInteger.prototype.subTo = function (a, r) {
	    var i = 0;
	    var c = 0;
	    var m = Math.min(a.t, this.t);

	    while (i < m) {
	      c += this[i] - a[i];
	      r[i++] = c & this.DM;
	      c >>= this.DB;
	    }

	    if (a.t < this.t) {
	      c -= a.s;

	      while (i < this.t) {
	        c += this[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }

	      c += this.s;
	    } else {
	      c += this.s;

	      while (i < a.t) {
	        c -= a[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }

	      c -= a.s;
	    }

	    r.s = c < 0 ? -1 : 0;

	    if (c < -1) {
	      r[i++] = this.DV + c;
	    } else if (c > 0) {
	      r[i++] = c;
	    }

	    r.t = i;
	    r.clamp();
	  }; // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	  // (protected) r = this * a, r != this,a (HAC 14.12)
	  // "this" should be the larger one if appropriate.


	  BigInteger.prototype.multiplyTo = function (a, r) {
	    var x = this.abs();
	    var y = a.abs();
	    var i = x.t;
	    r.t = i + y.t;

	    while (--i >= 0) {
	      r[i] = 0;
	    }

	    for (i = 0; i < y.t; ++i) {
	      r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
	    }

	    r.s = 0;
	    r.clamp();

	    if (this.s != a.s) {
	      BigInteger.ZERO.subTo(r, r);
	    }
	  }; // BigInteger.prototype.squareTo = bnpSquareTo;
	  // (protected) r = this^2, r != this (HAC 14.16)


	  BigInteger.prototype.squareTo = function (r) {
	    var x = this.abs();
	    var i = r.t = 2 * x.t;

	    while (--i >= 0) {
	      r[i] = 0;
	    }

	    for (i = 0; i < x.t - 1; ++i) {
	      var c = x.am(i, x[i], r, 2 * i, 0, 1);

	      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
	        r[i + x.t] -= x.DV;
	        r[i + x.t + 1] = 1;
	      }
	    }

	    if (r.t > 0) {
	      r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
	    }

	    r.s = 0;
	    r.clamp();
	  }; // BigInteger.prototype.divRemTo = bnpDivRemTo;
	  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
	  // r != q, this != m.  q or r may be null.


	  BigInteger.prototype.divRemTo = function (m, q, r) {
	    var pm = m.abs();

	    if (pm.t <= 0) {
	      return;
	    }

	    var pt = this.abs();

	    if (pt.t < pm.t) {
	      if (q != null) {
	        q.fromInt(0);
	      }

	      if (r != null) {
	        this.copyTo(r);
	      }

	      return;
	    }

	    if (r == null) {
	      r = nbi();
	    }

	    var y = nbi();
	    var ts = this.s;
	    var ms = m.s;
	    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus

	    if (nsh > 0) {
	      pm.lShiftTo(nsh, y);
	      pt.lShiftTo(nsh, r);
	    } else {
	      pm.copyTo(y);
	      pt.copyTo(r);
	    }

	    var ys = y.t;
	    var y0 = y[ys - 1];

	    if (y0 == 0) {
	      return;
	    }

	    var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
	    var d1 = this.FV / yt;
	    var d2 = (1 << this.F1) / yt;
	    var e = 1 << this.F2;
	    var i = r.t;
	    var j = i - ys;
	    var t = q == null ? nbi() : q;
	    y.dlShiftTo(j, t);

	    if (r.compareTo(t) >= 0) {
	      r[r.t++] = 1;
	      r.subTo(t, r);
	    }

	    BigInteger.ONE.dlShiftTo(ys, t);
	    t.subTo(y, y); // "negative" y so we can replace sub with am later

	    while (y.t < ys) {
	      y[y.t++] = 0;
	    }

	    while (--j >= 0) {
	      // Estimate quotient digit
	      var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);

	      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
	        // Try it out
	        y.dlShiftTo(j, t);
	        r.subTo(t, r);

	        while (r[i] < --qd) {
	          r.subTo(t, r);
	        }
	      }
	    }

	    if (q != null) {
	      r.drShiftTo(ys, q);

	      if (ts != ms) {
	        BigInteger.ZERO.subTo(q, q);
	      }
	    }

	    r.t = ys;
	    r.clamp();

	    if (nsh > 0) {
	      r.rShiftTo(nsh, r);
	    } // Denormalize remainder


	    if (ts < 0) {
	      BigInteger.ZERO.subTo(r, r);
	    }
	  }; // BigInteger.prototype.invDigit = bnpInvDigit;
	  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
	  // justification:
	  //         xy == 1 (mod m)
	  //         xy =  1+km
	  //   xy(2-xy) = (1+km)(1-km)
	  // x[y(2-xy)] = 1-k^2m^2
	  // x[y(2-xy)] == 1 (mod m^2)
	  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
	  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
	  // JS multiply "overflows" differently from C/C++, so care is needed here.


	  BigInteger.prototype.invDigit = function () {
	    if (this.t < 1) {
	      return 0;
	    }

	    var x = this[0];

	    if ((x & 1) == 0) {
	      return 0;
	    }

	    var y = x & 3; // y == 1/x mod 2^2

	    y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4

	    y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8

	    y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16
	    // last step - calculate inverse mod DV directly;
	    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints

	    y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits
	    // we really want the negative inverse, and -DV < y < DV

	    return y > 0 ? this.DV - y : -y;
	  }; // BigInteger.prototype.isEven = bnpIsEven;
	  // (protected) true iff this is even


	  BigInteger.prototype.isEven = function () {
	    return (this.t > 0 ? this[0] & 1 : this.s) == 0;
	  }; // BigInteger.prototype.exp = bnpExp;
	  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)


	  BigInteger.prototype.exp = function (e, z) {
	    if (e > 0xffffffff || e < 1) {
	      return BigInteger.ONE;
	    }

	    var r = nbi();
	    var r2 = nbi();
	    var g = z.convert(this);
	    var i = nbits(e) - 1;
	    g.copyTo(r);

	    while (--i >= 0) {
	      z.sqrTo(r, r2);

	      if ((e & 1 << i) > 0) {
	        z.mulTo(r2, g, r);
	      } else {
	        var t = r;
	        r = r2;
	        r2 = t;
	      }
	    }

	    return z.revert(r);
	  }; // BigInteger.prototype.chunkSize = bnpChunkSize;
	  // (protected) return x s.t. r^x < DV


	  BigInteger.prototype.chunkSize = function (r) {
	    return Math.floor(Math.LN2 * this.DB / Math.log(r));
	  }; // BigInteger.prototype.toRadix = bnpToRadix;
	  // (protected) convert to radix string


	  BigInteger.prototype.toRadix = function (b) {
	    if (b == null) {
	      b = 10;
	    }

	    if (this.signum() == 0 || b < 2 || b > 36) {
	      return "0";
	    }

	    var cs = this.chunkSize(b);
	    var a = Math.pow(b, cs);
	    var d = nbv(a);
	    var y = nbi();
	    var z = nbi();
	    var r = "";
	    this.divRemTo(d, y, z);

	    while (y.signum() > 0) {
	      r = (a + z.intValue()).toString(b).substr(1) + r;
	      y.divRemTo(d, y, z);
	    }

	    return z.intValue().toString(b) + r;
	  }; // BigInteger.prototype.fromRadix = bnpFromRadix;
	  // (protected) convert from radix string


	  BigInteger.prototype.fromRadix = function (s, b) {
	    this.fromInt(0);

	    if (b == null) {
	      b = 10;
	    }

	    var cs = this.chunkSize(b);
	    var d = Math.pow(b, cs);
	    var mi = false;
	    var j = 0;
	    var w = 0;

	    for (var i = 0; i < s.length; ++i) {
	      var x = intAt(s, i);

	      if (x < 0) {
	        if (s.charAt(i) == "-" && this.signum() == 0) {
	          mi = true;
	        }

	        continue;
	      }

	      w = b * w + x;

	      if (++j >= cs) {
	        this.dMultiply(d);
	        this.dAddOffset(w, 0);
	        j = 0;
	        w = 0;
	      }
	    }

	    if (j > 0) {
	      this.dMultiply(Math.pow(b, j));
	      this.dAddOffset(w, 0);
	    }

	    if (mi) {
	      BigInteger.ZERO.subTo(this, this);
	    }
	  }; // BigInteger.prototype.fromNumber = bnpFromNumber;
	  // (protected) alternate constructor


	  BigInteger.prototype.fromNumber = function (a, b, c) {
	    if ("number" == typeof b) {
	      // new BigInteger(int,int,RNG)
	      if (a < 2) {
	        this.fromInt(1);
	      } else {
	        this.fromNumber(a, c);

	        if (!this.testBit(a - 1)) {
	          // force MSB set
	          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
	        }

	        if (this.isEven()) {
	          this.dAddOffset(1, 0);
	        } // force odd


	        while (!this.isProbablePrime(b)) {
	          this.dAddOffset(2, 0);

	          if (this.bitLength() > a) {
	            this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
	          }
	        }
	      }
	    } else {
	      // new BigInteger(int,RNG)
	      var x = [];
	      var t = a & 7;
	      x.length = (a >> 3) + 1;
	      b.nextBytes(x);

	      if (t > 0) {
	        x[0] &= (1 << t) - 1;
	      } else {
	        x[0] = 0;
	      }

	      this.fromString(x, 256);
	    }
	  }; // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	  // (protected) r = this op a (bitwise)


	  BigInteger.prototype.bitwiseTo = function (a, op, r) {
	    var i;
	    var f;
	    var m = Math.min(a.t, this.t);

	    for (i = 0; i < m; ++i) {
	      r[i] = op(this[i], a[i]);
	    }

	    if (a.t < this.t) {
	      f = a.s & this.DM;

	      for (i = m; i < this.t; ++i) {
	        r[i] = op(this[i], f);
	      }

	      r.t = this.t;
	    } else {
	      f = this.s & this.DM;

	      for (i = m; i < a.t; ++i) {
	        r[i] = op(f, a[i]);
	      }

	      r.t = a.t;
	    }

	    r.s = op(this.s, a.s);
	    r.clamp();
	  }; // BigInteger.prototype.changeBit = bnpChangeBit;
	  // (protected) this op (1<<n)


	  BigInteger.prototype.changeBit = function (n, op) {
	    var r = BigInteger.ONE.shiftLeft(n);
	    this.bitwiseTo(r, op, r);
	    return r;
	  }; // BigInteger.prototype.addTo = bnpAddTo;
	  // (protected) r = this + a


	  BigInteger.prototype.addTo = function (a, r) {
	    var i = 0;
	    var c = 0;
	    var m = Math.min(a.t, this.t);

	    while (i < m) {
	      c += this[i] + a[i];
	      r[i++] = c & this.DM;
	      c >>= this.DB;
	    }

	    if (a.t < this.t) {
	      c += a.s;

	      while (i < this.t) {
	        c += this[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }

	      c += this.s;
	    } else {
	      c += this.s;

	      while (i < a.t) {
	        c += a[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }

	      c += a.s;
	    }

	    r.s = c < 0 ? -1 : 0;

	    if (c > 0) {
	      r[i++] = c;
	    } else if (c < -1) {
	      r[i++] = this.DV + c;
	    }

	    r.t = i;
	    r.clamp();
	  }; // BigInteger.prototype.dMultiply = bnpDMultiply;
	  // (protected) this *= n, this >= 0, 1 < n < DV


	  BigInteger.prototype.dMultiply = function (n) {
	    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
	    ++this.t;
	    this.clamp();
	  }; // BigInteger.prototype.dAddOffset = bnpDAddOffset;
	  // (protected) this += n << w words, this >= 0


	  BigInteger.prototype.dAddOffset = function (n, w) {
	    if (n == 0) {
	      return;
	    }

	    while (this.t <= w) {
	      this[this.t++] = 0;
	    }

	    this[w] += n;

	    while (this[w] >= this.DV) {
	      this[w] -= this.DV;

	      if (++w >= this.t) {
	        this[this.t++] = 0;
	      }

	      ++this[w];
	    }
	  }; // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	  // (protected) r = lower n words of "this * a", a.t <= n
	  // "this" should be the larger one if appropriate.


	  BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
	    var i = Math.min(this.t + a.t, n);
	    r.s = 0; // assumes a,this >= 0

	    r.t = i;

	    while (i > 0) {
	      r[--i] = 0;
	    }

	    for (var j = r.t - this.t; i < j; ++i) {
	      r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
	    }

	    for (var j = Math.min(a.t, n); i < j; ++i) {
	      this.am(0, a[i], r, i, 0, n - i);
	    }

	    r.clamp();
	  }; // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	  // (protected) r = "this * a" without lower n words, n > 0
	  // "this" should be the larger one if appropriate.


	  BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
	    --n;
	    var i = r.t = this.t + a.t - n;
	    r.s = 0; // assumes a,this >= 0

	    while (--i >= 0) {
	      r[i] = 0;
	    }

	    for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
	      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
	    }

	    r.clamp();
	    r.drShiftTo(1, r);
	  }; // BigInteger.prototype.modInt = bnpModInt;
	  // (protected) this % n, n < 2^26


	  BigInteger.prototype.modInt = function (n) {
	    if (n <= 0) {
	      return 0;
	    }

	    var d = this.DV % n;
	    var r = this.s < 0 ? n - 1 : 0;

	    if (this.t > 0) {
	      if (d == 0) {
	        r = this[0] % n;
	      } else {
	        for (var i = this.t - 1; i >= 0; --i) {
	          r = (d * r + this[i]) % n;
	        }
	      }
	    }

	    return r;
	  }; // BigInteger.prototype.millerRabin = bnpMillerRabin;
	  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)


	  BigInteger.prototype.millerRabin = function (t) {
	    var n1 = this.subtract(BigInteger.ONE);
	    var k = n1.getLowestSetBit();

	    if (k <= 0) {
	      return false;
	    }

	    var r = n1.shiftRight(k);
	    t = t + 1 >> 1;

	    if (t > lowprimes.length) {
	      t = lowprimes.length;
	    }

	    var a = nbi();

	    for (var i = 0; i < t; ++i) {
	      // Pick bases at random, instead of starting at 2
	      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
	      var y = a.modPow(r, this);

	      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
	        var j = 1;

	        while (j++ < k && y.compareTo(n1) != 0) {
	          y = y.modPowInt(2, this);

	          if (y.compareTo(BigInteger.ONE) == 0) {
	            return false;
	          }
	        }

	        if (y.compareTo(n1) != 0) {
	          return false;
	        }
	      }
	    }

	    return true;
	  }; // BigInteger.prototype.square = bnSquare;
	  // (public) this^2


	  BigInteger.prototype.square = function () {
	    var r = nbi();
	    this.squareTo(r);
	    return r;
	  }; //#region ASYNC
	  // Public API method


	  BigInteger.prototype.gcda = function (a, callback) {
	    var x = this.s < 0 ? this.negate() : this.clone();
	    var y = a.s < 0 ? a.negate() : a.clone();

	    if (x.compareTo(y) < 0) {
	      var t = x;
	      x = y;
	      y = t;
	    }

	    var i = x.getLowestSetBit();
	    var g = y.getLowestSetBit();

	    if (g < 0) {
	      callback(x);
	      return;
	    }

	    if (i < g) {
	      g = i;
	    }

	    if (g > 0) {
	      x.rShiftTo(g, x);
	      y.rShiftTo(g, y);
	    } // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.


	    var gcda1 = function gcda1() {
	      if ((i = x.getLowestSetBit()) > 0) {
	        x.rShiftTo(i, x);
	      }

	      if ((i = y.getLowestSetBit()) > 0) {
	        y.rShiftTo(i, y);
	      }

	      if (x.compareTo(y) >= 0) {
	        x.subTo(y, x);
	        x.rShiftTo(1, x);
	      } else {
	        y.subTo(x, y);
	        y.rShiftTo(1, y);
	      }

	      if (!(x.signum() > 0)) {
	        if (g > 0) {
	          y.lShiftTo(g, y);
	        }

	        setTimeout(function () {
	          callback(y);
	        }, 0); // escape
	      } else {
	        setTimeout(gcda1, 0);
	      }
	    };

	    setTimeout(gcda1, 10);
	  }; // (protected) alternate constructor


	  BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
	    if ("number" == typeof b) {
	      if (a < 2) {
	        this.fromInt(1);
	      } else {
	        this.fromNumber(a, c);

	        if (!this.testBit(a - 1)) {
	          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
	        }

	        if (this.isEven()) {
	          this.dAddOffset(1, 0);
	        }

	        var bnp_1 = this;

	        var bnpfn1_1 = function bnpfn1_1() {
	          bnp_1.dAddOffset(2, 0);

	          if (bnp_1.bitLength() > a) {
	            bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
	          }

	          if (bnp_1.isProbablePrime(b)) {
	            setTimeout(function () {
	              callback();
	            }, 0); // escape
	          } else {
	            setTimeout(bnpfn1_1, 0);
	          }
	        };

	        setTimeout(bnpfn1_1, 0);
	      }
	    } else {
	      var x = [];
	      var t = a & 7;
	      x.length = (a >> 3) + 1;
	      b.nextBytes(x);

	      if (t > 0) {
	        x[0] &= (1 << t) - 1;
	      } else {
	        x[0] = 0;
	      }

	      this.fromString(x, 256);
	    }
	  };

	  return BigInteger;
	}();
	//#region NullExp

	var NullExp =
	/** @class */
	function () {
	  function NullExp() {} // NullExp.prototype.convert = nNop;


	  NullExp.prototype.convert = function (x) {
	    return x;
	  }; // NullExp.prototype.revert = nNop;


	  NullExp.prototype.revert = function (x) {
	    return x;
	  }; // NullExp.prototype.mulTo = nMulTo;


	  NullExp.prototype.mulTo = function (x, y, r) {
	    x.multiplyTo(y, r);
	  }; // NullExp.prototype.sqrTo = nSqrTo;


	  NullExp.prototype.sqrTo = function (x, r) {
	    x.squareTo(r);
	  };

	  return NullExp;
	}(); // Modular reduction using "classic" algorithm


	var Classic =
	/** @class */
	function () {
	  function Classic(m) {
	    this.m = m;
	  } // Classic.prototype.convert = cConvert;


	  Classic.prototype.convert = function (x) {
	    if (x.s < 0 || x.compareTo(this.m) >= 0) {
	      return x.mod(this.m);
	    } else {
	      return x;
	    }
	  }; // Classic.prototype.revert = cRevert;


	  Classic.prototype.revert = function (x) {
	    return x;
	  }; // Classic.prototype.reduce = cReduce;


	  Classic.prototype.reduce = function (x) {
	    x.divRemTo(this.m, null, x);
	  }; // Classic.prototype.mulTo = cMulTo;


	  Classic.prototype.mulTo = function (x, y, r) {
	    x.multiplyTo(y, r);
	    this.reduce(r);
	  }; // Classic.prototype.sqrTo = cSqrTo;


	  Classic.prototype.sqrTo = function (x, r) {
	    x.squareTo(r);
	    this.reduce(r);
	  };

	  return Classic;
	}(); //#endregion
	//#region Montgomery
	// Montgomery reduction


	var Montgomery =
	/** @class */
	function () {
	  function Montgomery(m) {
	    this.m = m;
	    this.mp = m.invDigit();
	    this.mpl = this.mp & 0x7fff;
	    this.mph = this.mp >> 15;
	    this.um = (1 << m.DB - 15) - 1;
	    this.mt2 = 2 * m.t;
	  } // Montgomery.prototype.convert = montConvert;
	  // xR mod m


	  Montgomery.prototype.convert = function (x) {
	    var r = nbi();
	    x.abs().dlShiftTo(this.m.t, r);
	    r.divRemTo(this.m, null, r);

	    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
	      this.m.subTo(r, r);
	    }

	    return r;
	  }; // Montgomery.prototype.revert = montRevert;
	  // x/R mod m


	  Montgomery.prototype.revert = function (x) {
	    var r = nbi();
	    x.copyTo(r);
	    this.reduce(r);
	    return r;
	  }; // Montgomery.prototype.reduce = montReduce;
	  // x = x/R mod m (HAC 14.32)


	  Montgomery.prototype.reduce = function (x) {
	    while (x.t <= this.mt2) {
	      // pad x so am has enough room later
	      x[x.t++] = 0;
	    }

	    for (var i = 0; i < this.m.t; ++i) {
	      // faster way of calculating u0 = x[i]*mp mod DV
	      var j = x[i] & 0x7fff;
	      var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM; // use am to combine the multiply-shift-add into one call

	      j = i + this.m.t;
	      x[j] += this.m.am(0, u0, x, i, 0, this.m.t); // propagate carry

	      while (x[j] >= x.DV) {
	        x[j] -= x.DV;
	        x[++j]++;
	      }
	    }

	    x.clamp();
	    x.drShiftTo(this.m.t, x);

	    if (x.compareTo(this.m) >= 0) {
	      x.subTo(this.m, x);
	    }
	  }; // Montgomery.prototype.mulTo = montMulTo;
	  // r = "xy/R mod m"; x,y != r


	  Montgomery.prototype.mulTo = function (x, y, r) {
	    x.multiplyTo(y, r);
	    this.reduce(r);
	  }; // Montgomery.prototype.sqrTo = montSqrTo;
	  // r = "x^2/R mod m"; x != r


	  Montgomery.prototype.sqrTo = function (x, r) {
	    x.squareTo(r);
	    this.reduce(r);
	  };

	  return Montgomery;
	}(); //#endregion Montgomery
	//#region Barrett
	// Barrett modular reduction


	var Barrett =
	/** @class */
	function () {
	  function Barrett(m) {
	    this.m = m; // setup Barrett

	    this.r2 = nbi();
	    this.q3 = nbi();
	    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
	    this.mu = this.r2.divide(m);
	  } // Barrett.prototype.convert = barrettConvert;


	  Barrett.prototype.convert = function (x) {
	    if (x.s < 0 || x.t > 2 * this.m.t) {
	      return x.mod(this.m);
	    } else if (x.compareTo(this.m) < 0) {
	      return x;
	    } else {
	      var r = nbi();
	      x.copyTo(r);
	      this.reduce(r);
	      return r;
	    }
	  }; // Barrett.prototype.revert = barrettRevert;


	  Barrett.prototype.revert = function (x) {
	    return x;
	  }; // Barrett.prototype.reduce = barrettReduce;
	  // x = x mod m (HAC 14.42)


	  Barrett.prototype.reduce = function (x) {
	    x.drShiftTo(this.m.t - 1, this.r2);

	    if (x.t > this.m.t + 1) {
	      x.t = this.m.t + 1;
	      x.clamp();
	    }

	    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
	    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);

	    while (x.compareTo(this.r2) < 0) {
	      x.dAddOffset(1, this.m.t + 1);
	    }

	    x.subTo(this.r2, x);

	    while (x.compareTo(this.m) >= 0) {
	      x.subTo(this.m, x);
	    }
	  }; // Barrett.prototype.mulTo = barrettMulTo;
	  // r = x*y mod m; x,y != r


	  Barrett.prototype.mulTo = function (x, y, r) {
	    x.multiplyTo(y, r);
	    this.reduce(r);
	  }; // Barrett.prototype.sqrTo = barrettSqrTo;
	  // r = x^2 mod m; x != r


	  Barrett.prototype.sqrTo = function (x, r) {
	    x.squareTo(r);
	    this.reduce(r);
	  };

	  return Barrett;
	}(); //#endregion
	//#endregion REDUCERS
	// return new, unset BigInteger


	function nbi() {
	  return new BigInteger(null);
	}
	function parseBigInt(str, r) {
	  return new BigInteger(str, r);
	} // am: Compute w_j += (x*this_i), propagate carries,
	// c is initial carry, returns final carry.
	// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
	// We need to select the fastest one that works in this environment.

	var inBrowser = typeof navigator !== "undefined";

	if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
	  // am2 avoids a big mult-and-extract completely.
	  // Max digit bits should be <= 30 because we do bitwise ops
	  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
	  BigInteger.prototype.am = function am2(i, x, w, j, c, n) {
	    var xl = x & 0x7fff;
	    var xh = x >> 15;

	    while (--n >= 0) {
	      var l = this[i] & 0x7fff;
	      var h = this[i++] >> 15;
	      var m = xh * l + h * xl;
	      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
	      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
	      w[j++] = l & 0x3fffffff;
	    }

	    return c;
	  };

	  dbits = 30;
	} else if (inBrowser && j_lm && navigator.appName != "Netscape") {
	  // am1: use a single mult and divide to get the high bits,
	  // max digit bits should be 26 because
	  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
	  BigInteger.prototype.am = function am1(i, x, w, j, c, n) {
	    while (--n >= 0) {
	      var v = x * this[i++] + w[j] + c;
	      c = Math.floor(v / 0x4000000);
	      w[j++] = v & 0x3ffffff;
	    }

	    return c;
	  };

	  dbits = 26;
	} else {
	  // Mozilla/Netscape seems to prefer am3
	  // Alternately, set max digit bits to 28 since some
	  // browsers slow down when dealing with 32-bit numbers.
	  BigInteger.prototype.am = function am3(i, x, w, j, c, n) {
	    var xl = x & 0x3fff;
	    var xh = x >> 14;

	    while (--n >= 0) {
	      var l = this[i] & 0x3fff;
	      var h = this[i++] >> 14;
	      var m = xh * l + h * xl;
	      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
	      c = (l >> 28) + (m >> 14) + xh * h;
	      w[j++] = l & 0xfffffff;
	    }

	    return c;
	  };

	  dbits = 28;
	}

	BigInteger.prototype.DB = dbits;
	BigInteger.prototype.DM = (1 << dbits) - 1;
	BigInteger.prototype.DV = 1 << dbits;
	var BI_FP = 52;
	BigInteger.prototype.FV = Math.pow(2, BI_FP);
	BigInteger.prototype.F1 = BI_FP - dbits;
	BigInteger.prototype.F2 = 2 * dbits - BI_FP; // Digit conversions

	var BI_RC = [];
	var rr;
	var vv;
	rr = "0".charCodeAt(0);

	for (vv = 0; vv <= 9; ++vv) {
	  BI_RC[rr++] = vv;
	}

	rr = "a".charCodeAt(0);

	for (vv = 10; vv < 36; ++vv) {
	  BI_RC[rr++] = vv;
	}

	rr = "A".charCodeAt(0);

	for (vv = 10; vv < 36; ++vv) {
	  BI_RC[rr++] = vv;
	}

	function intAt(s, i) {
	  var c = BI_RC[s.charCodeAt(i)];
	  return c == null ? -1 : c;
	} // return bigint initialized to value

	function nbv(i) {
	  var r = nbi();
	  r.fromInt(i);
	  return r;
	} // returns bit length of the integer x

	function nbits(x) {
	  var r = 1;
	  var t;

	  if ((t = x >>> 16) != 0) {
	    x = t;
	    r += 16;
	  }

	  if ((t = x >> 8) != 0) {
	    x = t;
	    r += 8;
	  }

	  if ((t = x >> 4) != 0) {
	    x = t;
	    r += 4;
	  }

	  if ((t = x >> 2) != 0) {
	    x = t;
	    r += 2;
	  }

	  if ((t = x >> 1) != 0) {
	    x = t;
	    r += 1;
	  }

	  return r;
	} // "constants"

	BigInteger.ZERO = nbv(0);
	BigInteger.ONE = nbv(1);

	// prng4.js - uses Arcfour as a PRNG
	var Arcfour =
	/** @class */
	function () {
	  function Arcfour() {
	    this.i = 0;
	    this.j = 0;
	    this.S = [];
	  } // Arcfour.prototype.init = ARC4init;
	  // Initialize arcfour context from key, an array of ints, each from [0..255]


	  Arcfour.prototype.init = function (key) {
	    var i;
	    var j;
	    var t;

	    for (i = 0; i < 256; ++i) {
	      this.S[i] = i;
	    }

	    j = 0;

	    for (i = 0; i < 256; ++i) {
	      j = j + this.S[i] + key[i % key.length] & 255;
	      t = this.S[i];
	      this.S[i] = this.S[j];
	      this.S[j] = t;
	    }

	    this.i = 0;
	    this.j = 0;
	  }; // Arcfour.prototype.next = ARC4next;


	  Arcfour.prototype.next = function () {
	    var t;
	    this.i = this.i + 1 & 255;
	    this.j = this.j + this.S[this.i] & 255;
	    t = this.S[this.i];
	    this.S[this.i] = this.S[this.j];
	    this.S[this.j] = t;
	    return this.S[t + this.S[this.i] & 255];
	  };

	  return Arcfour;
	}();

	function prng_newstate() {
	  return new Arcfour();
	} // Pool size must be a multiple of 4 and greater than 32.
	// An array of bytes the size of the pool will be passed to init()

	var rng_psize = 256;

	var rng_state;
	var rng_pool = null;
	var rng_pptr; // Initialize the pool with junk if needed.

	if (rng_pool == null) {
	  rng_pool = [];
	  rng_pptr = 0;
	  var t = void 0;

	  if (window.crypto && window.crypto.getRandomValues) {
	    // Extract entropy (2048 bits) from RNG if available
	    var z = new Uint32Array(256);
	    window.crypto.getRandomValues(z);

	    for (t = 0; t < z.length; ++t) {
	      rng_pool[rng_pptr++] = z[t] & 255;
	    }
	  } // Use mouse events for entropy, if we do not have enough entropy by the time
	  // we need it, entropy will be generated by Math.random.


	  var count = 0;

	  var onMouseMoveListener_1 = function onMouseMoveListener_1(ev) {
	    count = count || 0;

	    if (count >= 256 || rng_pptr >= rng_psize) {
	      if (window.removeEventListener) {
	        window.removeEventListener("mousemove", onMouseMoveListener_1, false);
	      } else if (window.detachEvent) {
	        window.detachEvent("onmousemove", onMouseMoveListener_1);
	      }

	      return;
	    }

	    try {
	      var mouseCoordinates = ev.x + ev.y;
	      rng_pool[rng_pptr++] = mouseCoordinates & 255;
	      count += 1;
	    } catch (e) {// Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
	    }
	  };

	  if (window.addEventListener) {
	    window.addEventListener("mousemove", onMouseMoveListener_1, false);
	  } else if (window.attachEvent) {
	    window.attachEvent("onmousemove", onMouseMoveListener_1);
	  }
	}

	function rng_get_byte() {
	  if (rng_state == null) {
	    rng_state = prng_newstate(); // At this point, we may not have collected enough entropy.  If not, fall back to Math.random

	    while (rng_pptr < rng_psize) {
	      var random = Math.floor(65536 * Math.random());
	      rng_pool[rng_pptr++] = random & 255;
	    }

	    rng_state.init(rng_pool);

	    for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
	      rng_pool[rng_pptr] = 0;
	    }

	    rng_pptr = 0;
	  } // TODO: allow reseeding after first request


	  return rng_state.next();
	}

	var SecureRandom =
	/** @class */
	function () {
	  function SecureRandom() {}

	  SecureRandom.prototype.nextBytes = function (ba) {
	    for (var i = 0; i < ba.length; ++i) {
	      ba[i] = rng_get_byte();
	    }
	  };

	  return SecureRandom;
	}();

	//   var ret = "";
	//   var i = 0;
	//   while(i + n < s.length) {
	//     ret += s.substring(i,i+n) + "\n";
	//     i += n;
	//   }
	//   return ret + s.substring(i,s.length);
	// }
	// function byte2Hex(b) {
	//   if(b < 0x10)
	//     return "0" + b.toString(16);
	//   else
	//     return b.toString(16);
	// }

	function pkcs1pad1(s, n) {
	  if (n < s.length + 22) {
	    console.error("Message too long for RSA");
	    return null;
	  }

	  var len = n - s.length - 6;
	  var filler = "";

	  for (var f = 0; f < len; f += 2) {
	    filler += "ff";
	  }

	  var m = "0001" + filler + "00" + s;
	  return parseBigInt(m, 16);
	} // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint


	function pkcs1pad2(s, n) {
	  if (n < s.length + 11) {
	    // TODO: fix for utf-8
	    console.error("Message too long for RSA");
	    return null;
	  }

	  var ba = [];
	  var i = s.length - 1;

	  while (i >= 0 && n > 0) {
	    var c = s.charCodeAt(i--);

	    if (c < 128) {
	      // encode using utf-8
	      ba[--n] = c;
	    } else if (c > 127 && c < 2048) {
	      ba[--n] = c & 63 | 128;
	      ba[--n] = c >> 6 | 192;
	    } else {
	      ba[--n] = c & 63 | 128;
	      ba[--n] = c >> 6 & 63 | 128;
	      ba[--n] = c >> 12 | 224;
	    }
	  }

	  ba[--n] = 0;
	  var rng = new SecureRandom();
	  var x = [];

	  while (n > 2) {
	    // random non-zero pad
	    x[0] = 0;

	    while (x[0] == 0) {
	      rng.nextBytes(x);
	    }

	    ba[--n] = x[0];
	  }

	  ba[--n] = 2;
	  ba[--n] = 0;
	  return new BigInteger(ba);
	} // "empty" RSA key constructor


	var RSAKey =
	/** @class */
	function () {
	  function RSAKey() {
	    this.n = null;
	    this.e = 0;
	    this.d = null;
	    this.p = null;
	    this.q = null;
	    this.dmp1 = null;
	    this.dmq1 = null;
	    this.coeff = null;
	  } //#region PROTECTED
	  // protected
	  // RSAKey.prototype.doPublic = RSADoPublic;
	  // Perform raw public operation on "x": return x^e (mod n)


	  RSAKey.prototype.doPublic = function (x) {
	    return x.modPowInt(this.e, this.n);
	  }; // RSAKey.prototype.doPrivate = RSADoPrivate;
	  // Perform raw private operation on "x": return x^d (mod n)


	  RSAKey.prototype.doPrivate = function (x) {
	    if (this.p == null || this.q == null) {
	      return x.modPow(this.d, this.n);
	    } // TODO: re-calculate any missing CRT params


	    var xp = x.mod(this.p).modPow(this.dmp1, this.p);
	    var xq = x.mod(this.q).modPow(this.dmq1, this.q);

	    while (xp.compareTo(xq) < 0) {
	      xp = xp.add(this.p);
	    }

	    return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
	  }; //#endregion PROTECTED
	  //#region PUBLIC
	  // RSAKey.prototype.setPublic = RSASetPublic;
	  // Set the public key fields N and e from hex strings


	  RSAKey.prototype.setPublic = function (N, E) {
	    if (N != null && E != null && N.length > 0 && E.length > 0) {
	      this.n = parseBigInt(N, 16);
	      this.e = parseInt(E, 16);
	    } else {
	      console.error("Invalid RSA public key");
	    }
	  }; // RSAKey.prototype.encrypt = RSAEncrypt;
	  // Return the PKCS#1 RSA encryption of "text" as an even-length hex string


	  RSAKey.prototype.encrypt = function (text) {
	    var maxLength = this.n.bitLength() + 7 >> 3;
	    var m = pkcs1pad2(text, maxLength);

	    if (m == null) {
	      return null;
	    }

	    var c = this.doPublic(m);

	    if (c == null) {
	      return null;
	    }

	    var h = c.toString(16);
	    var length = h.length; // fix zero before result

	    for (var i = 0; i < maxLength * 2 - length; i++) {
	      h = "0" + h;
	    }

	    return h;
	  }; // RSAKey.prototype.setPrivate = RSASetPrivate;
	  // Set the private key fields N, e, and d from hex strings


	  RSAKey.prototype.setPrivate = function (N, E, D) {
	    if (N != null && E != null && N.length > 0 && E.length > 0) {
	      this.n = parseBigInt(N, 16);
	      this.e = parseInt(E, 16);
	      this.d = parseBigInt(D, 16);
	    } else {
	      console.error("Invalid RSA private key");
	    }
	  }; // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
	  // Set the private key fields N, e, d and CRT params from hex strings


	  RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
	    if (N != null && E != null && N.length > 0 && E.length > 0) {
	      this.n = parseBigInt(N, 16);
	      this.e = parseInt(E, 16);
	      this.d = parseBigInt(D, 16);
	      this.p = parseBigInt(P, 16);
	      this.q = parseBigInt(Q, 16);
	      this.dmp1 = parseBigInt(DP, 16);
	      this.dmq1 = parseBigInt(DQ, 16);
	      this.coeff = parseBigInt(C, 16);
	    } else {
	      console.error("Invalid RSA private key");
	    }
	  }; // RSAKey.prototype.generate = RSAGenerate;
	  // Generate a new random private key B bits long, using public expt E


	  RSAKey.prototype.generate = function (B, E) {
	    var rng = new SecureRandom();
	    var qs = B >> 1;
	    this.e = parseInt(E, 16);
	    var ee = new BigInteger(E, 16);

	    for (;;) {
	      for (;;) {
	        this.p = new BigInteger(B - qs, 1, rng);

	        if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
	          break;
	        }
	      }

	      for (;;) {
	        this.q = new BigInteger(qs, 1, rng);

	        if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
	          break;
	        }
	      }

	      if (this.p.compareTo(this.q) <= 0) {
	        var t = this.p;
	        this.p = this.q;
	        this.q = t;
	      }

	      var p1 = this.p.subtract(BigInteger.ONE);
	      var q1 = this.q.subtract(BigInteger.ONE);
	      var phi = p1.multiply(q1);

	      if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
	        this.n = this.p.multiply(this.q);
	        this.d = ee.modInverse(phi);
	        this.dmp1 = this.d.mod(p1);
	        this.dmq1 = this.d.mod(q1);
	        this.coeff = this.q.modInverse(this.p);
	        break;
	      }
	    }
	  }; // RSAKey.prototype.decrypt = RSADecrypt;
	  // Return the PKCS#1 RSA decryption of "ctext".
	  // "ctext" is an even-length hex string and the output is a plain string.


	  RSAKey.prototype.decrypt = function (ctext) {
	    var c = parseBigInt(ctext, 16);
	    var m = this.doPrivate(c);

	    if (m == null) {
	      return null;
	    }

	    return pkcs1unpad2(m, this.n.bitLength() + 7 >> 3);
	  }; // Generate a new random private key B bits long, using public expt E


	  RSAKey.prototype.generateAsync = function (B, E, callback) {
	    var rng = new SecureRandom();
	    var qs = B >> 1;
	    this.e = parseInt(E, 16);
	    var ee = new BigInteger(E, 16);
	    var rsa = this; // These functions have non-descript names because they were originally for(;;) loops.
	    // I don't know about cryptography to give them better names than loop1-4.

	    var loop1 = function loop1() {
	      var loop4 = function loop4() {
	        if (rsa.p.compareTo(rsa.q) <= 0) {
	          var t = rsa.p;
	          rsa.p = rsa.q;
	          rsa.q = t;
	        }

	        var p1 = rsa.p.subtract(BigInteger.ONE);
	        var q1 = rsa.q.subtract(BigInteger.ONE);
	        var phi = p1.multiply(q1);

	        if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
	          rsa.n = rsa.p.multiply(rsa.q);
	          rsa.d = ee.modInverse(phi);
	          rsa.dmp1 = rsa.d.mod(p1);
	          rsa.dmq1 = rsa.d.mod(q1);
	          rsa.coeff = rsa.q.modInverse(rsa.p);
	          setTimeout(function () {
	            callback();
	          }, 0); // escape
	        } else {
	          setTimeout(loop1, 0);
	        }
	      };

	      var loop3 = function loop3() {
	        rsa.q = nbi();
	        rsa.q.fromNumberAsync(qs, 1, rng, function () {
	          rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
	            if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
	              setTimeout(loop4, 0);
	            } else {
	              setTimeout(loop3, 0);
	            }
	          });
	        });
	      };

	      var loop2 = function loop2() {
	        rsa.p = nbi();
	        rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
	          rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
	            if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
	              setTimeout(loop3, 0);
	            } else {
	              setTimeout(loop2, 0);
	            }
	          });
	        });
	      };

	      setTimeout(loop2, 0);
	    };

	    setTimeout(loop1, 0);
	  };

	  RSAKey.prototype.sign = function (text, digestMethod, digestName) {
	    var header = getDigestHeader(digestName);
	    var digest = header + digestMethod(text).toString();
	    var m = pkcs1pad1(digest, this.n.bitLength() / 4);

	    if (m == null) {
	      return null;
	    }

	    var c = this.doPrivate(m);

	    if (c == null) {
	      return null;
	    }

	    var h = c.toString(16);

	    if ((h.length & 1) == 0) {
	      return h;
	    } else {
	      return "0" + h;
	    }
	  };

	  RSAKey.prototype.verify = function (text, signature, digestMethod) {
	    var c = parseBigInt(signature, 16);
	    var m = this.doPublic(c);

	    if (m == null) {
	      return null;
	    }

	    var unpadded = m.toString(16).replace(/^1f+00/, "");
	    var digest = removeDigestHeader(unpadded);
	    return digest == digestMethod(text).toString();
	  };

	  return RSAKey;
	}();

	function pkcs1unpad2(d, n) {
	  var b = d.toByteArray();
	  var i = 0;

	  while (i < b.length && b[i] == 0) {
	    ++i;
	  }

	  if (b.length - i != n - 1 || b[i] != 2) {
	    return null;
	  }

	  ++i;

	  while (b[i] != 0) {
	    if (++i >= b.length) {
	      return null;
	    }
	  }

	  var ret = "";

	  while (++i < b.length) {
	    var c = b[i] & 255;

	    if (c < 128) {
	      // utf-8 decode
	      ret += String.fromCharCode(c);
	    } else if (c > 191 && c < 224) {
	      ret += String.fromCharCode((c & 31) << 6 | b[i + 1] & 63);
	      ++i;
	    } else {
	      ret += String.fromCharCode((c & 15) << 12 | (b[i + 1] & 63) << 6 | b[i + 2] & 63);
	      i += 2;
	    }
	  }

	  return ret;
	} // https://tools.ietf.org/html/rfc3447#page-43


	var DIGEST_HEADERS = {
	  md2: "3020300c06082a864886f70d020205000410",
	  md5: "3020300c06082a864886f70d020505000410",
	  sha1: "3021300906052b0e03021a05000414",
	  sha224: "302d300d06096086480165030402040500041c",
	  sha256: "3031300d060960864801650304020105000420",
	  sha384: "3041300d060960864801650304020205000430",
	  sha512: "3051300d060960864801650304020305000440",
	  ripemd160: "3021300906052b2403020105000414"
	};

	function getDigestHeader(name) {
	  return DIGEST_HEADERS[name] || "";
	}

	function removeDigestHeader(str) {
	  for (var name_1 in DIGEST_HEADERS) {
	    if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
	      var header = DIGEST_HEADERS[name_1];
	      var len = header.length;

	      if (str.substr(0, len) == header) {
	        return str.substr(len);
	      }
	    }
	  }

	  return str;
	} // Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
	// function RSAEncryptB64(text) {
	//  var h = this.encrypt(text);
	//  if(h) return hex2b64(h); else return null;
	// }
	// public
	// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

	/*!
	Copyright (c) 2011, Yahoo! Inc. All rights reserved.
	Code licensed under the BSD License:
	http://developer.yahoo.com/yui/license.html
	version: 2.9.0
	*/
	var YAHOO = {};
	YAHOO.lang = {
	  /**
	   * Utility to set up the prototype, constructor and superclass properties to
	   * support an inheritance strategy that can chain constructors and methods.
	   * Static members will not be inherited.
	   *
	   * @method extend
	   * @static
	   * @param {Function} subc   the object to modify
	   * @param {Function} superc the object to inherit
	   * @param {Object} overrides  additional properties/methods to add to the
	   *                              subclass prototype.  These will override the
	   *                              matching items obtained from the superclass
	   *                              if present.
	   */
	  extend: function extend(subc, superc, overrides) {
	    if (!superc || !subc) {
	      throw new Error("YAHOO.lang.extend failed, please check that " + "all dependencies are included.");
	    }

	    var F = function F() {};

	    F.prototype = superc.prototype;
	    subc.prototype = new F();
	    subc.prototype.constructor = subc;
	    subc.superclass = superc.prototype;

	    if (superc.prototype.constructor == Object.prototype.constructor) {
	      superc.prototype.constructor = superc;
	    }

	    if (overrides) {
	      var i;

	      for (i in overrides) {
	        subc.prototype[i] = overrides[i];
	      }
	      /*
	       * IE will not enumerate native functions in a derived object even if the
	       * function was overridden.  This is a workaround for specific functions
	       * we care about on the Object prototype.
	       * @property _IEEnumFix
	       * @param {Function} r  the object to receive the augmentation
	       * @param {Function} s  the object that supplies the properties to augment
	       * @static
	       * @private
	       */


	      var _IEEnumFix = function _IEEnumFix() {},
	          ADD = ["toString", "valueOf"];

	      try {
	        if (/MSIE/.test(navigator.userAgent)) {
	          _IEEnumFix = function _IEEnumFix(r, s) {
	            for (i = 0; i < ADD.length; i = i + 1) {
	              var fname = ADD[i],
	                  f = s[fname];

	              if (typeof f === 'function' && f != Object.prototype[fname]) {
	                r[fname] = f;
	              }
	            }
	          };
	        }
	      } catch (ex) {}

	      _IEEnumFix(subc.prototype, overrides);
	    }
	  }
	};

	/**
	 * @fileOverview
	 * @name asn1-1.0.js
	 * @author Kenji Urushima kenji.urushima@gmail.com
	 * @version asn1 1.0.13 (2017-Jun-02)
	 * @since jsrsasign 2.1
	 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
	 */

	/**
	 * kjur's class library name space
	 * <p>
	 * This name space provides following name spaces:
	 * <ul>
	 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
	 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
	 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
	 * class and utilities</li>
	 * </ul>
	 * </p>
	 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
	 * @name KJUR
	 * @namespace kjur's class library name space
	 */

	var KJUR = {};
	/**
	 * kjur's ASN.1 class library name space
	 * <p>
	 * This is ITU-T X.690 ASN.1 DER encoder class library and
	 * class structure and methods is very similar to
	 * org.bouncycastle.asn1 package of
	 * well known BouncyCaslte Cryptography Library.
	 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
	 * Here are ASN.1 DER primitive classes.
	 * <ul>
	 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
	 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
	 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
	 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
	 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
	 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
	 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
	 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
	 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
	 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
	 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
	 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
	 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
	 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
	 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
	 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
	 * </ul>
	 * <h4>OTHER ASN.1 CLASSES</h4>
	 * <ul>
	 * <li>{@link KJUR.asn1.ASN1Object}</li>
	 * <li>{@link KJUR.asn1.DERAbstractString}</li>
	 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
	 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
	 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
	 * </ul>
	 * <h4>SUB NAME SPACES</h4>
	 * <ul>
	 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
	 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
	 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
	 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
	 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
	 * </ul>
	 * </p>
	 * NOTE: Please ignore method summary and document of this namespace.
	 * This caused by a bug of jsdoc2.
	 * @name KJUR.asn1
	 * @namespace
	 */

	if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
	/**
	 * ASN1 utilities class
	 * @name KJUR.asn1.ASN1Util
	 * @class ASN1 utilities class
	 * @since asn1 1.0.2
	 */

	KJUR.asn1.ASN1Util = new function () {
	  this.integerToByteHex = function (i) {
	    var h = i.toString(16);
	    if (h.length % 2 == 1) h = '0' + h;
	    return h;
	  };

	  this.bigIntToMinTwosComplementsHex = function (bigIntegerValue) {
	    var h = bigIntegerValue.toString(16);

	    if (h.substr(0, 1) != '-') {
	      if (h.length % 2 == 1) {
	        h = '0' + h;
	      } else {
	        if (!h.match(/^[0-7]/)) {
	          h = '00' + h;
	        }
	      }
	    } else {
	      var hPos = h.substr(1);
	      var xorLen = hPos.length;

	      if (xorLen % 2 == 1) {
	        xorLen += 1;
	      } else {
	        if (!h.match(/^[0-7]/)) {
	          xorLen += 2;
	        }
	      }

	      var hMask = '';

	      for (var i = 0; i < xorLen; i++) {
	        hMask += 'f';
	      }

	      var biMask = new BigInteger(hMask, 16);
	      var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
	      h = biNeg.toString(16).replace(/^-/, '');
	    }

	    return h;
	  };
	  /**
	   * get PEM string from hexadecimal data and header string
	   * @name getPEMStringFromHex
	   * @memberOf KJUR.asn1.ASN1Util
	   * @function
	   * @param {String} dataHex hexadecimal string of PEM body
	   * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
	   * @return {String} PEM formatted string of input data
	   * @description
	   * This method converts a hexadecimal string to a PEM string with
	   * a specified header. Its line break will be CRLF("\r\n").
	   * @example
	   * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
	   * // value of pem will be:
	   * -----BEGIN PRIVATE KEY-----
	   * YWFh
	   * -----END PRIVATE KEY-----
	   */


	  this.getPEMStringFromHex = function (dataHex, pemHeader) {
	    return hextopem(dataHex, pemHeader);
	  };
	  /**
	   * generate ASN1Object specifed by JSON parameters
	   * @name newObject
	   * @memberOf KJUR.asn1.ASN1Util
	   * @function
	   * @param {Array} param JSON parameter to generate ASN1Object
	   * @return {KJUR.asn1.ASN1Object} generated object
	   * @since asn1 1.0.3
	   * @description
	   * generate any ASN1Object specified by JSON param
	   * including ASN.1 primitive or structured.
	   * Generally 'param' can be described as follows:
	   * <blockquote>
	   * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
	   * </blockquote>
	   * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
	   * <ul>
	   * <li>'bool' - DERBoolean</li>
	   * <li>'int' - DERInteger</li>
	   * <li>'bitstr' - DERBitString</li>
	   * <li>'octstr' - DEROctetString</li>
	   * <li>'null' - DERNull</li>
	   * <li>'oid' - DERObjectIdentifier</li>
	   * <li>'enum' - DEREnumerated</li>
	   * <li>'utf8str' - DERUTF8String</li>
	   * <li>'numstr' - DERNumericString</li>
	   * <li>'prnstr' - DERPrintableString</li>
	   * <li>'telstr' - DERTeletexString</li>
	   * <li>'ia5str' - DERIA5String</li>
	   * <li>'utctime' - DERUTCTime</li>
	   * <li>'gentime' - DERGeneralizedTime</li>
	   * <li>'seq' - DERSequence</li>
	   * <li>'set' - DERSet</li>
	   * <li>'tag' - DERTaggedObject</li>
	   * </ul>
	   * @example
	   * newObject({'prnstr': 'aaa'});
	   * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
	   * // ASN.1 Tagged Object
	   * newObject({'tag': {'tag': 'a1',
	   *                    'explicit': true,
	   *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
	   * // more simple representation of ASN.1 Tagged Object
	   * newObject({'tag': ['a1',
	   *                    true,
	   *                    {'seq': [
	   *                      {'int': 3},
	   *                      {'prnstr': 'aaa'}]}
	   *                   ]});
	   */


	  this.newObject = function (param) {
	    var _KJUR = KJUR,
	        _KJUR_asn1 = _KJUR.asn1,
	        _DERBoolean = _KJUR_asn1.DERBoolean,
	        _DERInteger = _KJUR_asn1.DERInteger,
	        _DERBitString = _KJUR_asn1.DERBitString,
	        _DEROctetString = _KJUR_asn1.DEROctetString,
	        _DERNull = _KJUR_asn1.DERNull,
	        _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	        _DEREnumerated = _KJUR_asn1.DEREnumerated,
	        _DERUTF8String = _KJUR_asn1.DERUTF8String,
	        _DERNumericString = _KJUR_asn1.DERNumericString,
	        _DERPrintableString = _KJUR_asn1.DERPrintableString,
	        _DERTeletexString = _KJUR_asn1.DERTeletexString,
	        _DERIA5String = _KJUR_asn1.DERIA5String,
	        _DERUTCTime = _KJUR_asn1.DERUTCTime,
	        _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
	        _DERSequence = _KJUR_asn1.DERSequence,
	        _DERSet = _KJUR_asn1.DERSet,
	        _DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	        _newObject = _KJUR_asn1.ASN1Util.newObject;
	    var keys = Object.keys(param);
	    if (keys.length != 1) throw "key of param shall be only one.";
	    var key = keys[0];
	    if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1) throw "undefined key: " + key;
	    if (key == "bool") return new _DERBoolean(param[key]);
	    if (key == "int") return new _DERInteger(param[key]);
	    if (key == "bitstr") return new _DERBitString(param[key]);
	    if (key == "octstr") return new _DEROctetString(param[key]);
	    if (key == "null") return new _DERNull(param[key]);
	    if (key == "oid") return new _DERObjectIdentifier(param[key]);
	    if (key == "enum") return new _DEREnumerated(param[key]);
	    if (key == "utf8str") return new _DERUTF8String(param[key]);
	    if (key == "numstr") return new _DERNumericString(param[key]);
	    if (key == "prnstr") return new _DERPrintableString(param[key]);
	    if (key == "telstr") return new _DERTeletexString(param[key]);
	    if (key == "ia5str") return new _DERIA5String(param[key]);
	    if (key == "utctime") return new _DERUTCTime(param[key]);
	    if (key == "gentime") return new _DERGeneralizedTime(param[key]);

	    if (key == "seq") {
	      var paramList = param[key];
	      var a = [];

	      for (var i = 0; i < paramList.length; i++) {
	        var asn1Obj = _newObject(paramList[i]);

	        a.push(asn1Obj);
	      }

	      return new _DERSequence({
	        'array': a
	      });
	    }

	    if (key == "set") {
	      var paramList = param[key];
	      var a = [];

	      for (var i = 0; i < paramList.length; i++) {
	        var asn1Obj = _newObject(paramList[i]);

	        a.push(asn1Obj);
	      }

	      return new _DERSet({
	        'array': a
	      });
	    }

	    if (key == "tag") {
	      var tagParam = param[key];

	      if (Object.prototype.toString.call(tagParam) === '[object Array]' && tagParam.length == 3) {
	        var obj = _newObject(tagParam[2]);

	        return new _DERTaggedObject({
	          tag: tagParam[0],
	          explicit: tagParam[1],
	          obj: obj
	        });
	      } else {
	        var newParam = {};
	        if (tagParam.explicit !== undefined) newParam.explicit = tagParam.explicit;
	        if (tagParam.tag !== undefined) newParam.tag = tagParam.tag;
	        if (tagParam.obj === undefined) throw "obj shall be specified for 'tag'.";
	        newParam.obj = _newObject(tagParam.obj);
	        return new _DERTaggedObject(newParam);
	      }
	    }
	  };
	  /**
	   * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
	   * @name jsonToASN1HEX
	   * @memberOf KJUR.asn1.ASN1Util
	   * @function
	   * @param {Array} param JSON parameter to generate ASN1Object
	   * @return hexadecimal string of ASN1Object
	   * @since asn1 1.0.4
	   * @description
	   * As for ASN.1 object representation of JSON object,
	   * please see {@link newObject}.
	   * @example
	   * jsonToASN1HEX({'prnstr': 'aaa'});
	   */


	  this.jsonToASN1HEX = function (param) {
	    var asn1Obj = this.newObject(param);
	    return asn1Obj.getEncodedHex();
	  };
	}();
	/**
	 * get dot noted oid number string from hexadecimal value of OID
	 * @name oidHexToInt
	 * @memberOf KJUR.asn1.ASN1Util
	 * @function
	 * @param {String} hex hexadecimal value of object identifier
	 * @return {String} dot noted string of object identifier
	 * @since jsrsasign 4.8.3 asn1 1.0.7
	 * @description
	 * This static method converts from hexadecimal string representation of
	 * ASN.1 value of object identifier to oid number string.
	 * @example
	 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
	 */

	KJUR.asn1.ASN1Util.oidHexToInt = function (hex) {
	  var s = "";
	  var i01 = parseInt(hex.substr(0, 2), 16);
	  var i0 = Math.floor(i01 / 40);
	  var i1 = i01 % 40;
	  var s = i0 + "." + i1;
	  var binbuf = "";

	  for (var i = 2; i < hex.length; i += 2) {
	    var value = parseInt(hex.substr(i, 2), 16);
	    var bin = ("00000000" + value.toString(2)).slice(-8);
	    binbuf = binbuf + bin.substr(1, 7);

	    if (bin.substr(0, 1) == "0") {
	      var bi = new BigInteger(binbuf, 2);
	      s = s + "." + bi.toString(10);
	      binbuf = "";
	    }
	  }
	  return s;
	};
	/**
	 * get hexadecimal value of object identifier from dot noted oid value
	 * @name oidIntToHex
	 * @memberOf KJUR.asn1.ASN1Util
	 * @function
	 * @param {String} oidString dot noted string of object identifier
	 * @return {String} hexadecimal value of object identifier
	 * @since jsrsasign 4.8.3 asn1 1.0.7
	 * @description
	 * This static method converts from object identifier value string.
	 * to hexadecimal string representation of it.
	 * @example
	 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
	 */


	KJUR.asn1.ASN1Util.oidIntToHex = function (oidString) {
	  var itox = function itox(i) {
	    var h = i.toString(16);
	    if (h.length == 1) h = '0' + h;
	    return h;
	  };

	  var roidtox = function roidtox(roid) {
	    var h = '';
	    var bi = new BigInteger(roid, 10);
	    var b = bi.toString(2);
	    var padLen = 7 - b.length % 7;
	    if (padLen == 7) padLen = 0;
	    var bPad = '';

	    for (var i = 0; i < padLen; i++) {
	      bPad += '0';
	    }

	    b = bPad + b;

	    for (var i = 0; i < b.length - 1; i += 7) {
	      var b8 = b.substr(i, 7);
	      if (i != b.length - 7) b8 = '1' + b8;
	      h += itox(parseInt(b8, 2));
	    }

	    return h;
	  };

	  if (!oidString.match(/^[0-9.]+$/)) {
	    throw "malformed oid string: " + oidString;
	  }

	  var h = '';
	  var a = oidString.split('.');
	  var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
	  h += itox(i0);
	  a.splice(0, 2);

	  for (var i = 0; i < a.length; i++) {
	    h += roidtox(a[i]);
	  }

	  return h;
	}; // ********************************************************************
	//  Abstract ASN.1 Classes
	// ********************************************************************
	// ********************************************************************

	/**
	 * base class for ASN.1 DER encoder object
	 * @name KJUR.asn1.ASN1Object
	 * @class base class for ASN.1 DER encoder object
	 * @property {Boolean} isModified flag whether internal data was changed
	 * @property {String} hTLV hexadecimal string of ASN.1 TLV
	 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
	 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
	 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
	 * @description
	 */


	KJUR.asn1.ASN1Object = function () {
	  var hV = '';
	  /**
	   * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
	   * @name getLengthHexFromValue
	   * @memberOf KJUR.asn1.ASN1Object#
	   * @function
	   * @return {String} hexadecimal string of ASN.1 TLV length(L)
	   */

	  this.getLengthHexFromValue = function () {
	    if (typeof this.hV == "undefined" || this.hV == null) {
	      throw "this.hV is null or undefined.";
	    }

	    if (this.hV.length % 2 == 1) {
	      throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
	    }

	    var n = this.hV.length / 2;
	    var hN = n.toString(16);

	    if (hN.length % 2 == 1) {
	      hN = "0" + hN;
	    }

	    if (n < 128) {
	      return hN;
	    } else {
	      var hNlen = hN.length / 2;

	      if (hNlen > 15) {
	        throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
	      }

	      var head = 128 + hNlen;
	      return head.toString(16) + hN;
	    }
	  };
	  /**
	   * get hexadecimal string of ASN.1 TLV bytes
	   * @name getEncodedHex
	   * @memberOf KJUR.asn1.ASN1Object#
	   * @function
	   * @return {String} hexadecimal string of ASN.1 TLV
	   */


	  this.getEncodedHex = function () {
	    if (this.hTLV == null || this.isModified) {
	      this.hV = this.getFreshValueHex();
	      this.hL = this.getLengthHexFromValue();
	      this.hTLV = this.hT + this.hL + this.hV;
	      this.isModified = false; //alert("first time: " + this.hTLV);
	    }

	    return this.hTLV;
	  };
	  /**
	   * get hexadecimal string of ASN.1 TLV value(V) bytes
	   * @name getValueHex
	   * @memberOf KJUR.asn1.ASN1Object#
	   * @function
	   * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
	   */


	  this.getValueHex = function () {
	    this.getEncodedHex();
	    return this.hV;
	  };

	  this.getFreshValueHex = function () {
	    return '';
	  };
	}; // == BEGIN DERAbstractString ================================================

	/**
	 * base class for ASN.1 DER string classes
	 * @name KJUR.asn1.DERAbstractString
	 * @class base class for ASN.1 DER string classes
	 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
	 * @property {String} s internal string of value
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>str - specify initial ASN.1 value(V) by a string</li>
	 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
	 * </ul>
	 * NOTE: 'params' can be omitted.
	 */


	KJUR.asn1.DERAbstractString = function (params) {
	  KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
	  /**
	   * get string value of this string object
	   * @name getString
	   * @memberOf KJUR.asn1.DERAbstractString#
	   * @function
	   * @return {String} string value of this string object
	   */

	  this.getString = function () {
	    return this.s;
	  };
	  /**
	   * set value by a string
	   * @name setString
	   * @memberOf KJUR.asn1.DERAbstractString#
	   * @function
	   * @param {String} newS value by a string to set
	   */


	  this.setString = function (newS) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.s = newS;
	    this.hV = stohex(this.s);
	  };
	  /**
	   * set value by a hexadecimal string
	   * @name setStringHex
	   * @memberOf KJUR.asn1.DERAbstractString#
	   * @function
	   * @param {String} newHexString value by a hexadecimal string to set
	   */


	  this.setStringHex = function (newHexString) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.s = null;
	    this.hV = newHexString;
	  };

	  this.getFreshValueHex = function () {
	    return this.hV;
	  };

	  if (typeof params != "undefined") {
	    if (typeof params == "string") {
	      this.setString(params);
	    } else if (typeof params['str'] != "undefined") {
	      this.setString(params['str']);
	    } else if (typeof params['hex'] != "undefined") {
	      this.setStringHex(params['hex']);
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object); // == END   DERAbstractString ================================================
	// == BEGIN DERAbstractTime ==================================================

	/**
	 * base class for ASN.1 DER Generalized/UTCTime class
	 * @name KJUR.asn1.DERAbstractTime
	 * @class base class for ASN.1 DER Generalized/UTCTime class
	 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * @see KJUR.asn1.ASN1Object - superclass
	 */

	KJUR.asn1.DERAbstractTime = function (params) {
	  KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);

	  this.localDateToUTC = function (d) {
	    utc = d.getTime() + d.getTimezoneOffset() * 60000;
	    var utcDate = new Date(utc);
	    return utcDate;
	  };
	  /*
	   * format date string by Data object
	   * @name formatDate
	   * @memberOf KJUR.asn1.AbstractTime;
	   * @param {Date} dateObject
	   * @param {string} type 'utc' or 'gen'
	   * @param {boolean} withMillis flag for with millisections or not
	   * @description
	   * 'withMillis' flag is supported from asn1 1.0.6.
	   */


	  this.formatDate = function (dateObject, type, withMillis) {
	    var pad = this.zeroPadding;
	    var d = this.localDateToUTC(dateObject);
	    var year = String(d.getFullYear());
	    if (type == 'utc') year = year.substr(2, 2);
	    var month = pad(String(d.getMonth() + 1), 2);
	    var day = pad(String(d.getDate()), 2);
	    var hour = pad(String(d.getHours()), 2);
	    var min = pad(String(d.getMinutes()), 2);
	    var sec = pad(String(d.getSeconds()), 2);
	    var s = year + month + day + hour + min + sec;

	    if (withMillis === true) {
	      var millis = d.getMilliseconds();

	      if (millis != 0) {
	        var sMillis = pad(String(millis), 3);
	        sMillis = sMillis.replace(/[0]+$/, "");
	        s = s + "." + sMillis;
	      }
	    }

	    return s + "Z";
	  };

	  this.zeroPadding = function (s, len) {
	    if (s.length >= len) return s;
	    return new Array(len - s.length + 1).join('0') + s;
	  }; // --- PUBLIC METHODS --------------------

	  /**
	   * get string value of this string object
	   * @name getString
	   * @memberOf KJUR.asn1.DERAbstractTime#
	   * @function
	   * @return {String} string value of this time object
	   */


	  this.getString = function () {
	    return this.s;
	  };
	  /**
	   * set value by a string
	   * @name setString
	   * @memberOf KJUR.asn1.DERAbstractTime#
	   * @function
	   * @param {String} newS value by a string to set such like "130430235959Z"
	   */


	  this.setString = function (newS) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.s = newS;
	    this.hV = stohex(newS);
	  };
	  /**
	   * set value by a Date object
	   * @name setByDateValue
	   * @memberOf KJUR.asn1.DERAbstractTime#
	   * @function
	   * @param {Integer} year year of date (ex. 2013)
	   * @param {Integer} month month of date between 1 and 12 (ex. 12)
	   * @param {Integer} day day of month
	   * @param {Integer} hour hours of date
	   * @param {Integer} min minutes of date
	   * @param {Integer} sec seconds of date
	   */


	  this.setByDateValue = function (year, month, day, hour, min, sec) {
	    var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
	    this.setByDate(dateObject);
	  };

	  this.getFreshValueHex = function () {
	    return this.hV;
	  };
	};

	YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object); // == END   DERAbstractTime ==================================================
	// == BEGIN DERAbstractStructured ============================================

	/**
	 * base class for ASN.1 DER structured class
	 * @name KJUR.asn1.DERAbstractStructured
	 * @class base class for ASN.1 DER structured class
	 * @property {Array} asn1Array internal array of ASN1Object
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * @see KJUR.asn1.ASN1Object - superclass
	 */

	KJUR.asn1.DERAbstractStructured = function (params) {
	  KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
	  /**
	   * set value by array of ASN1Object
	   * @name setByASN1ObjectArray
	   * @memberOf KJUR.asn1.DERAbstractStructured#
	   * @function
	   * @param {array} asn1ObjectArray array of ASN1Object to set
	   */

	  this.setByASN1ObjectArray = function (asn1ObjectArray) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.asn1Array = asn1ObjectArray;
	  };
	  /**
	   * append an ASN1Object to internal array
	   * @name appendASN1Object
	   * @memberOf KJUR.asn1.DERAbstractStructured#
	   * @function
	   * @param {ASN1Object} asn1Object to add
	   */


	  this.appendASN1Object = function (asn1Object) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.asn1Array.push(asn1Object);
	  };

	  this.asn1Array = new Array();

	  if (typeof params != "undefined") {
	    if (typeof params['array'] != "undefined") {
	      this.asn1Array = params['array'];
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object); // ********************************************************************
	//  ASN.1 Object Classes
	// ********************************************************************
	// ********************************************************************

	/**
	 * class for ASN.1 DER Boolean
	 * @name KJUR.asn1.DERBoolean
	 * @class class for ASN.1 DER Boolean
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * @see KJUR.asn1.ASN1Object - superclass
	 */

	KJUR.asn1.DERBoolean = function () {
	  KJUR.asn1.DERBoolean.superclass.constructor.call(this);
	  this.hT = "01";
	  this.hTLV = "0101ff";
	};

	YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object); // ********************************************************************

	/**
	 * class for ASN.1 DER Integer
	 * @name KJUR.asn1.DERInteger
	 * @class class for ASN.1 DER Integer
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>int - specify initial ASN.1 value(V) by integer value</li>
	 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
	 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
	 * </ul>
	 * NOTE: 'params' can be omitted.
	 */

	KJUR.asn1.DERInteger = function (params) {
	  KJUR.asn1.DERInteger.superclass.constructor.call(this);
	  this.hT = "02";
	  /**
	   * set value by Tom Wu's BigInteger object
	   * @name setByBigInteger
	   * @memberOf KJUR.asn1.DERInteger#
	   * @function
	   * @param {BigInteger} bigIntegerValue to set
	   */

	  this.setByBigInteger = function (bigIntegerValue) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
	  };
	  /**
	   * set value by integer value
	   * @name setByInteger
	   * @memberOf KJUR.asn1.DERInteger
	   * @function
	   * @param {Integer} integer value to set
	   */


	  this.setByInteger = function (intValue) {
	    var bi = new BigInteger(String(intValue), 10);
	    this.setByBigInteger(bi);
	  };
	  /**
	   * set value by integer value
	   * @name setValueHex
	   * @memberOf KJUR.asn1.DERInteger#
	   * @function
	   * @param {String} hexadecimal string of integer value
	   * @description
	   * <br/>
	   * NOTE: Value shall be represented by minimum octet length of
	   * two's complement representation.
	   * @example
	   * new KJUR.asn1.DERInteger(123);
	   * new KJUR.asn1.DERInteger({'int': 123});
	   * new KJUR.asn1.DERInteger({'hex': '1fad'});
	   */


	  this.setValueHex = function (newHexString) {
	    this.hV = newHexString;
	  };

	  this.getFreshValueHex = function () {
	    return this.hV;
	  };

	  if (typeof params != "undefined") {
	    if (typeof params['bigint'] != "undefined") {
	      this.setByBigInteger(params['bigint']);
	    } else if (typeof params['int'] != "undefined") {
	      this.setByInteger(params['int']);
	    } else if (typeof params == "number") {
	      this.setByInteger(params);
	    } else if (typeof params['hex'] != "undefined") {
	      this.setValueHex(params['hex']);
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object); // ********************************************************************

	/**
	 * class for ASN.1 DER encoded BitString primitive
	 * @name KJUR.asn1.DERBitString
	 * @class class for ASN.1 DER encoded BitString primitive
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>bin - specify binary string (ex. '10111')</li>
	 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
	 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
	 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
	 * argument for "BitString encapsulates" structure.</li>
	 * </ul>
	 * NOTE1: 'params' can be omitted.<br/>
	 * NOTE2: 'obj' parameter have been supported since
	 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
	 * @example
	 * // default constructor
	 * o = new KJUR.asn1.DERBitString();
	 * // initialize with binary string
	 * o = new KJUR.asn1.DERBitString({bin: "1011"});
	 * // initialize with boolean array
	 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
	 * // initialize with hexadecimal string (04 is unused bits)
	 * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
	 * // initialize with ASN1Util.newObject argument for encapsulated
	 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
	 * // above generates a ASN.1 data like this:
	 * // BIT STRING, encapsulates {
	 * //   SEQUENCE {
	 * //     INTEGER 3
	 * //     PrintableString 'aaa'
	 * //     }
	 * //   }
	 */

	KJUR.asn1.DERBitString = function (params) {
	  if (params !== undefined && typeof params.obj !== "undefined") {
	    var o = KJUR.asn1.ASN1Util.newObject(params.obj);
	    params.hex = "00" + o.getEncodedHex();
	  }

	  KJUR.asn1.DERBitString.superclass.constructor.call(this);
	  this.hT = "03";
	  /**
	   * set ASN.1 value(V) by a hexadecimal string including unused bits
	   * @name setHexValueIncludingUnusedBits
	   * @memberOf KJUR.asn1.DERBitString#
	   * @function
	   * @param {String} newHexStringIncludingUnusedBits
	   */

	  this.setHexValueIncludingUnusedBits = function (newHexStringIncludingUnusedBits) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.hV = newHexStringIncludingUnusedBits;
	  };
	  /**
	   * set ASN.1 value(V) by unused bit and hexadecimal string of value
	   * @name setUnusedBitsAndHexValue
	   * @memberOf KJUR.asn1.DERBitString#
	   * @function
	   * @param {Integer} unusedBits
	   * @param {String} hValue
	   */


	  this.setUnusedBitsAndHexValue = function (unusedBits, hValue) {
	    if (unusedBits < 0 || 7 < unusedBits) {
	      throw "unused bits shall be from 0 to 7: u = " + unusedBits;
	    }

	    var hUnusedBits = "0" + unusedBits;
	    this.hTLV = null;
	    this.isModified = true;
	    this.hV = hUnusedBits + hValue;
	  };
	  /**
	   * set ASN.1 DER BitString by binary string<br/>
	   * @name setByBinaryString
	   * @memberOf KJUR.asn1.DERBitString#
	   * @function
	   * @param {String} binaryString binary value string (i.e. '10111')
	   * @description
	   * Its unused bits will be calculated automatically by length of
	   * 'binaryValue'. <br/>
	   * NOTE: Trailing zeros '0' will be ignored.
	   * @example
	   * o = new KJUR.asn1.DERBitString();
	   * o.setByBooleanArray("01011");
	   */


	  this.setByBinaryString = function (binaryString) {
	    binaryString = binaryString.replace(/0+$/, '');
	    var unusedBits = 8 - binaryString.length % 8;
	    if (unusedBits == 8) unusedBits = 0;

	    for (var i = 0; i <= unusedBits; i++) {
	      binaryString += '0';
	    }

	    var h = '';

	    for (var i = 0; i < binaryString.length - 1; i += 8) {
	      var b = binaryString.substr(i, 8);
	      var x = parseInt(b, 2).toString(16);
	      if (x.length == 1) x = '0' + x;
	      h += x;
	    }

	    this.hTLV = null;
	    this.isModified = true;
	    this.hV = '0' + unusedBits + h;
	  };
	  /**
	   * set ASN.1 TLV value(V) by an array of boolean<br/>
	   * @name setByBooleanArray
	   * @memberOf KJUR.asn1.DERBitString#
	   * @function
	   * @param {array} booleanArray array of boolean (ex. [true, false, true])
	   * @description
	   * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
	   * @example
	   * o = new KJUR.asn1.DERBitString();
	   * o.setByBooleanArray([false, true, false, true, true]);
	   */


	  this.setByBooleanArray = function (booleanArray) {
	    var s = '';

	    for (var i = 0; i < booleanArray.length; i++) {
	      if (booleanArray[i] == true) {
	        s += '1';
	      } else {
	        s += '0';
	      }
	    }

	    this.setByBinaryString(s);
	  };
	  /**
	   * generate an array of falses with specified length<br/>
	   * @name newFalseArray
	   * @memberOf KJUR.asn1.DERBitString
	   * @function
	   * @param {Integer} nLength length of array to generate
	   * @return {array} array of boolean falses
	   * @description
	   * This static method may be useful to initialize boolean array.
	   * @example
	   * o = new KJUR.asn1.DERBitString();
	   * o.newFalseArray(3) &rarr; [false, false, false]
	   */


	  this.newFalseArray = function (nLength) {
	    var a = new Array(nLength);

	    for (var i = 0; i < nLength; i++) {
	      a[i] = false;
	    }

	    return a;
	  };

	  this.getFreshValueHex = function () {
	    return this.hV;
	  };

	  if (typeof params != "undefined") {
	    if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
	      this.setHexValueIncludingUnusedBits(params);
	    } else if (typeof params['hex'] != "undefined") {
	      this.setHexValueIncludingUnusedBits(params['hex']);
	    } else if (typeof params['bin'] != "undefined") {
	      this.setByBinaryString(params['bin']);
	    } else if (typeof params['array'] != "undefined") {
	      this.setByBooleanArray(params['array']);
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object); // ********************************************************************

	/**
	 * class for ASN.1 DER OctetString<br/>
	 * @name KJUR.asn1.DEROctetString
	 * @class class for ASN.1 DER OctetString
	 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
	 * @extends KJUR.asn1.DERAbstractString
	 * @description
	 * This class provides ASN.1 OctetString simple type.<br/>
	 * Supported "params" attributes are:
	 * <ul>
	 * <li>str - to set a string as a value</li>
	 * <li>hex - to set a hexadecimal string as a value</li>
	 * <li>obj - to set a encapsulated ASN.1 value by JSON object
	 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
	 * </ul>
	 * NOTE: A parameter 'obj' have been supported
	 * for "OCTET STRING, encapsulates" structure.
	 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
	 * @see KJUR.asn1.DERAbstractString - superclass
	 * @example
	 * // default constructor
	 * o = new KJUR.asn1.DEROctetString();
	 * // initialize with string
	 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
	 * // initialize with hexadecimal string
	 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
	 * // initialize with ASN1Util.newObject argument
	 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
	 * // above generates a ASN.1 data like this:
	 * // OCTET STRING, encapsulates {
	 * //   SEQUENCE {
	 * //     INTEGER 3
	 * //     PrintableString 'aaa'
	 * //     }
	 * //   }
	 */

	KJUR.asn1.DEROctetString = function (params) {
	  if (params !== undefined && typeof params.obj !== "undefined") {
	    var o = KJUR.asn1.ASN1Util.newObject(params.obj);
	    params.hex = o.getEncodedHex();
	  }

	  KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
	  this.hT = "04";
	};

	YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString); // ********************************************************************

	/**
	 * class for ASN.1 DER Null
	 * @name KJUR.asn1.DERNull
	 * @class class for ASN.1 DER Null
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * @see KJUR.asn1.ASN1Object - superclass
	 */

	KJUR.asn1.DERNull = function () {
	  KJUR.asn1.DERNull.superclass.constructor.call(this);
	  this.hT = "05";
	  this.hTLV = "0500";
	};

	YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object); // ********************************************************************

	/**
	 * class for ASN.1 DER ObjectIdentifier
	 * @name KJUR.asn1.DERObjectIdentifier
	 * @class class for ASN.1 DER ObjectIdentifier
	 * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
	 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
	 * </ul>
	 * NOTE: 'params' can be omitted.
	 */

	KJUR.asn1.DERObjectIdentifier = function (params) {
	  var itox = function itox(i) {
	    var h = i.toString(16);
	    if (h.length == 1) h = '0' + h;
	    return h;
	  };

	  var roidtox = function roidtox(roid) {
	    var h = '';
	    var bi = new BigInteger(roid, 10);
	    var b = bi.toString(2);
	    var padLen = 7 - b.length % 7;
	    if (padLen == 7) padLen = 0;
	    var bPad = '';

	    for (var i = 0; i < padLen; i++) {
	      bPad += '0';
	    }

	    b = bPad + b;

	    for (var i = 0; i < b.length - 1; i += 7) {
	      var b8 = b.substr(i, 7);
	      if (i != b.length - 7) b8 = '1' + b8;
	      h += itox(parseInt(b8, 2));
	    }

	    return h;
	  };

	  KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
	  this.hT = "06";
	  /**
	   * set value by a hexadecimal string
	   * @name setValueHex
	   * @memberOf KJUR.asn1.DERObjectIdentifier#
	   * @function
	   * @param {String} newHexString hexadecimal value of OID bytes
	   */

	  this.setValueHex = function (newHexString) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.s = null;
	    this.hV = newHexString;
	  };
	  /**
	   * set value by a OID string<br/>
	   * @name setValueOidString
	   * @memberOf KJUR.asn1.DERObjectIdentifier#
	   * @function
	   * @param {String} oidString OID string (ex. 2.5.4.13)
	   * @example
	   * o = new KJUR.asn1.DERObjectIdentifier();
	   * o.setValueOidString("2.5.4.13");
	   */


	  this.setValueOidString = function (oidString) {
	    if (!oidString.match(/^[0-9.]+$/)) {
	      throw "malformed oid string: " + oidString;
	    }

	    var h = '';
	    var a = oidString.split('.');
	    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
	    h += itox(i0);
	    a.splice(0, 2);

	    for (var i = 0; i < a.length; i++) {
	      h += roidtox(a[i]);
	    }

	    this.hTLV = null;
	    this.isModified = true;
	    this.s = null;
	    this.hV = h;
	  };
	  /**
	   * set value by a OID name
	   * @name setValueName
	   * @memberOf KJUR.asn1.DERObjectIdentifier#
	   * @function
	   * @param {String} oidName OID name (ex. 'serverAuth')
	   * @since 1.0.1
	   * @description
	   * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
	   * Otherwise raise error.
	   * @example
	   * o = new KJUR.asn1.DERObjectIdentifier();
	   * o.setValueName("serverAuth");
	   */


	  this.setValueName = function (oidName) {
	    var oid = KJUR.asn1.x509.OID.name2oid(oidName);

	    if (oid !== '') {
	      this.setValueOidString(oid);
	    } else {
	      throw "DERObjectIdentifier oidName undefined: " + oidName;
	    }
	  };

	  this.getFreshValueHex = function () {
	    return this.hV;
	  };

	  if (params !== undefined) {
	    if (typeof params === "string") {
	      if (params.match(/^[0-2].[0-9.]+$/)) {
	        this.setValueOidString(params);
	      } else {
	        this.setValueName(params);
	      }
	    } else if (params.oid !== undefined) {
	      this.setValueOidString(params.oid);
	    } else if (params.hex !== undefined) {
	      this.setValueHex(params.hex);
	    } else if (params.name !== undefined) {
	      this.setValueName(params.name);
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object); // ********************************************************************

	/**
	 * class for ASN.1 DER Enumerated
	 * @name KJUR.asn1.DEREnumerated
	 * @class class for ASN.1 DER Enumerated
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>int - specify initial ASN.1 value(V) by integer value</li>
	 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
	 * </ul>
	 * NOTE: 'params' can be omitted.
	 * @example
	 * new KJUR.asn1.DEREnumerated(123);
	 * new KJUR.asn1.DEREnumerated({int: 123});
	 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
	 */

	KJUR.asn1.DEREnumerated = function (params) {
	  KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
	  this.hT = "0a";
	  /**
	   * set value by Tom Wu's BigInteger object
	   * @name setByBigInteger
	   * @memberOf KJUR.asn1.DEREnumerated#
	   * @function
	   * @param {BigInteger} bigIntegerValue to set
	   */

	  this.setByBigInteger = function (bigIntegerValue) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
	  };
	  /**
	   * set value by integer value
	   * @name setByInteger
	   * @memberOf KJUR.asn1.DEREnumerated#
	   * @function
	   * @param {Integer} integer value to set
	   */


	  this.setByInteger = function (intValue) {
	    var bi = new BigInteger(String(intValue), 10);
	    this.setByBigInteger(bi);
	  };
	  /**
	   * set value by integer value
	   * @name setValueHex
	   * @memberOf KJUR.asn1.DEREnumerated#
	   * @function
	   * @param {String} hexadecimal string of integer value
	   * @description
	   * <br/>
	   * NOTE: Value shall be represented by minimum octet length of
	   * two's complement representation.
	   */


	  this.setValueHex = function (newHexString) {
	    this.hV = newHexString;
	  };

	  this.getFreshValueHex = function () {
	    return this.hV;
	  };

	  if (typeof params != "undefined") {
	    if (typeof params['int'] != "undefined") {
	      this.setByInteger(params['int']);
	    } else if (typeof params == "number") {
	      this.setByInteger(params);
	    } else if (typeof params['hex'] != "undefined") {
	      this.setValueHex(params['hex']);
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object); // ********************************************************************

	/**
	 * class for ASN.1 DER UTF8String
	 * @name KJUR.asn1.DERUTF8String
	 * @class class for ASN.1 DER UTF8String
	 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
	 * @extends KJUR.asn1.DERAbstractString
	 * @description
	 * @see KJUR.asn1.DERAbstractString - superclass
	 */

	KJUR.asn1.DERUTF8String = function (params) {
	  KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
	  this.hT = "0c";
	};

	YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString); // ********************************************************************

	/**
	 * class for ASN.1 DER NumericString
	 * @name KJUR.asn1.DERNumericString
	 * @class class for ASN.1 DER NumericString
	 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
	 * @extends KJUR.asn1.DERAbstractString
	 * @description
	 * @see KJUR.asn1.DERAbstractString - superclass
	 */

	KJUR.asn1.DERNumericString = function (params) {
	  KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
	  this.hT = "12";
	};

	YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString); // ********************************************************************

	/**
	 * class for ASN.1 DER PrintableString
	 * @name KJUR.asn1.DERPrintableString
	 * @class class for ASN.1 DER PrintableString
	 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
	 * @extends KJUR.asn1.DERAbstractString
	 * @description
	 * @see KJUR.asn1.DERAbstractString - superclass
	 */

	KJUR.asn1.DERPrintableString = function (params) {
	  KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
	  this.hT = "13";
	};

	YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString); // ********************************************************************

	/**
	 * class for ASN.1 DER TeletexString
	 * @name KJUR.asn1.DERTeletexString
	 * @class class for ASN.1 DER TeletexString
	 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
	 * @extends KJUR.asn1.DERAbstractString
	 * @description
	 * @see KJUR.asn1.DERAbstractString - superclass
	 */

	KJUR.asn1.DERTeletexString = function (params) {
	  KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
	  this.hT = "14";
	};

	YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString); // ********************************************************************

	/**
	 * class for ASN.1 DER IA5String
	 * @name KJUR.asn1.DERIA5String
	 * @class class for ASN.1 DER IA5String
	 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
	 * @extends KJUR.asn1.DERAbstractString
	 * @description
	 * @see KJUR.asn1.DERAbstractString - superclass
	 */

	KJUR.asn1.DERIA5String = function (params) {
	  KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
	  this.hT = "16";
	};

	YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString); // ********************************************************************

	/**
	 * class for ASN.1 DER UTCTime
	 * @name KJUR.asn1.DERUTCTime
	 * @class class for ASN.1 DER UTCTime
	 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
	 * @extends KJUR.asn1.DERAbstractTime
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
	 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
	 * <li>date - specify Date object.</li>
	 * </ul>
	 * NOTE: 'params' can be omitted.
	 * <h4>EXAMPLES</h4>
	 * @example
	 * d1 = new KJUR.asn1.DERUTCTime();
	 * d1.setString('130430125959Z');
	 *
	 * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
	 * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
	 * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
	 */

	KJUR.asn1.DERUTCTime = function (params) {
	  KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
	  this.hT = "17";
	  /**
	   * set value by a Date object<br/>
	   * @name setByDate
	   * @memberOf KJUR.asn1.DERUTCTime#
	   * @function
	   * @param {Date} dateObject Date object to set ASN.1 value(V)
	   * @example
	   * o = new KJUR.asn1.DERUTCTime();
	   * o.setByDate(new Date("2016/12/31"));
	   */

	  this.setByDate = function (dateObject) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.date = dateObject;
	    this.s = this.formatDate(this.date, 'utc');
	    this.hV = stohex(this.s);
	  };

	  this.getFreshValueHex = function () {
	    if (typeof this.date == "undefined" && typeof this.s == "undefined") {
	      this.date = new Date();
	      this.s = this.formatDate(this.date, 'utc');
	      this.hV = stohex(this.s);
	    }

	    return this.hV;
	  };

	  if (params !== undefined) {
	    if (params.str !== undefined) {
	      this.setString(params.str);
	    } else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
	      this.setString(params);
	    } else if (params.hex !== undefined) {
	      this.setStringHex(params.hex);
	    } else if (params.date !== undefined) {
	      this.setByDate(params.date);
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime); // ********************************************************************

	/**
	 * class for ASN.1 DER GeneralizedTime
	 * @name KJUR.asn1.DERGeneralizedTime
	 * @class class for ASN.1 DER GeneralizedTime
	 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
	 * @property {Boolean} withMillis flag to show milliseconds or not
	 * @extends KJUR.asn1.DERAbstractTime
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
	 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
	 * <li>date - specify Date object.</li>
	 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
	 * </ul>
	 * NOTE1: 'params' can be omitted.
	 * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
	 */

	KJUR.asn1.DERGeneralizedTime = function (params) {
	  KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
	  this.hT = "18";
	  this.withMillis = false;
	  /**
	   * set value by a Date object
	   * @name setByDate
	   * @memberOf KJUR.asn1.DERGeneralizedTime#
	   * @function
	   * @param {Date} dateObject Date object to set ASN.1 value(V)
	   * @example
	   * When you specify UTC time, use 'Date.UTC' method like this:<br/>
	   * o1 = new DERUTCTime();
	   * o1.setByDate(date);
	   *
	   * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
	   */

	  this.setByDate = function (dateObject) {
	    this.hTLV = null;
	    this.isModified = true;
	    this.date = dateObject;
	    this.s = this.formatDate(this.date, 'gen', this.withMillis);
	    this.hV = stohex(this.s);
	  };

	  this.getFreshValueHex = function () {
	    if (this.date === undefined && this.s === undefined) {
	      this.date = new Date();
	      this.s = this.formatDate(this.date, 'gen', this.withMillis);
	      this.hV = stohex(this.s);
	    }

	    return this.hV;
	  };

	  if (params !== undefined) {
	    if (params.str !== undefined) {
	      this.setString(params.str);
	    } else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
	      this.setString(params);
	    } else if (params.hex !== undefined) {
	      this.setStringHex(params.hex);
	    } else if (params.date !== undefined) {
	      this.setByDate(params.date);
	    }

	    if (params.millis === true) {
	      this.withMillis = true;
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime); // ********************************************************************

	/**
	 * class for ASN.1 DER Sequence
	 * @name KJUR.asn1.DERSequence
	 * @class class for ASN.1 DER Sequence
	 * @extends KJUR.asn1.DERAbstractStructured
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>array - specify array of ASN1Object to set elements of content</li>
	 * </ul>
	 * NOTE: 'params' can be omitted.
	 */

	KJUR.asn1.DERSequence = function (params) {
	  KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
	  this.hT = "30";

	  this.getFreshValueHex = function () {
	    var h = '';

	    for (var i = 0; i < this.asn1Array.length; i++) {
	      var asn1Obj = this.asn1Array[i];
	      h += asn1Obj.getEncodedHex();
	    }

	    this.hV = h;
	    return this.hV;
	  };
	};

	YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured); // ********************************************************************

	/**
	 * class for ASN.1 DER Set
	 * @name KJUR.asn1.DERSet
	 * @class class for ASN.1 DER Set
	 * @extends KJUR.asn1.DERAbstractStructured
	 * @description
	 * <br/>
	 * As for argument 'params' for constructor, you can specify one of
	 * following properties:
	 * <ul>
	 * <li>array - specify array of ASN1Object to set elements of content</li>
	 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
	 * </ul>
	 * NOTE1: 'params' can be omitted.<br/>
	 * NOTE2: sortflag is supported since 1.0.5.
	 */

	KJUR.asn1.DERSet = function (params) {
	  KJUR.asn1.DERSet.superclass.constructor.call(this, params);
	  this.hT = "31";
	  this.sortFlag = true; // item shall be sorted only in ASN.1 DER

	  this.getFreshValueHex = function () {
	    var a = new Array();

	    for (var i = 0; i < this.asn1Array.length; i++) {
	      var asn1Obj = this.asn1Array[i];
	      a.push(asn1Obj.getEncodedHex());
	    }

	    if (this.sortFlag == true) a.sort();
	    this.hV = a.join('');
	    return this.hV;
	  };

	  if (typeof params != "undefined") {
	    if (typeof params.sortflag != "undefined" && params.sortflag == false) this.sortFlag = false;
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured); // ********************************************************************

	/**
	 * class for ASN.1 DER TaggedObject
	 * @name KJUR.asn1.DERTaggedObject
	 * @class class for ASN.1 DER TaggedObject
	 * @extends KJUR.asn1.ASN1Object
	 * @description
	 * <br/>
	 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
	 * For example, if you find '[1]' tag in a ASN.1 dump,
	 * 'tagNoHex' will be 'a1'.
	 * <br/>
	 * As for optional argument 'params' for constructor, you can specify *ANY* of
	 * following properties:
	 * <ul>
	 * <li>explicit - specify true if this is explicit tag otherwise false
	 *     (default is 'true').</li>
	 * <li>tag - specify tag (default is 'a0' which means [0])</li>
	 * <li>obj - specify ASN1Object which is tagged</li>
	 * </ul>
	 * @example
	 * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
	 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
	 * hex = d2.getEncodedHex();
	 */

	KJUR.asn1.DERTaggedObject = function (params) {
	  KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
	  this.hT = "a0";
	  this.hV = '';
	  this.isExplicit = true;
	  this.asn1Object = null;
	  /**
	   * set value by an ASN1Object
	   * @name setString
	   * @memberOf KJUR.asn1.DERTaggedObject#
	   * @function
	   * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
	   * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
	   * @param {ASN1Object} asn1Object ASN.1 to encapsulate
	   */

	  this.setASN1Object = function (isExplicitFlag, tagNoHex, asn1Object) {
	    this.hT = tagNoHex;
	    this.isExplicit = isExplicitFlag;
	    this.asn1Object = asn1Object;

	    if (this.isExplicit) {
	      this.hV = this.asn1Object.getEncodedHex();
	      this.hTLV = null;
	      this.isModified = true;
	    } else {
	      this.hV = null;
	      this.hTLV = asn1Object.getEncodedHex();
	      this.hTLV = this.hTLV.replace(/^../, tagNoHex);
	      this.isModified = false;
	    }
	  };

	  this.getFreshValueHex = function () {
	    return this.hV;
	  };

	  if (typeof params != "undefined") {
	    if (typeof params['tag'] != "undefined") {
	      this.hT = params['tag'];
	    }

	    if (typeof params['explicit'] != "undefined") {
	      this.isExplicit = params['explicit'];
	    }

	    if (typeof params['obj'] != "undefined") {
	      this.asn1Object = params['obj'];
	      this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
	    }
	  }
	};

	YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

	var __extends = undefined && undefined.__extends || function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) {
	        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	      }
	    };

	    return _extendStatics(d, b);
	  };

	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

	    _extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	/**
	 * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
	 * This object is just a decorator for parsing the key parameter
	 * @param {string|Object} key - The key in string format, or an object containing
	 * the parameters needed to build a RSAKey object.
	 * @constructor
	 */

	var JSEncryptRSAKey =
	/** @class */
	function (_super) {
	  __extends(JSEncryptRSAKey, _super);

	  function JSEncryptRSAKey(key) {
	    var _this = _super.call(this) || this; // Call the super constructor.
	    //  RSAKey.call(this);
	    // If a key key was provided.


	    if (key) {
	      // If this is a string...
	      if (typeof key === "string") {
	        _this.parseKey(key);
	      } else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) || JSEncryptRSAKey.hasPublicKeyProperty(key)) {
	        // Set the values for the key.
	        _this.parsePropertiesFrom(key);
	      }
	    }

	    return _this;
	  }
	  /**
	   * Method to parse a pem encoded string containing both a public or private key.
	   * The method will translate the pem encoded string in a der encoded string and
	   * will parse private key and public key parameters. This method accepts public key
	   * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
	   *
	   * @todo Check how many rsa formats use the same format of pkcs #1.
	   *
	   * The format is defined as:
	   * PublicKeyInfo ::= SEQUENCE {
	   *   algorithm       AlgorithmIdentifier,
	   *   PublicKey       BIT STRING
	   * }
	   * Where AlgorithmIdentifier is:
	   * AlgorithmIdentifier ::= SEQUENCE {
	   *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
	   *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
	   * }
	   * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
	   * RSAPublicKey ::= SEQUENCE {
	   *   modulus           INTEGER,  -- n
	   *   publicExponent    INTEGER   -- e
	   * }
	   * it's possible to examine the structure of the keys obtained from openssl using
	   * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
	   * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
	   * @private
	   */


	  JSEncryptRSAKey.prototype.parseKey = function (pem) {
	    try {
	      var modulus = 0;
	      var public_exponent = 0;
	      var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
	      var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
	      var asn1 = ASN1.decode(der); // Fixes a bug with OpenSSL 1.0+ private keys

	      if (asn1.sub.length === 3) {
	        asn1 = asn1.sub[2].sub[0];
	      }

	      if (asn1.sub.length === 9) {
	        // Parse the private key.
	        modulus = asn1.sub[1].getHexStringValue(); // bigint

	        this.n = parseBigInt(modulus, 16);
	        public_exponent = asn1.sub[2].getHexStringValue(); // int

	        this.e = parseInt(public_exponent, 16);
	        var private_exponent = asn1.sub[3].getHexStringValue(); // bigint

	        this.d = parseBigInt(private_exponent, 16);
	        var prime1 = asn1.sub[4].getHexStringValue(); // bigint

	        this.p = parseBigInt(prime1, 16);
	        var prime2 = asn1.sub[5].getHexStringValue(); // bigint

	        this.q = parseBigInt(prime2, 16);
	        var exponent1 = asn1.sub[6].getHexStringValue(); // bigint

	        this.dmp1 = parseBigInt(exponent1, 16);
	        var exponent2 = asn1.sub[7].getHexStringValue(); // bigint

	        this.dmq1 = parseBigInt(exponent2, 16);
	        var coefficient = asn1.sub[8].getHexStringValue(); // bigint

	        this.coeff = parseBigInt(coefficient, 16);
	      } else if (asn1.sub.length === 2) {
	        // Parse the public key.
	        var bit_string = asn1.sub[1];
	        var sequence = bit_string.sub[0];
	        modulus = sequence.sub[0].getHexStringValue();
	        this.n = parseBigInt(modulus, 16);
	        public_exponent = sequence.sub[1].getHexStringValue();
	        this.e = parseInt(public_exponent, 16);
	      } else {
	        return false;
	      }

	      return true;
	    } catch (ex) {
	      return false;
	    }
	  };
	  /**
	   * Translate rsa parameters in a hex encoded string representing the rsa key.
	   *
	   * The translation follow the ASN.1 notation :
	   * RSAPrivateKey ::= SEQUENCE {
	   *   version           Version,
	   *   modulus           INTEGER,  -- n
	   *   publicExponent    INTEGER,  -- e
	   *   privateExponent   INTEGER,  -- d
	   *   prime1            INTEGER,  -- p
	   *   prime2            INTEGER,  -- q
	   *   exponent1         INTEGER,  -- d mod (p1)
	   *   exponent2         INTEGER,  -- d mod (q-1)
	   *   coefficient       INTEGER,  -- (inverse of q) mod p
	   * }
	   * @returns {string}  DER Encoded String representing the rsa private key
	   * @private
	   */


	  JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
	    var options = {
	      array: [new KJUR.asn1.DERInteger({
	        "int": 0
	      }), new KJUR.asn1.DERInteger({
	        bigint: this.n
	      }), new KJUR.asn1.DERInteger({
	        "int": this.e
	      }), new KJUR.asn1.DERInteger({
	        bigint: this.d
	      }), new KJUR.asn1.DERInteger({
	        bigint: this.p
	      }), new KJUR.asn1.DERInteger({
	        bigint: this.q
	      }), new KJUR.asn1.DERInteger({
	        bigint: this.dmp1
	      }), new KJUR.asn1.DERInteger({
	        bigint: this.dmq1
	      }), new KJUR.asn1.DERInteger({
	        bigint: this.coeff
	      })]
	    };
	    var seq = new KJUR.asn1.DERSequence(options);
	    return seq.getEncodedHex();
	  };
	  /**
	   * base64 (pem) encoded version of the DER encoded representation
	   * @returns {string} pem encoded representation without header and footer
	   * @public
	   */


	  JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
	    return hex2b64(this.getPrivateBaseKey());
	  };
	  /**
	   * Translate rsa parameters in a hex encoded string representing the rsa public key.
	   * The representation follow the ASN.1 notation :
	   * PublicKeyInfo ::= SEQUENCE {
	   *   algorithm       AlgorithmIdentifier,
	   *   PublicKey       BIT STRING
	   * }
	   * Where AlgorithmIdentifier is:
	   * AlgorithmIdentifier ::= SEQUENCE {
	   *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
	   *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
	   * }
	   * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
	   * RSAPublicKey ::= SEQUENCE {
	   *   modulus           INTEGER,  -- n
	   *   publicExponent    INTEGER   -- e
	   * }
	   * @returns {string} DER Encoded String representing the rsa public key
	   * @private
	   */


	  JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
	    var first_sequence = new KJUR.asn1.DERSequence({
	      array: [new KJUR.asn1.DERObjectIdentifier({
	        oid: "1.2.840.113549.1.1.1"
	      }), new KJUR.asn1.DERNull()]
	    });
	    var second_sequence = new KJUR.asn1.DERSequence({
	      array: [new KJUR.asn1.DERInteger({
	        bigint: this.n
	      }), new KJUR.asn1.DERInteger({
	        "int": this.e
	      })]
	    });
	    var bit_string = new KJUR.asn1.DERBitString({
	      hex: "00" + second_sequence.getEncodedHex()
	    });
	    var seq = new KJUR.asn1.DERSequence({
	      array: [first_sequence, bit_string]
	    });
	    return seq.getEncodedHex();
	  };
	  /**
	   * base64 (pem) encoded version of the DER encoded representation
	   * @returns {string} pem encoded representation without header and footer
	   * @public
	   */


	  JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
	    return hex2b64(this.getPublicBaseKey());
	  };
	  /**
	   * wrap the string in block of width chars. The default value for rsa keys is 64
	   * characters.
	   * @param {string} str the pem encoded string without header and footer
	   * @param {Number} [width=64] - the length the string has to be wrapped at
	   * @returns {string}
	   * @private
	   */


	  JSEncryptRSAKey.wordwrap = function (str, width) {
	    width = width || 64;

	    if (!str) {
	      return str;
	    }

	    var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
	    return str.match(RegExp(regex, "g")).join("\n");
	  };
	  /**
	   * Retrieve the pem encoded private key
	   * @returns {string} the pem encoded private key with header/footer
	   * @public
	   */


	  JSEncryptRSAKey.prototype.getPrivateKey = function () {
	    var key = "-----BEGIN RSA PRIVATE KEY-----\n";
	    key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
	    key += "-----END RSA PRIVATE KEY-----";
	    return key;
	  };
	  /**
	   * Retrieve the pem encoded public key
	   * @returns {string} the pem encoded public key with header/footer
	   * @public
	   */


	  JSEncryptRSAKey.prototype.getPublicKey = function () {
	    var key = "-----BEGIN PUBLIC KEY-----\n";
	    key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
	    key += "-----END PUBLIC KEY-----";
	    return key;
	  };
	  /**
	   * Check if the object contains the necessary parameters to populate the rsa modulus
	   * and public exponent parameters.
	   * @param {Object} [obj={}] - An object that may contain the two public key
	   * parameters
	   * @returns {boolean} true if the object contains both the modulus and the public exponent
	   * properties (n and e)
	   * @todo check for types of n and e. N should be a parseable bigInt object, E should
	   * be a parseable integer number
	   * @private
	   */


	  JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
	    obj = obj || {};
	    return obj.hasOwnProperty("n") && obj.hasOwnProperty("e");
	  };
	  /**
	   * Check if the object contains ALL the parameters of an RSA key.
	   * @param {Object} [obj={}] - An object that may contain nine rsa key
	   * parameters
	   * @returns {boolean} true if the object contains all the parameters needed
	   * @todo check for types of the parameters all the parameters but the public exponent
	   * should be parseable bigint objects, the public exponent should be a parseable integer number
	   * @private
	   */


	  JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
	    obj = obj || {};
	    return obj.hasOwnProperty("n") && obj.hasOwnProperty("e") && obj.hasOwnProperty("d") && obj.hasOwnProperty("p") && obj.hasOwnProperty("q") && obj.hasOwnProperty("dmp1") && obj.hasOwnProperty("dmq1") && obj.hasOwnProperty("coeff");
	  };
	  /**
	   * Parse the properties of obj in the current rsa object. Obj should AT LEAST
	   * include the modulus and public exponent (n, e) parameters.
	   * @param {Object} obj - the object containing rsa parameters
	   * @private
	   */


	  JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
	    this.n = obj.n;
	    this.e = obj.e;

	    if (obj.hasOwnProperty("d")) {
	      this.d = obj.d;
	      this.p = obj.p;
	      this.q = obj.q;
	      this.dmp1 = obj.dmp1;
	      this.dmq1 = obj.dmq1;
	      this.coeff = obj.coeff;
	    }
	  };

	  return JSEncryptRSAKey;
	}(RSAKey);

	var version = "3.2.1";
	var version$1 = {
		version: version
	};

	/**
	 *
	 * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
	 * possible parameters are:
	 * - default_key_size        {number}  default: 1024 the key size in bit
	 * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
	 * - log                     {boolean} default: false whether log warn/error or not
	 * @constructor
	 */

	var JSEncrypt =
	/** @class */
	function () {
	  function JSEncrypt(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    options = options || {};
	    this.default_key_size = options.default_key_size ? parseInt(options.default_key_size, 10) : 1024;
	    this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type

	    this.log = options.log || false; // The private and public key.

	    this.key = null;
	  }
	  /**
	   * Method to set the rsa key parameter (one method is enough to set both the public
	   * and the private key, since the private key contains the public key paramenters)
	   * Log a warning if logs are enabled
	   * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
	   * @public
	   */


	  JSEncrypt.prototype.setKey = function (key) {
	    if (this.log && this.key) {
	      console.warn("A key was already set, overriding existing.");
	    }

	    this.key = new JSEncryptRSAKey(key);
	  };
	  /**
	   * Proxy method for setKey, for api compatibility
	   * @see setKey
	   * @public
	   */


	  JSEncrypt.prototype.setPrivateKey = function (privkey) {
	    // Create the key.
	    this.setKey(privkey);
	  };
	  /**
	   * Proxy method for setKey, for api compatibility
	   * @see setKey
	   * @public
	   */


	  JSEncrypt.prototype.setPublicKey = function (pubkey) {
	    // Sets the public key.
	    this.setKey(pubkey);
	  };
	  /**
	   * Proxy method for RSAKey object's decrypt, decrypt the string using the private
	   * components of the rsa key object. Note that if the object was not set will be created
	   * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
	   * @param {string} str base64 encoded crypted string to decrypt
	   * @return {string} the decrypted string
	   * @public
	   */


	  JSEncrypt.prototype.decrypt = function (str) {
	    // Return the decrypted string.
	    try {
	      return this.getKey().decrypt(b64tohex(str));
	    } catch (ex) {
	      return false;
	    }
	  };
	  /**
	   * Proxy method for RSAKey object's encrypt, encrypt the string using the public
	   * components of the rsa key object. Note that if the object was not set will be created
	   * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
	   * @param {string} str the string to encrypt
	   * @return {string} the encrypted string encoded in base64
	   * @public
	   */


	  JSEncrypt.prototype.encrypt = function (str) {
	    // Return the encrypted string.
	    try {
	      return hex2b64(this.getKey().encrypt(str));
	    } catch (ex) {
	      return false;
	    }
	  };
	  /**
	   * Proxy method for RSAKey object's sign.
	   * @param {string} str the string to sign
	   * @param {function} digestMethod hash method
	   * @param {string} digestName the name of the hash algorithm
	   * @return {string} the signature encoded in base64
	   * @public
	   */


	  JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
	    // return the RSA signature of 'str' in 'hex' format.
	    try {
	      return hex2b64(this.getKey().sign(str, digestMethod, digestName));
	    } catch (ex) {
	      return false;
	    }
	  };
	  /**
	   * Proxy method for RSAKey object's verify.
	   * @param {string} str the string to verify
	   * @param {string} signature the signature encoded in base64 to compare the string to
	   * @param {function} digestMethod hash method
	   * @return {boolean} whether the data and signature match
	   * @public
	   */


	  JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
	    // Return the decrypted 'digest' of the signature.
	    try {
	      return this.getKey().verify(str, b64tohex(signature), digestMethod);
	    } catch (ex) {
	      return false;
	    }
	  };
	  /**
	   * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
	   * will be created and returned
	   * @param {callback} [cb] the callback to be called if we want the key to be generated
	   * in an async fashion
	   * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
	   * @public
	   */


	  JSEncrypt.prototype.getKey = function (cb) {
	    // Only create new if it does not exist.
	    if (!this.key) {
	      // Get a new private key.
	      this.key = new JSEncryptRSAKey();

	      if (cb && {}.toString.call(cb) === "[object Function]") {
	        this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
	        return;
	      } // Generate the key.


	      this.key.generate(this.default_key_size, this.default_public_exponent);
	    }

	    return this.key;
	  };
	  /**
	   * Returns the pem encoded representation of the private key
	   * If the key doesn't exists a new key will be created
	   * @returns {string} pem encoded representation of the private key WITH header and footer
	   * @public
	   */


	  JSEncrypt.prototype.getPrivateKey = function () {
	    // Return the private representation of this key.
	    return this.getKey().getPrivateKey();
	  };
	  /**
	   * Returns the pem encoded representation of the private key
	   * If the key doesn't exists a new key will be created
	   * @returns {string} pem encoded representation of the private key WITHOUT header and footer
	   * @public
	   */


	  JSEncrypt.prototype.getPrivateKeyB64 = function () {
	    // Return the private representation of this key.
	    return this.getKey().getPrivateBaseKeyB64();
	  };
	  /**
	   * Returns the pem encoded representation of the public key
	   * If the key doesn't exists a new key will be created
	   * @returns {string} pem encoded representation of the public key WITH header and footer
	   * @public
	   */


	  JSEncrypt.prototype.getPublicKey = function () {
	    // Return the private representation of this key.
	    return this.getKey().getPublicKey();
	  };
	  /**
	   * Returns the pem encoded representation of the public key
	   * If the key doesn't exists a new key will be created
	   * @returns {string} pem encoded representation of the public key WITHOUT header and footer
	   * @public
	   */


	  JSEncrypt.prototype.getPublicKeyB64 = function () {
	    // Return the private representation of this key.
	    return this.getKey().getPublicBaseKeyB64();
	  };

	  JSEncrypt.version = version$1.version;
	  return JSEncrypt;
	}();

	var aTypedArray = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.at` method
	// https://github.com/tc39/proposal-relative-indexing-method

	exportTypedArrayMethod('at', function at(index) {
	  var O = aTypedArray(this);
	  var len = lengthOfArrayLike(O);
	  var relativeIndex = toIntegerOrInfinity(index);
	  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
	  return k < 0 || k >= len ? undefined : O[k];
	});

	var stringSlice$1 = functionUncurryThis(''.slice);
	var max = Math.max;
	var min = Math.min; // eslint-disable-next-line unicorn/prefer-string-slice -- required for testing

	var FORCED$1 = !''.substr || 'ab'.substr(-1) !== 'b'; // `String.prototype.substr` method
	// https://tc39.es/ecma262/#sec-string.prototype.substr

	_export({
	  target: 'String',
	  proto: true,
	  forced: FORCED$1
	}, {
	  substr: function substr(start, length) {
	    var that = toString_1(requireObjectCoercible(this));
	    var size = that.length;
	    var intStart = toIntegerOrInfinity(start);
	    var intLength, intEnd;
	    if (intStart === Infinity) intStart = 0;
	    if (intStart < 0) intStart = max(size + intStart, 0);
	    intLength = length === undefined ? size : toIntegerOrInfinity(length);
	    if (intLength <= 0 || intLength === Infinity) return '';
	    intEnd = min(intStart + intLength, size);
	    return intStart >= intEnd ? '' : stringSlice$1(that, intStart, intEnd);
	  }
	});

	var charAt$3 = functionUncurryThis(''.charAt);
	var charCodeAt$2 = functionUncurryThis(''.charCodeAt);
	var exec$2 = functionUncurryThis(/./.exec);
	var numberToString$1 = functionUncurryThis(1.0.toString);
	var toUpperCase = functionUncurryThis(''.toUpperCase);
	var raw = /[\w*+\-./@]/;

	var hex = function hex(code, length) {
	  var result = numberToString$1(code, 16);

	  while (result.length < length) {
	    result = '0' + result;
	  }

	  return result;
	}; // `escape` method
	// https://tc39.es/ecma262/#sec-escape-string


	_export({
	  global: true
	}, {
	  escape: function escape(string) {
	    var str = toString_1(string);
	    var result = '';
	    var length = str.length;
	    var index = 0;
	    var chr, code;

	    while (index < length) {
	      chr = charAt$3(str, index++);

	      if (exec$2(raw, chr)) {
	        result += chr;
	      } else {
	        code = charCodeAt$2(chr, 0);

	        if (code < 256) {
	          result += '%' + hex(code, 2);
	        } else {
	          result += '%u' + toUpperCase(hex(code, 4));
	        }
	      }
	    }

	    return result;
	  }
	});

	var fromCharCode = String.fromCharCode;
	var charAt$2 = functionUncurryThis(''.charAt);
	var exec$1 = functionUncurryThis(/./.exec);
	var stringSlice = functionUncurryThis(''.slice);
	var hex2 = /^[\da-f]{2}$/i;
	var hex4 = /^[\da-f]{4}$/i; // `unescape` method
	// https://tc39.es/ecma262/#sec-unescape-string

	_export({
	  global: true
	}, {
	  unescape: function unescape(string) {
	    var str = toString_1(string);
	    var result = '';
	    var length = str.length;
	    var index = 0;
	    var chr, part;

	    while (index < length) {
	      chr = charAt$2(str, index++);

	      if (chr === '%') {
	        if (charAt$2(str, index) === 'u') {
	          part = stringSlice(str, index + 1, index + 5);

	          if (exec$1(hex4, part)) {
	            result += fromCharCode(parseInt(part, 16));
	            index += 5;
	            continue;
	          }
	        } else {
	          part = stringSlice(str, index, index + 2);

	          if (exec$1(hex2, part)) {
	            result += fromCharCode(parseInt(part, 16));
	            index += 2;
	            continue;
	          }
	        }
	      }

	      result += chr;
	    }

	    return result;
	  }
	});

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': _nodeResolve_empty
	});

	var require$$42 = getCjsExportFromNamespace(_nodeResolve_empty$1);

	var core = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory();
	  } else {
	    // Global (browser)
	    root.CryptoJS = factory();
	  }
	})(commonjsGlobal, function () {
	  /*globals window, global, require*/

	  /**
	   * CryptoJS core components.
	   */
	  var CryptoJS = CryptoJS || function (Math, undefined$1) {
	    var crypto; // Native crypto from window (Browser)

	    if (typeof window !== 'undefined' && window.crypto) {
	      crypto = window.crypto;
	    } // Native crypto in web worker (Browser)


	    if (typeof self !== 'undefined' && self.crypto) {
	      crypto = self.crypto;
	    } // Native crypto from worker


	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	      crypto = globalThis.crypto;
	    } // Native (experimental IE 11) crypto from window (Browser)


	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	      crypto = window.msCrypto;
	    } // Native crypto from global (NodeJS)


	    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
	      crypto = commonjsGlobal.crypto;
	    } // Native crypto import via require (NodeJS)


	    if (!crypto && typeof require === 'function') {
	      try {
	        crypto = require$$42;
	      } catch (err) {}
	    }
	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */


	    var cryptoSecureRandomInt = function cryptoSecureRandomInt() {
	      if (crypto) {
	        // Use getRandomValues method (Browser)
	        if (typeof crypto.getRandomValues === 'function') {
	          try {
	            return crypto.getRandomValues(new Uint32Array(1))[0];
	          } catch (err) {}
	        } // Use randomBytes method (NodeJS)


	        if (typeof crypto.randomBytes === 'function') {
	          try {
	            return crypto.randomBytes(4).readInt32LE();
	          } catch (err) {}
	        }
	      }

	      throw new Error('Native crypto module could not be used to get secure random number.');
	    };
	    /*
	     * Local polyfill of Object.create
	      */


	    var create = Object.create || function () {
	      function F() {}

	      return function (obj) {
	        var subtype;
	        F.prototype = obj;
	        subtype = new F();
	        F.prototype = null;
	        return subtype;
	      };
	    }();
	    /**
	     * CryptoJS namespace.
	     */


	    var C = {};
	    /**
	     * Library namespace.
	     */

	    var C_lib = C.lib = {};
	    /**
	     * Base object for prototypal inheritance.
	     */

	    var Base = C_lib.Base = function () {
	      return {
	        /**
	         * Creates a new object that inherits from this object.
	         *
	         * @param {Object} overrides Properties to copy into the new object.
	         *
	         * @return {Object} The new object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var MyType = CryptoJS.lib.Base.extend({
	         *         field: 'value',
	         *
	         *         method: function () {
	         *         }
	         *     });
	         */
	        extend: function extend(overrides) {
	          // Spawn
	          var subtype = create(this); // Augment

	          if (overrides) {
	            subtype.mixIn(overrides);
	          } // Create default initializer


	          if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	            subtype.init = function () {
	              subtype.$super.init.apply(this, arguments);
	            };
	          } // Initializer's prototype is the subtype object


	          subtype.init.prototype = subtype; // Reference supertype

	          subtype.$super = this;
	          return subtype;
	        },

	        /**
	         * Extends this object and runs the init method.
	         * Arguments to create() will be passed to init().
	         *
	         * @return {Object} The new object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var instance = MyType.create();
	         */
	        create: function create() {
	          var instance = this.extend();
	          instance.init.apply(instance, arguments);
	          return instance;
	        },

	        /**
	         * Initializes a newly created object.
	         * Override this method to add some logic when your objects are created.
	         *
	         * @example
	         *
	         *     var MyType = CryptoJS.lib.Base.extend({
	         *         init: function () {
	         *             // ...
	         *         }
	         *     });
	         */
	        init: function init() {},

	        /**
	         * Copies properties into this object.
	         *
	         * @param {Object} properties The properties to mix in.
	         *
	         * @example
	         *
	         *     MyType.mixIn({
	         *         field: 'value'
	         *     });
	         */
	        mixIn: function mixIn(properties) {
	          for (var propertyName in properties) {
	            if (properties.hasOwnProperty(propertyName)) {
	              this[propertyName] = properties[propertyName];
	            }
	          } // IE won't copy toString using the loop above


	          if (properties.hasOwnProperty('toString')) {
	            this.toString = properties.toString;
	          }
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = instance.clone();
	         */
	        clone: function clone() {
	          return this.init.prototype.extend(this);
	        }
	      };
	    }();
	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */


	    var WordArray = C_lib.WordArray = Base.extend({
	      /**
	       * Initializes a newly created word array.
	       *
	       * @param {Array} words (Optional) An array of 32-bit words.
	       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.lib.WordArray.create();
	       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	       */
	      init: function init(words, sigBytes) {
	        words = this.words = words || [];

	        if (sigBytes != undefined$1) {
	          this.sigBytes = sigBytes;
	        } else {
	          this.sigBytes = words.length * 4;
	        }
	      },

	      /**
	       * Converts this word array to a string.
	       *
	       * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	       *
	       * @return {string} The stringified word array.
	       *
	       * @example
	       *
	       *     var string = wordArray + '';
	       *     var string = wordArray.toString();
	       *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	       */
	      toString: function toString(encoder) {
	        return (encoder || Hex).stringify(this);
	      },

	      /**
	       * Concatenates a word array to this word array.
	       *
	       * @param {WordArray} wordArray The word array to append.
	       *
	       * @return {WordArray} This word array.
	       *
	       * @example
	       *
	       *     wordArray1.concat(wordArray2);
	       */
	      concat: function concat(wordArray) {
	        // Shortcuts
	        var thisWords = this.words;
	        var thatWords = wordArray.words;
	        var thisSigBytes = this.sigBytes;
	        var thatSigBytes = wordArray.sigBytes; // Clamp excess bits

	        this.clamp(); // Concat

	        if (thisSigBytes % 4) {
	          // Copy one byte at a time
	          for (var i = 0; i < thatSigBytes; i++) {
	            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
	            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
	          }
	        } else {
	          // Copy one word at a time
	          for (var j = 0; j < thatSigBytes; j += 4) {
	            thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
	          }
	        }

	        this.sigBytes += thatSigBytes; // Chainable

	        return this;
	      },

	      /**
	       * Removes insignificant bits.
	       *
	       * @example
	       *
	       *     wordArray.clamp();
	       */
	      clamp: function clamp() {
	        // Shortcuts
	        var words = this.words;
	        var sigBytes = this.sigBytes; // Clamp

	        words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
	        words.length = Math.ceil(sigBytes / 4);
	      },

	      /**
	       * Creates a copy of this word array.
	       *
	       * @return {WordArray} The clone.
	       *
	       * @example
	       *
	       *     var clone = wordArray.clone();
	       */
	      clone: function clone() {
	        var clone = Base.clone.call(this);
	        clone.words = this.words.slice(0);
	        return clone;
	      },

	      /**
	       * Creates a word array filled with random bytes.
	       *
	       * @param {number} nBytes The number of random bytes to generate.
	       *
	       * @return {WordArray} The random word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.lib.WordArray.random(16);
	       */
	      random: function random(nBytes) {
	        var words = [];

	        for (var i = 0; i < nBytes; i += 4) {
	          words.push(cryptoSecureRandomInt());
	        }

	        return new WordArray.init(words, nBytes);
	      }
	    });
	    /**
	     * Encoder namespace.
	     */

	    var C_enc = C.enc = {};
	    /**
	     * Hex encoding strategy.
	     */

	    var Hex = C_enc.Hex = {
	      /**
	       * Converts a word array to a hex string.
	       *
	       * @param {WordArray} wordArray The word array.
	       *
	       * @return {string} The hex string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	       */
	      stringify: function stringify(wordArray) {
	        // Shortcuts
	        var words = wordArray.words;
	        var sigBytes = wordArray.sigBytes; // Convert

	        var hexChars = [];

	        for (var i = 0; i < sigBytes; i++) {
	          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
	          hexChars.push((bite >>> 4).toString(16));
	          hexChars.push((bite & 0x0f).toString(16));
	        }

	        return hexChars.join('');
	      },

	      /**
	       * Converts a hex string to a word array.
	       *
	       * @param {string} hexStr The hex string.
	       *
	       * @return {WordArray} The word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	       */
	      parse: function parse(hexStr) {
	        // Shortcut
	        var hexStrLength = hexStr.length; // Convert

	        var words = [];

	        for (var i = 0; i < hexStrLength; i += 2) {
	          words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
	        }

	        return new WordArray.init(words, hexStrLength / 2);
	      }
	    };
	    /**
	     * Latin1 encoding strategy.
	     */

	    var Latin1 = C_enc.Latin1 = {
	      /**
	       * Converts a word array to a Latin1 string.
	       *
	       * @param {WordArray} wordArray The word array.
	       *
	       * @return {string} The Latin1 string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	       */
	      stringify: function stringify(wordArray) {
	        // Shortcuts
	        var words = wordArray.words;
	        var sigBytes = wordArray.sigBytes; // Convert

	        var latin1Chars = [];

	        for (var i = 0; i < sigBytes; i++) {
	          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
	          latin1Chars.push(String.fromCharCode(bite));
	        }

	        return latin1Chars.join('');
	      },

	      /**
	       * Converts a Latin1 string to a word array.
	       *
	       * @param {string} latin1Str The Latin1 string.
	       *
	       * @return {WordArray} The word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	       */
	      parse: function parse(latin1Str) {
	        // Shortcut
	        var latin1StrLength = latin1Str.length; // Convert

	        var words = [];

	        for (var i = 0; i < latin1StrLength; i++) {
	          words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
	        }

	        return new WordArray.init(words, latin1StrLength);
	      }
	    };
	    /**
	     * UTF-8 encoding strategy.
	     */

	    var Utf8 = C_enc.Utf8 = {
	      /**
	       * Converts a word array to a UTF-8 string.
	       *
	       * @param {WordArray} wordArray The word array.
	       *
	       * @return {string} The UTF-8 string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	       */
	      stringify: function stringify(wordArray) {
	        try {
	          return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	        } catch (e) {
	          throw new Error('Malformed UTF-8 data');
	        }
	      },

	      /**
	       * Converts a UTF-8 string to a word array.
	       *
	       * @param {string} utf8Str The UTF-8 string.
	       *
	       * @return {WordArray} The word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	       */
	      parse: function parse(utf8Str) {
	        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	      }
	    };
	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */

	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	      /**
	       * Resets this block algorithm's data buffer to its initial state.
	       *
	       * @example
	       *
	       *     bufferedBlockAlgorithm.reset();
	       */
	      reset: function reset() {
	        // Initial values
	        this._data = new WordArray.init();
	        this._nDataBytes = 0;
	      },

	      /**
	       * Adds new data to this block algorithm's buffer.
	       *
	       * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	       *
	       * @example
	       *
	       *     bufferedBlockAlgorithm._append('data');
	       *     bufferedBlockAlgorithm._append(wordArray);
	       */
	      _append: function _append(data) {
	        // Convert string to WordArray, else assume WordArray already
	        if (typeof data == 'string') {
	          data = Utf8.parse(data);
	        } // Append


	        this._data.concat(data);

	        this._nDataBytes += data.sigBytes;
	      },

	      /**
	       * Processes available data blocks.
	       *
	       * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	       *
	       * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	       *
	       * @return {WordArray} The processed data.
	       *
	       * @example
	       *
	       *     var processedData = bufferedBlockAlgorithm._process();
	       *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	       */
	      _process: function _process(doFlush) {
	        var processedWords; // Shortcuts

	        var data = this._data;
	        var dataWords = data.words;
	        var dataSigBytes = data.sigBytes;
	        var blockSize = this.blockSize;
	        var blockSizeBytes = blockSize * 4; // Count blocks ready

	        var nBlocksReady = dataSigBytes / blockSizeBytes;

	        if (doFlush) {
	          // Round up to include partial blocks
	          nBlocksReady = Math.ceil(nBlocksReady);
	        } else {
	          // Round down to include only full blocks,
	          // less the number of blocks that must remain in the buffer
	          nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	        } // Count words ready


	        var nWordsReady = nBlocksReady * blockSize; // Count bytes ready

	        var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); // Process blocks

	        if (nWordsReady) {
	          for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	            // Perform concrete-algorithm logic
	            this._doProcessBlock(dataWords, offset);
	          } // Remove processed words


	          processedWords = dataWords.splice(0, nWordsReady);
	          data.sigBytes -= nBytesReady;
	        } // Return processed words


	        return new WordArray.init(processedWords, nBytesReady);
	      },

	      /**
	       * Creates a copy of this object.
	       *
	       * @return {Object} The clone.
	       *
	       * @example
	       *
	       *     var clone = bufferedBlockAlgorithm.clone();
	       */
	      clone: function clone() {
	        var clone = Base.clone.call(this);
	        clone._data = this._data.clone();
	        return clone;
	      },
	      _minBufferSize: 0
	    });
	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */

	    C_lib.Hasher = BufferedBlockAlgorithm.extend({
	      /**
	       * Configuration options.
	       */
	      cfg: Base.extend(),

	      /**
	       * Initializes a newly created hasher.
	       *
	       * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	       *
	       * @example
	       *
	       *     var hasher = CryptoJS.algo.SHA256.create();
	       */
	      init: function init(cfg) {
	        // Apply config defaults
	        this.cfg = this.cfg.extend(cfg); // Set initial values

	        this.reset();
	      },

	      /**
	       * Resets this hasher to its initial state.
	       *
	       * @example
	       *
	       *     hasher.reset();
	       */
	      reset: function reset() {
	        // Reset data buffer
	        BufferedBlockAlgorithm.reset.call(this); // Perform concrete-hasher logic

	        this._doReset();
	      },

	      /**
	       * Updates this hasher with a message.
	       *
	       * @param {WordArray|string} messageUpdate The message to append.
	       *
	       * @return {Hasher} This hasher.
	       *
	       * @example
	       *
	       *     hasher.update('message');
	       *     hasher.update(wordArray);
	       */
	      update: function update(messageUpdate) {
	        // Append
	        this._append(messageUpdate); // Update the hash


	        this._process(); // Chainable


	        return this;
	      },

	      /**
	       * Finalizes the hash computation.
	       * Note that the finalize operation is effectively a destructive, read-once operation.
	       *
	       * @param {WordArray|string} messageUpdate (Optional) A final message update.
	       *
	       * @return {WordArray} The hash.
	       *
	       * @example
	       *
	       *     var hash = hasher.finalize();
	       *     var hash = hasher.finalize('message');
	       *     var hash = hasher.finalize(wordArray);
	       */
	      finalize: function finalize(messageUpdate) {
	        // Final message update
	        if (messageUpdate) {
	          this._append(messageUpdate);
	        } // Perform concrete-hasher logic


	        var hash = this._doFinalize();

	        return hash;
	      },
	      blockSize: 512 / 32,

	      /**
	       * Creates a shortcut function to a hasher's object interface.
	       *
	       * @param {Hasher} hasher The hasher to create a helper for.
	       *
	       * @return {Function} The shortcut function.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	       */
	      _createHelper: function _createHelper(hasher) {
	        return function (message, cfg) {
	          return new hasher.init(cfg).finalize(message);
	        };
	      },

	      /**
	       * Creates a shortcut function to the HMAC's object interface.
	       *
	       * @param {Hasher} hasher The hasher to use in this HMAC helper.
	       *
	       * @return {Function} The shortcut function.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	       */
	      _createHmacHelper: function _createHmacHelper(hasher) {
	        return function (message, key) {
	          return new C_algo.HMAC.init(hasher, key).finalize(message);
	        };
	      }
	    });
	    /**
	     * Algorithm namespace.
	     */

	    var C_algo = C.algo = {};
	    return C;
	  }(Math);

	  return CryptoJS;
	});
	});

	var x64Core = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function (undefined$1) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;
	    /**
	     * x64 namespace.
	     */

	    var C_x64 = C.x64 = {};
	    /**
	     * A 64-bit word.
	     */

	    C_x64.Word = Base.extend({
	      /**
	       * Initializes a newly created 64-bit word.
	       *
	       * @param {number} high The high 32 bits.
	       * @param {number} low The low 32 bits.
	       *
	       * @example
	       *
	       *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	       */
	      init: function init(high, low) {
	        this.high = high;
	        this.low = low;
	      }
	      /**
	       * Bitwise NOTs this word.
	       *
	       * @return {X64Word} A new x64-Word object after negating.
	       *
	       * @example
	       *
	       *     var negated = x64Word.not();
	       */
	      // not: function () {
	      // var high = ~this.high;
	      // var low = ~this.low;
	      // return X64Word.create(high, low);
	      // },

	      /**
	       * Bitwise ANDs this word with the passed word.
	       *
	       * @param {X64Word} word The x64-Word to AND with this word.
	       *
	       * @return {X64Word} A new x64-Word object after ANDing.
	       *
	       * @example
	       *
	       *     var anded = x64Word.and(anotherX64Word);
	       */
	      // and: function (word) {
	      // var high = this.high & word.high;
	      // var low = this.low & word.low;
	      // return X64Word.create(high, low);
	      // },

	      /**
	       * Bitwise ORs this word with the passed word.
	       *
	       * @param {X64Word} word The x64-Word to OR with this word.
	       *
	       * @return {X64Word} A new x64-Word object after ORing.
	       *
	       * @example
	       *
	       *     var ored = x64Word.or(anotherX64Word);
	       */
	      // or: function (word) {
	      // var high = this.high | word.high;
	      // var low = this.low | word.low;
	      // return X64Word.create(high, low);
	      // },

	      /**
	       * Bitwise XORs this word with the passed word.
	       *
	       * @param {X64Word} word The x64-Word to XOR with this word.
	       *
	       * @return {X64Word} A new x64-Word object after XORing.
	       *
	       * @example
	       *
	       *     var xored = x64Word.xor(anotherX64Word);
	       */
	      // xor: function (word) {
	      // var high = this.high ^ word.high;
	      // var low = this.low ^ word.low;
	      // return X64Word.create(high, low);
	      // },

	      /**
	       * Shifts this word n bits to the left.
	       *
	       * @param {number} n The number of bits to shift.
	       *
	       * @return {X64Word} A new x64-Word object after shifting.
	       *
	       * @example
	       *
	       *     var shifted = x64Word.shiftL(25);
	       */
	      // shiftL: function (n) {
	      // if (n < 32) {
	      // var high = (this.high << n) | (this.low >>> (32 - n));
	      // var low = this.low << n;
	      // } else {
	      // var high = this.low << (n - 32);
	      // var low = 0;
	      // }
	      // return X64Word.create(high, low);
	      // },

	      /**
	       * Shifts this word n bits to the right.
	       *
	       * @param {number} n The number of bits to shift.
	       *
	       * @return {X64Word} A new x64-Word object after shifting.
	       *
	       * @example
	       *
	       *     var shifted = x64Word.shiftR(7);
	       */
	      // shiftR: function (n) {
	      // if (n < 32) {
	      // var low = (this.low >>> n) | (this.high << (32 - n));
	      // var high = this.high >>> n;
	      // } else {
	      // var low = this.high >>> (n - 32);
	      // var high = 0;
	      // }
	      // return X64Word.create(high, low);
	      // },

	      /**
	       * Rotates this word n bits to the left.
	       *
	       * @param {number} n The number of bits to rotate.
	       *
	       * @return {X64Word} A new x64-Word object after rotating.
	       *
	       * @example
	       *
	       *     var rotated = x64Word.rotL(25);
	       */
	      // rotL: function (n) {
	      // return this.shiftL(n).or(this.shiftR(64 - n));
	      // },

	      /**
	       * Rotates this word n bits to the right.
	       *
	       * @param {number} n The number of bits to rotate.
	       *
	       * @return {X64Word} A new x64-Word object after rotating.
	       *
	       * @example
	       *
	       *     var rotated = x64Word.rotR(7);
	       */
	      // rotR: function (n) {
	      // return this.shiftR(n).or(this.shiftL(64 - n));
	      // },

	      /**
	       * Adds this word with the passed word.
	       *
	       * @param {X64Word} word The x64-Word to add with this word.
	       *
	       * @return {X64Word} A new x64-Word object after adding.
	       *
	       * @example
	       *
	       *     var added = x64Word.add(anotherX64Word);
	       */
	      // add: function (word) {
	      // var low = (this.low + word.low) | 0;
	      // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	      // var high = (this.high + word.high + carry) | 0;
	      // return X64Word.create(high, low);
	      // }

	    });
	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */

	    C_x64.WordArray = Base.extend({
	      /**
	       * Initializes a newly created word array.
	       *
	       * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.x64.WordArray.create();
	       *
	       *     var wordArray = CryptoJS.x64.WordArray.create([
	       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	       *     ]);
	       *
	       *     var wordArray = CryptoJS.x64.WordArray.create([
	       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	       *     ], 10);
	       */
	      init: function init(words, sigBytes) {
	        words = this.words = words || [];

	        if (sigBytes != undefined$1) {
	          this.sigBytes = sigBytes;
	        } else {
	          this.sigBytes = words.length * 8;
	        }
	      },

	      /**
	       * Converts this 64-bit word array to a 32-bit word array.
	       *
	       * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	       *
	       * @example
	       *
	       *     var x32WordArray = x64WordArray.toX32();
	       */
	      toX32: function toX32() {
	        // Shortcuts
	        var x64Words = this.words;
	        var x64WordsLength = x64Words.length; // Convert

	        var x32Words = [];

	        for (var i = 0; i < x64WordsLength; i++) {
	          var x64Word = x64Words[i];
	          x32Words.push(x64Word.high);
	          x32Words.push(x64Word.low);
	        }

	        return X32WordArray.create(x32Words, this.sigBytes);
	      },

	      /**
	       * Creates a copy of this word array.
	       *
	       * @return {X64WordArray} The clone.
	       *
	       * @example
	       *
	       *     var clone = x64WordArray.clone();
	       */
	      clone: function clone() {
	        var clone = Base.clone.call(this); // Clone "words" array

	        var words = clone.words = this.words.slice(0); // Clone each X64Word object

	        var wordsLength = words.length;

	        for (var i = 0; i < wordsLength; i++) {
	          words[i] = words[i].clone();
	        }

	        return clone;
	      }
	    });
	  })();

	  return CryptoJS;
	});
	});

	var libTypedarrays = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	      return;
	    } // Shortcuts


	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray; // Reference original init

	    var superInit = WordArray.init; // Augment WordArray.init to handle typed arrays

	    var subInit = WordArray.init = function (typedArray) {
	      // Convert buffers to uint8
	      if (typedArray instanceof ArrayBuffer) {
	        typedArray = new Uint8Array(typedArray);
	      } // Convert other array views to uint8


	      if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
	        typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	      } // Handle Uint8Array


	      if (typedArray instanceof Uint8Array) {
	        // Shortcut
	        var typedArrayByteLength = typedArray.byteLength; // Extract bytes

	        var words = [];

	        for (var i = 0; i < typedArrayByteLength; i++) {
	          words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
	        } // Initialize this word array


	        superInit.call(this, words, typedArrayByteLength);
	      } else {
	        // Else call normal init
	        superInit.apply(this, arguments);
	      }
	    };

	    subInit.prototype = WordArray;
	  })();

	  return CryptoJS.lib.WordArray;
	});
	});

	var encUtf16 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;
	    /**
	     * UTF-16 BE encoding strategy.
	     */

	    C_enc.Utf16 = C_enc.Utf16BE = {
	      /**
	       * Converts a word array to a UTF-16 BE string.
	       *
	       * @param {WordArray} wordArray The word array.
	       *
	       * @return {string} The UTF-16 BE string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	       */
	      stringify: function stringify(wordArray) {
	        // Shortcuts
	        var words = wordArray.words;
	        var sigBytes = wordArray.sigBytes; // Convert

	        var utf16Chars = [];

	        for (var i = 0; i < sigBytes; i += 2) {
	          var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff;
	          utf16Chars.push(String.fromCharCode(codePoint));
	        }

	        return utf16Chars.join('');
	      },

	      /**
	       * Converts a UTF-16 BE string to a word array.
	       *
	       * @param {string} utf16Str The UTF-16 BE string.
	       *
	       * @return {WordArray} The word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	       */
	      parse: function parse(utf16Str) {
	        // Shortcut
	        var utf16StrLength = utf16Str.length; // Convert

	        var words = [];

	        for (var i = 0; i < utf16StrLength; i++) {
	          words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
	        }

	        return WordArray.create(words, utf16StrLength * 2);
	      }
	    };
	    /**
	     * UTF-16 LE encoding strategy.
	     */

	    C_enc.Utf16LE = {
	      /**
	       * Converts a word array to a UTF-16 LE string.
	       *
	       * @param {WordArray} wordArray The word array.
	       *
	       * @return {string} The UTF-16 LE string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	       */
	      stringify: function stringify(wordArray) {
	        // Shortcuts
	        var words = wordArray.words;
	        var sigBytes = wordArray.sigBytes; // Convert

	        var utf16Chars = [];

	        for (var i = 0; i < sigBytes; i += 2) {
	          var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff);
	          utf16Chars.push(String.fromCharCode(codePoint));
	        }

	        return utf16Chars.join('');
	      },

	      /**
	       * Converts a UTF-16 LE string to a word array.
	       *
	       * @param {string} utf16Str The UTF-16 LE string.
	       *
	       * @return {WordArray} The word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	       */
	      parse: function parse(utf16Str) {
	        // Shortcut
	        var utf16StrLength = utf16Str.length; // Convert

	        var words = [];

	        for (var i = 0; i < utf16StrLength; i++) {
	          words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
	        }

	        return WordArray.create(words, utf16StrLength * 2);
	      }
	    };

	    function swapEndian(word) {
	      return word << 8 & 0xff00ff00 | word >>> 8 & 0x00ff00ff;
	    }
	  })();

	  return CryptoJS.enc.Utf16;
	});
	});

	var encBase64 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;
	    /**
	     * Base64 encoding strategy.
	     */

	    C_enc.Base64 = {
	      /**
	       * Converts a word array to a Base64 string.
	       *
	       * @param {WordArray} wordArray The word array.
	       *
	       * @return {string} The Base64 string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	       */
	      stringify: function stringify(wordArray) {
	        // Shortcuts
	        var words = wordArray.words;
	        var sigBytes = wordArray.sigBytes;
	        var map = this._map; // Clamp excess bits

	        wordArray.clamp(); // Convert

	        var base64Chars = [];

	        for (var i = 0; i < sigBytes; i += 3) {
	          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
	          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
	          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
	          var triplet = byte1 << 16 | byte2 << 8 | byte3;

	          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
	            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
	          }
	        } // Add padding


	        var paddingChar = map.charAt(64);

	        if (paddingChar) {
	          while (base64Chars.length % 4) {
	            base64Chars.push(paddingChar);
	          }
	        }

	        return base64Chars.join('');
	      },

	      /**
	       * Converts a Base64 string to a word array.
	       *
	       * @param {string} base64Str The Base64 string.
	       *
	       * @return {WordArray} The word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	       */
	      parse: function parse(base64Str) {
	        // Shortcuts
	        var base64StrLength = base64Str.length;
	        var map = this._map;
	        var reverseMap = this._reverseMap;

	        if (!reverseMap) {
	          reverseMap = this._reverseMap = [];

	          for (var j = 0; j < map.length; j++) {
	            reverseMap[map.charCodeAt(j)] = j;
	          }
	        } // Ignore padding


	        var paddingChar = map.charAt(64);

	        if (paddingChar) {
	          var paddingIndex = base64Str.indexOf(paddingChar);

	          if (paddingIndex !== -1) {
	            base64StrLength = paddingIndex;
	          }
	        } // Convert


	        return parseLoop(base64Str, base64StrLength, reverseMap);
	      },
	      _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;

	      for (var i = 0; i < base64StrLength; i++) {
	        if (i % 4) {
	          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
	          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
	          var bitsCombined = bits1 | bits2;
	          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
	          nBytes++;
	        }
	      }

	      return WordArray.create(words, nBytes);
	    }
	  })();

	  return CryptoJS.enc.Base64;
	});
	});

	var encBase64url = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;
	    /**
	     * Base64url encoding strategy.
	     */

	    C_enc.Base64url = {
	      /**
	       * Converts a word array to a Base64url string.
	       *
	       * @param {WordArray} wordArray The word array.
	       *
	       * @param {boolean} urlSafe Whether to use url safe
	       *
	       * @return {string} The Base64url string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
	       */
	      stringify: function stringify(wordArray) {
	        var urlSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	        // Shortcuts
	        var words = wordArray.words;
	        var sigBytes = wordArray.sigBytes;
	        var map = urlSafe ? this._safe_map : this._map; // Clamp excess bits

	        wordArray.clamp(); // Convert

	        var base64Chars = [];

	        for (var i = 0; i < sigBytes; i += 3) {
	          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
	          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
	          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
	          var triplet = byte1 << 16 | byte2 << 8 | byte3;

	          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
	            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
	          }
	        } // Add padding


	        var paddingChar = map.charAt(64);

	        if (paddingChar) {
	          while (base64Chars.length % 4) {
	            base64Chars.push(paddingChar);
	          }
	        }

	        return base64Chars.join('');
	      },

	      /**
	       * Converts a Base64url string to a word array.
	       *
	       * @param {string} base64Str The Base64url string.
	       *
	       * @param {boolean} urlSafe Whether to use url safe
	       *
	       * @return {WordArray} The word array.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
	       */
	      parse: function parse(base64Str) {
	        var urlSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	        // Shortcuts
	        var base64StrLength = base64Str.length;
	        var map = urlSafe ? this._safe_map : this._map;
	        var reverseMap = this._reverseMap;

	        if (!reverseMap) {
	          reverseMap = this._reverseMap = [];

	          for (var j = 0; j < map.length; j++) {
	            reverseMap[map.charCodeAt(j)] = j;
	          }
	        } // Ignore padding


	        var paddingChar = map.charAt(64);

	        if (paddingChar) {
	          var paddingIndex = base64Str.indexOf(paddingChar);

	          if (paddingIndex !== -1) {
	            base64StrLength = paddingIndex;
	          }
	        } // Convert


	        return parseLoop(base64Str, base64StrLength, reverseMap);
	      },
	      _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
	      _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;

	      for (var i = 0; i < base64StrLength; i++) {
	        if (i % 4) {
	          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
	          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
	          var bitsCombined = bits1 | bits2;
	          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
	          nBytes++;
	        }
	      }

	      return WordArray.create(words, nBytes);
	    }
	  })();

	  return CryptoJS.enc.Base64url;
	});
	});

	var md5 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo; // Constants table

	    var T = []; // Compute constants

	    (function () {
	      for (var i = 0; i < 64; i++) {
	        T[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;
	      }
	    })();
	    /**
	     * MD5 hash algorithm.
	     */


	    var MD5 = C_algo.MD5 = Hasher.extend({
	      _doReset: function _doReset() {
	        this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Swap endian
	        for (var i = 0; i < 16; i++) {
	          // Shortcuts
	          var offset_i = offset + i;
	          var M_offset_i = M[offset_i];
	          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
	        } // Shortcuts


	        var H = this._hash.words;
	        var M_offset_0 = M[offset + 0];
	        var M_offset_1 = M[offset + 1];
	        var M_offset_2 = M[offset + 2];
	        var M_offset_3 = M[offset + 3];
	        var M_offset_4 = M[offset + 4];
	        var M_offset_5 = M[offset + 5];
	        var M_offset_6 = M[offset + 6];
	        var M_offset_7 = M[offset + 7];
	        var M_offset_8 = M[offset + 8];
	        var M_offset_9 = M[offset + 9];
	        var M_offset_10 = M[offset + 10];
	        var M_offset_11 = M[offset + 11];
	        var M_offset_12 = M[offset + 12];
	        var M_offset_13 = M[offset + 13];
	        var M_offset_14 = M[offset + 14];
	        var M_offset_15 = M[offset + 15]; // Working varialbes

	        var a = H[0];
	        var b = H[1];
	        var c = H[2];
	        var d = H[3]; // Computation

	        a = FF(a, b, c, d, M_offset_0, 7, T[0]);
	        d = FF(d, a, b, c, M_offset_1, 12, T[1]);
	        c = FF(c, d, a, b, M_offset_2, 17, T[2]);
	        b = FF(b, c, d, a, M_offset_3, 22, T[3]);
	        a = FF(a, b, c, d, M_offset_4, 7, T[4]);
	        d = FF(d, a, b, c, M_offset_5, 12, T[5]);
	        c = FF(c, d, a, b, M_offset_6, 17, T[6]);
	        b = FF(b, c, d, a, M_offset_7, 22, T[7]);
	        a = FF(a, b, c, d, M_offset_8, 7, T[8]);
	        d = FF(d, a, b, c, M_offset_9, 12, T[9]);
	        c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	        b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	        a = FF(a, b, c, d, M_offset_12, 7, T[12]);
	        d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	        c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	        b = FF(b, c, d, a, M_offset_15, 22, T[15]);
	        a = GG(a, b, c, d, M_offset_1, 5, T[16]);
	        d = GG(d, a, b, c, M_offset_6, 9, T[17]);
	        c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	        b = GG(b, c, d, a, M_offset_0, 20, T[19]);
	        a = GG(a, b, c, d, M_offset_5, 5, T[20]);
	        d = GG(d, a, b, c, M_offset_10, 9, T[21]);
	        c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	        b = GG(b, c, d, a, M_offset_4, 20, T[23]);
	        a = GG(a, b, c, d, M_offset_9, 5, T[24]);
	        d = GG(d, a, b, c, M_offset_14, 9, T[25]);
	        c = GG(c, d, a, b, M_offset_3, 14, T[26]);
	        b = GG(b, c, d, a, M_offset_8, 20, T[27]);
	        a = GG(a, b, c, d, M_offset_13, 5, T[28]);
	        d = GG(d, a, b, c, M_offset_2, 9, T[29]);
	        c = GG(c, d, a, b, M_offset_7, 14, T[30]);
	        b = GG(b, c, d, a, M_offset_12, 20, T[31]);
	        a = HH(a, b, c, d, M_offset_5, 4, T[32]);
	        d = HH(d, a, b, c, M_offset_8, 11, T[33]);
	        c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	        b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	        a = HH(a, b, c, d, M_offset_1, 4, T[36]);
	        d = HH(d, a, b, c, M_offset_4, 11, T[37]);
	        c = HH(c, d, a, b, M_offset_7, 16, T[38]);
	        b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	        a = HH(a, b, c, d, M_offset_13, 4, T[40]);
	        d = HH(d, a, b, c, M_offset_0, 11, T[41]);
	        c = HH(c, d, a, b, M_offset_3, 16, T[42]);
	        b = HH(b, c, d, a, M_offset_6, 23, T[43]);
	        a = HH(a, b, c, d, M_offset_9, 4, T[44]);
	        d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	        c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	        b = HH(b, c, d, a, M_offset_2, 23, T[47]);
	        a = II(a, b, c, d, M_offset_0, 6, T[48]);
	        d = II(d, a, b, c, M_offset_7, 10, T[49]);
	        c = II(c, d, a, b, M_offset_14, 15, T[50]);
	        b = II(b, c, d, a, M_offset_5, 21, T[51]);
	        a = II(a, b, c, d, M_offset_12, 6, T[52]);
	        d = II(d, a, b, c, M_offset_3, 10, T[53]);
	        c = II(c, d, a, b, M_offset_10, 15, T[54]);
	        b = II(b, c, d, a, M_offset_1, 21, T[55]);
	        a = II(a, b, c, d, M_offset_8, 6, T[56]);
	        d = II(d, a, b, c, M_offset_15, 10, T[57]);
	        c = II(c, d, a, b, M_offset_6, 15, T[58]);
	        b = II(b, c, d, a, M_offset_13, 21, T[59]);
	        a = II(a, b, c, d, M_offset_4, 6, T[60]);
	        d = II(d, a, b, c, M_offset_11, 10, T[61]);
	        c = II(c, d, a, b, M_offset_2, 15, T[62]);
	        b = II(b, c, d, a, M_offset_9, 21, T[63]); // Intermediate hash value

	        H[0] = H[0] + a | 0;
	        H[1] = H[1] + b | 0;
	        H[2] = H[2] + c | 0;
	        H[3] = H[3] + d | 0;
	      },
	      _doFinalize: function _doFinalize() {
	        // Shortcuts
	        var data = this._data;
	        var dataWords = data.words;
	        var nBitsTotal = this._nDataBytes * 8;
	        var nBitsLeft = data.sigBytes * 8; // Add padding

	        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
	        var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	        var nBitsTotalL = nBitsTotal;
	        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;
	        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;
	        data.sigBytes = (dataWords.length + 1) * 4; // Hash final blocks

	        this._process(); // Shortcuts


	        var hash = this._hash;
	        var H = hash.words; // Swap endian

	        for (var i = 0; i < 4; i++) {
	          // Shortcut
	          var H_i = H[i];
	          H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
	        } // Return final computed hash


	        return hash;
	      },
	      clone: function clone() {
	        var clone = Hasher.clone.call(this);
	        clone._hash = this._hash.clone();
	        return clone;
	      }
	    });

	    function FF(a, b, c, d, x, s, t) {
	      var n = a + (b & c | ~b & d) + x + t;
	      return (n << s | n >>> 32 - s) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	      var n = a + (b & d | c & ~d) + x + t;
	      return (n << s | n >>> 32 - s) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	      var n = a + (b ^ c ^ d) + x + t;
	      return (n << s | n >>> 32 - s) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	      var n = a + (c ^ (b | ~d)) + x + t;
	      return (n << s | n >>> 32 - s) + b;
	    }
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */


	    C.MD5 = Hasher._createHelper(MD5);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */

	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	  })(Math);

	  return CryptoJS.MD5;
	});
	});

	var sha1 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo; // Reusable object

	    var W = [];
	    /**
	     * SHA-1 hash algorithm.
	     */

	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	      _doReset: function _doReset() {
	        this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Shortcut
	        var H = this._hash.words; // Working variables

	        var a = H[0];
	        var b = H[1];
	        var c = H[2];
	        var d = H[3];
	        var e = H[4]; // Computation

	        for (var i = 0; i < 80; i++) {
	          if (i < 16) {
	            W[i] = M[offset + i] | 0;
	          } else {
	            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	            W[i] = n << 1 | n >>> 31;
	          }

	          var t = (a << 5 | a >>> 27) + e + W[i];

	          if (i < 20) {
	            t += (b & c | ~b & d) + 0x5a827999;
	          } else if (i < 40) {
	            t += (b ^ c ^ d) + 0x6ed9eba1;
	          } else if (i < 60) {
	            t += (b & c | b & d | c & d) - 0x70e44324;
	          } else
	            /* if (i < 80) */
	            {
	              t += (b ^ c ^ d) - 0x359d3e2a;
	            }

	          e = d;
	          d = c;
	          c = b << 30 | b >>> 2;
	          b = a;
	          a = t;
	        } // Intermediate hash value


	        H[0] = H[0] + a | 0;
	        H[1] = H[1] + b | 0;
	        H[2] = H[2] + c | 0;
	        H[3] = H[3] + d | 0;
	        H[4] = H[4] + e | 0;
	      },
	      _doFinalize: function _doFinalize() {
	        // Shortcuts
	        var data = this._data;
	        var dataWords = data.words;
	        var nBitsTotal = this._nDataBytes * 8;
	        var nBitsLeft = data.sigBytes * 8; // Add padding

	        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
	        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
	        data.sigBytes = dataWords.length * 4; // Hash final blocks

	        this._process(); // Return final computed hash


	        return this._hash;
	      },
	      clone: function clone() {
	        var clone = Hasher.clone.call(this);
	        clone._hash = this._hash.clone();
	        return clone;
	      }
	    });
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */

	    C.SHA1 = Hasher._createHelper(SHA1);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */

	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	  })();

	  return CryptoJS.SHA1;
	});
	});

	var sha256 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo; // Initialization and round constants tables

	    var H = [];
	    var K = []; // Compute constants

	    (function () {
	      function isPrime(n) {
	        var sqrtN = Math.sqrt(n);

	        for (var factor = 2; factor <= sqrtN; factor++) {
	          if (!(n % factor)) {
	            return false;
	          }
	        }

	        return true;
	      }

	      function getFractionalBits(n) {
	        return (n - (n | 0)) * 0x100000000 | 0;
	      }

	      var n = 2;
	      var nPrime = 0;

	      while (nPrime < 64) {
	        if (isPrime(n)) {
	          if (nPrime < 8) {
	            H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	          }

	          K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
	          nPrime++;
	        }

	        n++;
	      }
	    })(); // Reusable object


	    var W = [];
	    /**
	     * SHA-256 hash algorithm.
	     */

	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	      _doReset: function _doReset() {
	        this._hash = new WordArray.init(H.slice(0));
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Shortcut
	        var H = this._hash.words; // Working variables

	        var a = H[0];
	        var b = H[1];
	        var c = H[2];
	        var d = H[3];
	        var e = H[4];
	        var f = H[5];
	        var g = H[6];
	        var h = H[7]; // Computation

	        for (var i = 0; i < 64; i++) {
	          if (i < 16) {
	            W[i] = M[offset + i] | 0;
	          } else {
	            var gamma0x = W[i - 15];
	            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
	            var gamma1x = W[i - 2];
	            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
	            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	          }

	          var ch = e & f ^ ~e & g;
	          var maj = a & b ^ a & c ^ b & c;
	          var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
	          var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
	          var t1 = h + sigma1 + ch + K[i] + W[i];
	          var t2 = sigma0 + maj;
	          h = g;
	          g = f;
	          f = e;
	          e = d + t1 | 0;
	          d = c;
	          c = b;
	          b = a;
	          a = t1 + t2 | 0;
	        } // Intermediate hash value


	        H[0] = H[0] + a | 0;
	        H[1] = H[1] + b | 0;
	        H[2] = H[2] + c | 0;
	        H[3] = H[3] + d | 0;
	        H[4] = H[4] + e | 0;
	        H[5] = H[5] + f | 0;
	        H[6] = H[6] + g | 0;
	        H[7] = H[7] + h | 0;
	      },
	      _doFinalize: function _doFinalize() {
	        // Shortcuts
	        var data = this._data;
	        var dataWords = data.words;
	        var nBitsTotal = this._nDataBytes * 8;
	        var nBitsLeft = data.sigBytes * 8; // Add padding

	        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
	        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
	        data.sigBytes = dataWords.length * 4; // Hash final blocks

	        this._process(); // Return final computed hash


	        return this._hash;
	      },
	      clone: function clone() {
	        var clone = Hasher.clone.call(this);
	        clone._hash = this._hash.clone();
	        return clone;
	      }
	    });
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */

	    C.SHA256 = Hasher._createHelper(SHA256);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */

	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	  })(Math);

	  return CryptoJS.SHA256;
	});
	});

	var sha224 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, sha256);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;
	    /**
	     * SHA-224 hash algorithm.
	     */

	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	      _doReset: function _doReset() {
	        this._hash = new WordArray.init([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);
	      },
	      _doFinalize: function _doFinalize() {
	        var hash = SHA256._doFinalize.call(this);

	        hash.sigBytes -= 4;
	        return hash;
	      }
	    });
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */

	    C.SHA224 = SHA256._createHelper(SHA224);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */

	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	  })();

	  return CryptoJS.SHA224;
	});
	});

	var sha512 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, x64Core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	      return X64Word.create.apply(X64Word, arguments);
	    } // Constants


	    var K = [X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd), X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc), X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019), X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118), X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe), X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2), X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1), X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694), X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3), X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65), X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483), X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5), X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210), X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4), X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725), X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70), X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926), X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df), X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8), X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b), X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001), X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30), X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910), X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8), X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53), X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8), X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb), X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3), X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60), X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec), X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9), X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b), X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207), X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178), X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6), X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b), X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493), X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c), X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a), X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)]; // Reusable objects

	    var W = [];

	    (function () {
	      for (var i = 0; i < 80; i++) {
	        W[i] = X64Word_create();
	      }
	    })();
	    /**
	     * SHA-512 hash algorithm.
	     */


	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	      _doReset: function _doReset() {
	        this._hash = new X64WordArray.init([new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b), new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1), new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f), new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)]);
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Shortcuts
	        var H = this._hash.words;
	        var H0 = H[0];
	        var H1 = H[1];
	        var H2 = H[2];
	        var H3 = H[3];
	        var H4 = H[4];
	        var H5 = H[5];
	        var H6 = H[6];
	        var H7 = H[7];
	        var H0h = H0.high;
	        var H0l = H0.low;
	        var H1h = H1.high;
	        var H1l = H1.low;
	        var H2h = H2.high;
	        var H2l = H2.low;
	        var H3h = H3.high;
	        var H3l = H3.low;
	        var H4h = H4.high;
	        var H4l = H4.low;
	        var H5h = H5.high;
	        var H5l = H5.low;
	        var H6h = H6.high;
	        var H6l = H6.low;
	        var H7h = H7.high;
	        var H7l = H7.low; // Working variables

	        var ah = H0h;
	        var al = H0l;
	        var bh = H1h;
	        var bl = H1l;
	        var ch = H2h;
	        var cl = H2l;
	        var dh = H3h;
	        var dl = H3l;
	        var eh = H4h;
	        var el = H4l;
	        var fh = H5h;
	        var fl = H5l;
	        var gh = H6h;
	        var gl = H6l;
	        var hh = H7h;
	        var hl = H7l; // Rounds

	        for (var i = 0; i < 80; i++) {
	          var Wil;
	          var Wih; // Shortcut

	          var Wi = W[i]; // Extend message

	          if (i < 16) {
	            Wih = Wi.high = M[offset + i * 2] | 0;
	            Wil = Wi.low = M[offset + i * 2 + 1] | 0;
	          } else {
	            // Gamma0
	            var gamma0x = W[i - 15];
	            var gamma0xh = gamma0x.high;
	            var gamma0xl = gamma0x.low;
	            var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
	            var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25); // Gamma1

	            var gamma1x = W[i - 2];
	            var gamma1xh = gamma1x.high;
	            var gamma1xl = gamma1x.low;
	            var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
	            var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

	            var Wi7 = W[i - 7];
	            var Wi7h = Wi7.high;
	            var Wi7l = Wi7.low;
	            var Wi16 = W[i - 16];
	            var Wi16h = Wi16.high;
	            var Wi16l = Wi16.low;
	            Wil = gamma0l + Wi7l;
	            Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
	            Wil = Wil + gamma1l;
	            Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
	            Wil = Wil + Wi16l;
	            Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
	            Wi.high = Wih;
	            Wi.low = Wil;
	          }

	          var chh = eh & fh ^ ~eh & gh;
	          var chl = el & fl ^ ~el & gl;
	          var majh = ah & bh ^ ah & ch ^ bh & ch;
	          var majl = al & bl ^ al & cl ^ bl & cl;
	          var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
	          var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
	          var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
	          var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9); // t1 = h + sigma1 + ch + K[i] + W[i]

	          var Ki = K[i];
	          var Kih = Ki.high;
	          var Kil = Ki.low;
	          var t1l = hl + sigma1l;
	          var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
	          var t1l = t1l + chl;
	          var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
	          var t1l = t1l + Kil;
	          var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
	          var t1l = t1l + Wil;
	          var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0); // t2 = sigma0 + maj

	          var t2l = sigma0l + majl;
	          var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0); // Update working variables

	          hh = gh;
	          hl = gl;
	          gh = fh;
	          gl = fl;
	          fh = eh;
	          fl = el;
	          el = dl + t1l | 0;
	          eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
	          dh = ch;
	          dl = cl;
	          ch = bh;
	          cl = bl;
	          bh = ah;
	          bl = al;
	          al = t1l + t2l | 0;
	          ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
	        } // Intermediate hash value


	        H0l = H0.low = H0l + al;
	        H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
	        H1l = H1.low = H1l + bl;
	        H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
	        H2l = H2.low = H2l + cl;
	        H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
	        H3l = H3.low = H3l + dl;
	        H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
	        H4l = H4.low = H4l + el;
	        H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
	        H5l = H5.low = H5l + fl;
	        H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
	        H6l = H6.low = H6l + gl;
	        H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
	        H7l = H7.low = H7l + hl;
	        H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
	      },
	      _doFinalize: function _doFinalize() {
	        // Shortcuts
	        var data = this._data;
	        var dataWords = data.words;
	        var nBitsTotal = this._nDataBytes * 8;
	        var nBitsLeft = data.sigBytes * 8; // Add padding

	        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
	        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
	        data.sigBytes = dataWords.length * 4; // Hash final blocks

	        this._process(); // Convert hash to 32-bit word array before returning


	        var hash = this._hash.toX32(); // Return final computed hash


	        return hash;
	      },
	      clone: function clone() {
	        var clone = Hasher.clone.call(this);
	        clone._hash = this._hash.clone();
	        return clone;
	      },
	      blockSize: 1024 / 32
	    });
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */

	    C.SHA512 = Hasher._createHelper(SHA512);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */

	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	  })();

	  return CryptoJS.SHA512;
	});
	});

	var sha384 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, x64Core, sha512);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;
	    /**
	     * SHA-384 hash algorithm.
	     */

	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	      _doReset: function _doReset() {
	        this._hash = new X64WordArray.init([new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507), new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939), new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511), new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)]);
	      },
	      _doFinalize: function _doFinalize() {
	        var hash = SHA512._doFinalize.call(this);

	        hash.sigBytes -= 16;
	        return hash;
	      }
	    });
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */

	    C.SHA384 = SHA512._createHelper(SHA384);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */

	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	  })();

	  return CryptoJS.SHA384;
	});
	});

	var sha3 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, x64Core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo; // Constants tables

	    var RHO_OFFSETS = [];
	    var PI_INDEXES = [];
	    var ROUND_CONSTANTS = []; // Compute Constants

	    (function () {
	      // Compute rho offset constants
	      var x = 1,
	          y = 0;

	      for (var t = 0; t < 24; t++) {
	        RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
	        var newX = y % 5;
	        var newY = (2 * x + 3 * y) % 5;
	        x = newX;
	        y = newY;
	      } // Compute pi index constants


	      for (var x = 0; x < 5; x++) {
	        for (var y = 0; y < 5; y++) {
	          PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
	        }
	      } // Compute round constants


	      var LFSR = 0x01;

	      for (var i = 0; i < 24; i++) {
	        var roundConstantMsw = 0;
	        var roundConstantLsw = 0;

	        for (var j = 0; j < 7; j++) {
	          if (LFSR & 0x01) {
	            var bitPosition = (1 << j) - 1;

	            if (bitPosition < 32) {
	              roundConstantLsw ^= 1 << bitPosition;
	            } else
	              /* if (bitPosition >= 32) */
	              {
	                roundConstantMsw ^= 1 << bitPosition - 32;
	              }
	          } // Compute next LFSR


	          if (LFSR & 0x80) {
	            // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	            LFSR = LFSR << 1 ^ 0x71;
	          } else {
	            LFSR <<= 1;
	          }
	        }

	        ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	      }
	    })(); // Reusable objects for temporary values


	    var T = [];

	    (function () {
	      for (var i = 0; i < 25; i++) {
	        T[i] = X64Word.create();
	      }
	    })();
	    /**
	     * SHA-3 hash algorithm.
	     */


	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {number} outputLength
	       *   The desired number of bits in the output hash.
	       *   Only values permitted are: 224, 256, 384, 512.
	       *   Default: 512
	       */
	      cfg: Hasher.cfg.extend({
	        outputLength: 512
	      }),
	      _doReset: function _doReset() {
	        var state = this._state = [];

	        for (var i = 0; i < 25; i++) {
	          state[i] = new X64Word.init();
	        }

	        this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Shortcuts
	        var state = this._state;
	        var nBlockSizeLanes = this.blockSize / 2; // Absorb

	        for (var i = 0; i < nBlockSizeLanes; i++) {
	          // Shortcuts
	          var M2i = M[offset + 2 * i];
	          var M2i1 = M[offset + 2 * i + 1]; // Swap endian

	          M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;
	          M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00; // Absorb message into state

	          var lane = state[i];
	          lane.high ^= M2i1;
	          lane.low ^= M2i;
	        } // Rounds


	        for (var round = 0; round < 24; round++) {
	          // Theta
	          for (var x = 0; x < 5; x++) {
	            // Mix column lanes
	            var tMsw = 0,
	                tLsw = 0;

	            for (var y = 0; y < 5; y++) {
	              var lane = state[x + 5 * y];
	              tMsw ^= lane.high;
	              tLsw ^= lane.low;
	            } // Temporary values


	            var Tx = T[x];
	            Tx.high = tMsw;
	            Tx.low = tLsw;
	          }

	          for (var x = 0; x < 5; x++) {
	            // Shortcuts
	            var Tx4 = T[(x + 4) % 5];
	            var Tx1 = T[(x + 1) % 5];
	            var Tx1Msw = Tx1.high;
	            var Tx1Lsw = Tx1.low; // Mix surrounding columns

	            var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
	            var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);

	            for (var y = 0; y < 5; y++) {
	              var lane = state[x + 5 * y];
	              lane.high ^= tMsw;
	              lane.low ^= tLsw;
	            }
	          } // Rho Pi


	          for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	            var tMsw;
	            var tLsw; // Shortcuts

	            var lane = state[laneIndex];
	            var laneMsw = lane.high;
	            var laneLsw = lane.low;
	            var rhoOffset = RHO_OFFSETS[laneIndex]; // Rotate lanes

	            if (rhoOffset < 32) {
	              tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
	              tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
	            } else
	              /* if (rhoOffset >= 32) */
	              {
	                tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
	                tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
	              } // Transpose lanes


	            var TPiLane = T[PI_INDEXES[laneIndex]];
	            TPiLane.high = tMsw;
	            TPiLane.low = tLsw;
	          } // Rho pi at x = y = 0


	          var T0 = T[0];
	          var state0 = state[0];
	          T0.high = state0.high;
	          T0.low = state0.low; // Chi

	          for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	              // Shortcuts
	              var laneIndex = x + 5 * y;
	              var lane = state[laneIndex];
	              var TLane = T[laneIndex];
	              var Tx1Lane = T[(x + 1) % 5 + 5 * y];
	              var Tx2Lane = T[(x + 2) % 5 + 5 * y]; // Mix rows

	              lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
	              lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
	            }
	          } // Iota


	          var lane = state[0];
	          var roundConstant = ROUND_CONSTANTS[round];
	          lane.high ^= roundConstant.high;
	          lane.low ^= roundConstant.low;
	        }
	      },
	      _doFinalize: function _doFinalize() {
	        // Shortcuts
	        var data = this._data;
	        var dataWords = data.words;
	        this._nDataBytes * 8;
	        var nBitsLeft = data.sigBytes * 8;
	        var blockSizeBits = this.blockSize * 32; // Add padding

	        dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;
	        dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;
	        data.sigBytes = dataWords.length * 4; // Hash final blocks

	        this._process(); // Shortcuts


	        var state = this._state;
	        var outputLengthBytes = this.cfg.outputLength / 8;
	        var outputLengthLanes = outputLengthBytes / 8; // Squeeze

	        var hashWords = [];

	        for (var i = 0; i < outputLengthLanes; i++) {
	          // Shortcuts
	          var lane = state[i];
	          var laneMsw = lane.high;
	          var laneLsw = lane.low; // Swap endian

	          laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;
	          laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00; // Squeeze state to retrieve hash

	          hashWords.push(laneLsw);
	          hashWords.push(laneMsw);
	        } // Return final computed hash


	        return new WordArray.init(hashWords, outputLengthBytes);
	      },
	      clone: function clone() {
	        var clone = Hasher.clone.call(this);

	        var state = clone._state = this._state.slice(0);

	        for (var i = 0; i < 25; i++) {
	          state[i] = state[i].clone();
	        }

	        return clone;
	      }
	    });
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */

	    C.SHA3 = Hasher._createHelper(SHA3);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */

	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	  })(Math);

	  return CryptoJS.SHA3;
	});
	});

	var ripemd160 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /** @preserve
	  (c) 2012 by Cédric Mesnil. All rights reserved.
	  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	      - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  */
	  (function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo; // Constants table

	    var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);

	    var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);

	    var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);

	    var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);

	    var _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);

	    var _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);
	    /**
	     * RIPEMD160 hash algorithm.
	     */


	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	      _doReset: function _doReset() {
	        this._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Swap endian
	        for (var i = 0; i < 16; i++) {
	          // Shortcuts
	          var offset_i = offset + i;
	          var M_offset_i = M[offset_i]; // Swap

	          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
	        } // Shortcut


	        var H = this._hash.words;
	        var hl = _hl.words;
	        var hr = _hr.words;
	        var zl = _zl.words;
	        var zr = _zr.words;
	        var sl = _sl.words;
	        var sr = _sr.words; // Working variables

	        var al, bl, cl, dl, el;
	        var ar, br, cr, dr, er;
	        ar = al = H[0];
	        br = bl = H[1];
	        cr = cl = H[2];
	        dr = dl = H[3];
	        er = el = H[4]; // Computation

	        var t;

	        for (var i = 0; i < 80; i += 1) {
	          t = al + M[offset + zl[i]] | 0;

	          if (i < 16) {
	            t += f1(bl, cl, dl) + hl[0];
	          } else if (i < 32) {
	            t += f2(bl, cl, dl) + hl[1];
	          } else if (i < 48) {
	            t += f3(bl, cl, dl) + hl[2];
	          } else if (i < 64) {
	            t += f4(bl, cl, dl) + hl[3];
	          } else {
	            // if (i<80) {
	            t += f5(bl, cl, dl) + hl[4];
	          }

	          t = t | 0;
	          t = rotl(t, sl[i]);
	          t = t + el | 0;
	          al = el;
	          el = dl;
	          dl = rotl(cl, 10);
	          cl = bl;
	          bl = t;
	          t = ar + M[offset + zr[i]] | 0;

	          if (i < 16) {
	            t += f5(br, cr, dr) + hr[0];
	          } else if (i < 32) {
	            t += f4(br, cr, dr) + hr[1];
	          } else if (i < 48) {
	            t += f3(br, cr, dr) + hr[2];
	          } else if (i < 64) {
	            t += f2(br, cr, dr) + hr[3];
	          } else {
	            // if (i<80) {
	            t += f1(br, cr, dr) + hr[4];
	          }

	          t = t | 0;
	          t = rotl(t, sr[i]);
	          t = t + er | 0;
	          ar = er;
	          er = dr;
	          dr = rotl(cr, 10);
	          cr = br;
	          br = t;
	        } // Intermediate hash value


	        t = H[1] + cl + dr | 0;
	        H[1] = H[2] + dl + er | 0;
	        H[2] = H[3] + el + ar | 0;
	        H[3] = H[4] + al + br | 0;
	        H[4] = H[0] + bl + cr | 0;
	        H[0] = t;
	      },
	      _doFinalize: function _doFinalize() {
	        // Shortcuts
	        var data = this._data;
	        var dataWords = data.words;
	        var nBitsTotal = this._nDataBytes * 8;
	        var nBitsLeft = data.sigBytes * 8; // Add padding

	        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
	        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;
	        data.sigBytes = (dataWords.length + 1) * 4; // Hash final blocks

	        this._process(); // Shortcuts


	        var hash = this._hash;
	        var H = hash.words; // Swap endian

	        for (var i = 0; i < 5; i++) {
	          // Shortcut
	          var H_i = H[i]; // Swap

	          H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
	        } // Return final computed hash


	        return hash;
	      },
	      clone: function clone() {
	        var clone = Hasher.clone.call(this);
	        clone._hash = this._hash.clone();
	        return clone;
	      }
	    });

	    function f1(x, y, z) {
	      return x ^ y ^ z;
	    }

	    function f2(x, y, z) {
	      return x & y | ~x & z;
	    }

	    function f3(x, y, z) {
	      return (x | ~y) ^ z;
	    }

	    function f4(x, y, z) {
	      return x & z | y & ~z;
	    }

	    function f5(x, y, z) {
	      return x ^ (y | ~z);
	    }

	    function rotl(x, n) {
	      return x << n | x >>> 32 - n;
	    }
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */


	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */

	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	  })();

	  return CryptoJS.RIPEMD160;
	});
	});

	var hmac = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;
	    /**
	     * HMAC algorithm.
	     */

	    C_algo.HMAC = Base.extend({
	      /**
	       * Initializes a newly created HMAC.
	       *
	       * @param {Hasher} hasher The hash algorithm to use.
	       * @param {WordArray|string} key The secret key.
	       *
	       * @example
	       *
	       *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	       */
	      init: function init(hasher, key) {
	        // Init hasher
	        hasher = this._hasher = new hasher.init(); // Convert string to WordArray, else assume WordArray already

	        if (typeof key == 'string') {
	          key = Utf8.parse(key);
	        } // Shortcuts


	        var hasherBlockSize = hasher.blockSize;
	        var hasherBlockSizeBytes = hasherBlockSize * 4; // Allow arbitrary length keys

	        if (key.sigBytes > hasherBlockSizeBytes) {
	          key = hasher.finalize(key);
	        } // Clamp excess bits


	        key.clamp(); // Clone key for inner and outer pads

	        var oKey = this._oKey = key.clone();
	        var iKey = this._iKey = key.clone(); // Shortcuts

	        var oKeyWords = oKey.words;
	        var iKeyWords = iKey.words; // XOR keys with pad constants

	        for (var i = 0; i < hasherBlockSize; i++) {
	          oKeyWords[i] ^= 0x5c5c5c5c;
	          iKeyWords[i] ^= 0x36363636;
	        }

	        oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes; // Set initial values

	        this.reset();
	      },

	      /**
	       * Resets this HMAC to its initial state.
	       *
	       * @example
	       *
	       *     hmacHasher.reset();
	       */
	      reset: function reset() {
	        // Shortcut
	        var hasher = this._hasher; // Reset

	        hasher.reset();
	        hasher.update(this._iKey);
	      },

	      /**
	       * Updates this HMAC with a message.
	       *
	       * @param {WordArray|string} messageUpdate The message to append.
	       *
	       * @return {HMAC} This HMAC instance.
	       *
	       * @example
	       *
	       *     hmacHasher.update('message');
	       *     hmacHasher.update(wordArray);
	       */
	      update: function update(messageUpdate) {
	        this._hasher.update(messageUpdate); // Chainable


	        return this;
	      },

	      /**
	       * Finalizes the HMAC computation.
	       * Note that the finalize operation is effectively a destructive, read-once operation.
	       *
	       * @param {WordArray|string} messageUpdate (Optional) A final message update.
	       *
	       * @return {WordArray} The HMAC.
	       *
	       * @example
	       *
	       *     var hmac = hmacHasher.finalize();
	       *     var hmac = hmacHasher.finalize('message');
	       *     var hmac = hmacHasher.finalize(wordArray);
	       */
	      finalize: function finalize(messageUpdate) {
	        // Shortcut
	        var hasher = this._hasher; // Compute HMAC

	        var innerHash = hasher.finalize(messageUpdate);
	        hasher.reset();
	        var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
	        return hmac;
	      }
	    });
	  })();
	});
	});

	var pbkdf2 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, sha1, hmac);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;
	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */

	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	       * @property {Hasher} hasher The hasher to use. Default: SHA1
	       * @property {number} iterations The number of iterations to perform. Default: 1
	       */
	      cfg: Base.extend({
	        keySize: 128 / 32,
	        hasher: SHA1,
	        iterations: 1
	      }),

	      /**
	       * Initializes a newly created key derivation function.
	       *
	       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	       *
	       * @example
	       *
	       *     var kdf = CryptoJS.algo.PBKDF2.create();
	       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	       */
	      init: function init(cfg) {
	        this.cfg = this.cfg.extend(cfg);
	      },

	      /**
	       * Computes the Password-Based Key Derivation Function 2.
	       *
	       * @param {WordArray|string} password The password.
	       * @param {WordArray|string} salt A salt.
	       *
	       * @return {WordArray} The derived key.
	       *
	       * @example
	       *
	       *     var key = kdf.compute(password, salt);
	       */
	      compute: function compute(password, salt) {
	        // Shortcut
	        var cfg = this.cfg; // Init HMAC

	        var hmac = HMAC.create(cfg.hasher, password); // Initial values

	        var derivedKey = WordArray.create();
	        var blockIndex = WordArray.create([0x00000001]); // Shortcuts

	        var derivedKeyWords = derivedKey.words;
	        var blockIndexWords = blockIndex.words;
	        var keySize = cfg.keySize;
	        var iterations = cfg.iterations; // Generate key

	        while (derivedKeyWords.length < keySize) {
	          var block = hmac.update(salt).finalize(blockIndex);
	          hmac.reset(); // Shortcuts

	          var blockWords = block.words;
	          var blockWordsLength = blockWords.length; // Iterations

	          var intermediate = block;

	          for (var i = 1; i < iterations; i++) {
	            intermediate = hmac.finalize(intermediate);
	            hmac.reset(); // Shortcut

	            var intermediateWords = intermediate.words; // XOR intermediate with block

	            for (var j = 0; j < blockWordsLength; j++) {
	              blockWords[j] ^= intermediateWords[j];
	            }
	          }

	          derivedKey.concat(block);
	          blockIndexWords[0]++;
	        }

	        derivedKey.sigBytes = keySize * 4;
	        return derivedKey;
	      }
	    });
	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */

	    C.PBKDF2 = function (password, salt, cfg) {
	      return PBKDF2.create(cfg).compute(password, salt);
	    };
	  })();

	  return CryptoJS.PBKDF2;
	});
	});

	var evpkdf = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, sha1, hmac);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;
	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */

	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	       * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	       * @property {number} iterations The number of iterations to perform. Default: 1
	       */
	      cfg: Base.extend({
	        keySize: 128 / 32,
	        hasher: MD5,
	        iterations: 1
	      }),

	      /**
	       * Initializes a newly created key derivation function.
	       *
	       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	       *
	       * @example
	       *
	       *     var kdf = CryptoJS.algo.EvpKDF.create();
	       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	       */
	      init: function init(cfg) {
	        this.cfg = this.cfg.extend(cfg);
	      },

	      /**
	       * Derives a key from a password.
	       *
	       * @param {WordArray|string} password The password.
	       * @param {WordArray|string} salt A salt.
	       *
	       * @return {WordArray} The derived key.
	       *
	       * @example
	       *
	       *     var key = kdf.compute(password, salt);
	       */
	      compute: function compute(password, salt) {
	        var block; // Shortcut

	        var cfg = this.cfg; // Init hasher

	        var hasher = cfg.hasher.create(); // Initial values

	        var derivedKey = WordArray.create(); // Shortcuts

	        var derivedKeyWords = derivedKey.words;
	        var keySize = cfg.keySize;
	        var iterations = cfg.iterations; // Generate key

	        while (derivedKeyWords.length < keySize) {
	          if (block) {
	            hasher.update(block);
	          }

	          block = hasher.update(password).finalize(salt);
	          hasher.reset(); // Iterations

	          for (var i = 1; i < iterations; i++) {
	            block = hasher.finalize(block);
	            hasher.reset();
	          }

	          derivedKey.concat(block);
	        }

	        derivedKey.sigBytes = keySize * 4;
	        return derivedKey;
	      }
	    });
	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */

	    C.EvpKDF = function (password, salt, cfg) {
	      return EvpKDF.create(cfg).compute(password, salt);
	    };
	  })();

	  return CryptoJS.EvpKDF;
	});
	});

	var cipherCore = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, evpkdf);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * Cipher core components.
	   */
	  CryptoJS.lib.Cipher || function (undefined$1) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;
	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */

	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {WordArray} iv The IV to use for this operation.
	       */
	      cfg: Base.extend(),

	      /**
	       * Creates this cipher in encryption mode.
	       *
	       * @param {WordArray} key The key.
	       * @param {Object} cfg (Optional) The configuration options to use for this operation.
	       *
	       * @return {Cipher} A cipher instance.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	       */
	      createEncryptor: function createEncryptor(key, cfg) {
	        return this.create(this._ENC_XFORM_MODE, key, cfg);
	      },

	      /**
	       * Creates this cipher in decryption mode.
	       *
	       * @param {WordArray} key The key.
	       * @param {Object} cfg (Optional) The configuration options to use for this operation.
	       *
	       * @return {Cipher} A cipher instance.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	       */
	      createDecryptor: function createDecryptor(key, cfg) {
	        return this.create(this._DEC_XFORM_MODE, key, cfg);
	      },

	      /**
	       * Initializes a newly created cipher.
	       *
	       * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	       * @param {WordArray} key The key.
	       * @param {Object} cfg (Optional) The configuration options to use for this operation.
	       *
	       * @example
	       *
	       *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	       */
	      init: function init(xformMode, key, cfg) {
	        // Apply config defaults
	        this.cfg = this.cfg.extend(cfg); // Store transform mode and key

	        this._xformMode = xformMode;
	        this._key = key; // Set initial values

	        this.reset();
	      },

	      /**
	       * Resets this cipher to its initial state.
	       *
	       * @example
	       *
	       *     cipher.reset();
	       */
	      reset: function reset() {
	        // Reset data buffer
	        BufferedBlockAlgorithm.reset.call(this); // Perform concrete-cipher logic

	        this._doReset();
	      },

	      /**
	       * Adds data to be encrypted or decrypted.
	       *
	       * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	       *
	       * @return {WordArray} The data after processing.
	       *
	       * @example
	       *
	       *     var encrypted = cipher.process('data');
	       *     var encrypted = cipher.process(wordArray);
	       */
	      process: function process(dataUpdate) {
	        // Append
	        this._append(dataUpdate); // Process available blocks


	        return this._process();
	      },

	      /**
	       * Finalizes the encryption or decryption process.
	       * Note that the finalize operation is effectively a destructive, read-once operation.
	       *
	       * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	       *
	       * @return {WordArray} The data after final processing.
	       *
	       * @example
	       *
	       *     var encrypted = cipher.finalize();
	       *     var encrypted = cipher.finalize('data');
	       *     var encrypted = cipher.finalize(wordArray);
	       */
	      finalize: function finalize(dataUpdate) {
	        // Final data update
	        if (dataUpdate) {
	          this._append(dataUpdate);
	        } // Perform concrete-cipher logic


	        var finalProcessedData = this._doFinalize();

	        return finalProcessedData;
	      },
	      keySize: 128 / 32,
	      ivSize: 128 / 32,
	      _ENC_XFORM_MODE: 1,
	      _DEC_XFORM_MODE: 2,

	      /**
	       * Creates shortcut functions to a cipher's object interface.
	       *
	       * @param {Cipher} cipher The cipher to create a helper for.
	       *
	       * @return {Object} An object with encrypt and decrypt shortcut functions.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	       */
	      _createHelper: function () {
	        function selectCipherStrategy(key) {
	          if (typeof key == 'string') {
	            return PasswordBasedCipher;
	          } else {
	            return SerializableCipher;
	          }
	        }

	        return function (cipher) {
	          return {
	            encrypt: function encrypt(message, key, cfg) {
	              return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	            },
	            decrypt: function decrypt(ciphertext, key, cfg) {
	              return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	            }
	          };
	        };
	      }()
	    });
	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */

	    C_lib.StreamCipher = Cipher.extend({
	      _doFinalize: function _doFinalize() {
	        // Process partial blocks
	        var finalProcessedBlocks = this._process(!!'flush');

	        return finalProcessedBlocks;
	      },
	      blockSize: 1
	    });
	    /**
	     * Mode namespace.
	     */

	    var C_mode = C.mode = {};
	    /**
	     * Abstract base block cipher mode template.
	     */

	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	      /**
	       * Creates this mode for encryption.
	       *
	       * @param {Cipher} cipher A block cipher instance.
	       * @param {Array} iv The IV words.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	       */
	      createEncryptor: function createEncryptor(cipher, iv) {
	        return this.Encryptor.create(cipher, iv);
	      },

	      /**
	       * Creates this mode for decryption.
	       *
	       * @param {Cipher} cipher A block cipher instance.
	       * @param {Array} iv The IV words.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	       */
	      createDecryptor: function createDecryptor(cipher, iv) {
	        return this.Decryptor.create(cipher, iv);
	      },

	      /**
	       * Initializes a newly created mode.
	       *
	       * @param {Cipher} cipher A block cipher instance.
	       * @param {Array} iv The IV words.
	       *
	       * @example
	       *
	       *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	       */
	      init: function init(cipher, iv) {
	        this._cipher = cipher;
	        this._iv = iv;
	      }
	    });
	    /**
	     * Cipher Block Chaining mode.
	     */

	    var CBC = C_mode.CBC = function () {
	      /**
	       * Abstract base CBC mode.
	       */
	      var CBC = BlockCipherMode.extend();
	      /**
	       * CBC encryptor.
	       */

	      CBC.Encryptor = CBC.extend({
	        /**
	         * Processes the data block at offset.
	         *
	         * @param {Array} words The data words to operate on.
	         * @param {number} offset The offset where the block starts.
	         *
	         * @example
	         *
	         *     mode.processBlock(data.words, offset);
	         */
	        processBlock: function processBlock(words, offset) {
	          // Shortcuts
	          var cipher = this._cipher;
	          var blockSize = cipher.blockSize; // XOR and encrypt

	          xorBlock.call(this, words, offset, blockSize);
	          cipher.encryptBlock(words, offset); // Remember this block to use with next block

	          this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	      });
	      /**
	       * CBC decryptor.
	       */

	      CBC.Decryptor = CBC.extend({
	        /**
	         * Processes the data block at offset.
	         *
	         * @param {Array} words The data words to operate on.
	         * @param {number} offset The offset where the block starts.
	         *
	         * @example
	         *
	         *     mode.processBlock(data.words, offset);
	         */
	        processBlock: function processBlock(words, offset) {
	          // Shortcuts
	          var cipher = this._cipher;
	          var blockSize = cipher.blockSize; // Remember this block to use with next block

	          var thisBlock = words.slice(offset, offset + blockSize); // Decrypt and XOR

	          cipher.decryptBlock(words, offset);
	          xorBlock.call(this, words, offset, blockSize); // This block becomes the previous block

	          this._prevBlock = thisBlock;
	        }
	      });

	      function xorBlock(words, offset, blockSize) {
	        var block; // Shortcut

	        var iv = this._iv; // Choose mixing block

	        if (iv) {
	          block = iv; // Remove IV for subsequent blocks

	          this._iv = undefined$1;
	        } else {
	          block = this._prevBlock;
	        } // XOR blocks


	        for (var i = 0; i < blockSize; i++) {
	          words[offset + i] ^= block[i];
	        }
	      }

	      return CBC;
	    }();
	    /**
	     * Padding namespace.
	     */


	    var C_pad = C.pad = {};
	    /**
	     * PKCS #5/7 padding strategy.
	     */

	    var Pkcs7 = C_pad.Pkcs7 = {
	      /**
	       * Pads data using the algorithm defined in PKCS #5/7.
	       *
	       * @param {WordArray} data The data to pad.
	       * @param {number} blockSize The multiple that the data should be padded to.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	       */
	      pad: function pad(data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4; // Count padding bytes

	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Create padding word

	        var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes; // Create padding

	        var paddingWords = [];

	        for (var i = 0; i < nPaddingBytes; i += 4) {
	          paddingWords.push(paddingWord);
	        }

	        var padding = WordArray.create(paddingWords, nPaddingBytes); // Add padding

	        data.concat(padding);
	      },

	      /**
	       * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	       *
	       * @param {WordArray} data The data to unpad.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	       */
	      unpad: function unpad(data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff; // Remove padding

	        data.sigBytes -= nPaddingBytes;
	      }
	    };
	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */

	    C_lib.BlockCipher = Cipher.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {Mode} mode The block mode to use. Default: CBC
	       * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	       */
	      cfg: Cipher.cfg.extend({
	        mode: CBC,
	        padding: Pkcs7
	      }),
	      reset: function reset() {
	        var modeCreator; // Reset cipher

	        Cipher.reset.call(this); // Shortcuts

	        var cfg = this.cfg;
	        var iv = cfg.iv;
	        var mode = cfg.mode; // Reset block mode

	        if (this._xformMode == this._ENC_XFORM_MODE) {
	          modeCreator = mode.createEncryptor;
	        } else
	          /* if (this._xformMode == this._DEC_XFORM_MODE) */
	          {
	            modeCreator = mode.createDecryptor; // Keep at least one block in the buffer for unpadding

	            this._minBufferSize = 1;
	          }

	        if (this._mode && this._mode.__creator == modeCreator) {
	          this._mode.init(this, iv && iv.words);
	        } else {
	          this._mode = modeCreator.call(mode, this, iv && iv.words);
	          this._mode.__creator = modeCreator;
	        }
	      },
	      _doProcessBlock: function _doProcessBlock(words, offset) {
	        this._mode.processBlock(words, offset);
	      },
	      _doFinalize: function _doFinalize() {
	        var finalProcessedBlocks; // Shortcut

	        var padding = this.cfg.padding; // Finalize

	        if (this._xformMode == this._ENC_XFORM_MODE) {
	          // Pad data
	          padding.pad(this._data, this.blockSize); // Process final blocks

	          finalProcessedBlocks = this._process(!!'flush');
	        } else
	          /* if (this._xformMode == this._DEC_XFORM_MODE) */
	          {
	            // Process final blocks
	            finalProcessedBlocks = this._process(!!'flush'); // Unpad data

	            padding.unpad(finalProcessedBlocks);
	          }

	        return finalProcessedBlocks;
	      },
	      blockSize: 128 / 32
	    });
	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */

	    var CipherParams = C_lib.CipherParams = Base.extend({
	      /**
	       * Initializes a newly created cipher params object.
	       *
	       * @param {Object} cipherParams An object with any of the possible cipher parameters.
	       *
	       * @example
	       *
	       *     var cipherParams = CryptoJS.lib.CipherParams.create({
	       *         ciphertext: ciphertextWordArray,
	       *         key: keyWordArray,
	       *         iv: ivWordArray,
	       *         salt: saltWordArray,
	       *         algorithm: CryptoJS.algo.AES,
	       *         mode: CryptoJS.mode.CBC,
	       *         padding: CryptoJS.pad.PKCS7,
	       *         blockSize: 4,
	       *         formatter: CryptoJS.format.OpenSSL
	       *     });
	       */
	      init: function init(cipherParams) {
	        this.mixIn(cipherParams);
	      },

	      /**
	       * Converts this cipher params object to a string.
	       *
	       * @param {Format} formatter (Optional) The formatting strategy to use.
	       *
	       * @return {string} The stringified cipher params.
	       *
	       * @throws Error If neither the formatter nor the default formatter is set.
	       *
	       * @example
	       *
	       *     var string = cipherParams + '';
	       *     var string = cipherParams.toString();
	       *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	       */
	      toString: function toString(formatter) {
	        return (formatter || this.formatter).stringify(this);
	      }
	    });
	    /**
	     * Format namespace.
	     */

	    var C_format = C.format = {};
	    /**
	     * OpenSSL formatting strategy.
	     */

	    var OpenSSLFormatter = C_format.OpenSSL = {
	      /**
	       * Converts a cipher params object to an OpenSSL-compatible string.
	       *
	       * @param {CipherParams} cipherParams The cipher params object.
	       *
	       * @return {string} The OpenSSL-compatible string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	       */
	      stringify: function stringify(cipherParams) {
	        var wordArray; // Shortcuts

	        var ciphertext = cipherParams.ciphertext;
	        var salt = cipherParams.salt; // Format

	        if (salt) {
	          wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	        } else {
	          wordArray = ciphertext;
	        }

	        return wordArray.toString(Base64);
	      },

	      /**
	       * Converts an OpenSSL-compatible string to a cipher params object.
	       *
	       * @param {string} openSSLStr The OpenSSL-compatible string.
	       *
	       * @return {CipherParams} The cipher params object.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	       */
	      parse: function parse(openSSLStr) {
	        var salt; // Parse base64

	        var ciphertext = Base64.parse(openSSLStr); // Shortcut

	        var ciphertextWords = ciphertext.words; // Test for salt

	        if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	          // Extract salt
	          salt = WordArray.create(ciphertextWords.slice(2, 4)); // Remove salt from ciphertext

	          ciphertextWords.splice(0, 4);
	          ciphertext.sigBytes -= 16;
	        }

	        return CipherParams.create({
	          ciphertext: ciphertext,
	          salt: salt
	        });
	      }
	    };
	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */

	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	       */
	      cfg: Base.extend({
	        format: OpenSSLFormatter
	      }),

	      /**
	       * Encrypts a message.
	       *
	       * @param {Cipher} cipher The cipher algorithm to use.
	       * @param {WordArray|string} message The message to encrypt.
	       * @param {WordArray} key The key.
	       * @param {Object} cfg (Optional) The configuration options to use for this operation.
	       *
	       * @return {CipherParams} A cipher params object.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	       */
	      encrypt: function encrypt(cipher, message, key, cfg) {
	        // Apply config defaults
	        cfg = this.cfg.extend(cfg); // Encrypt

	        var encryptor = cipher.createEncryptor(key, cfg);
	        var ciphertext = encryptor.finalize(message); // Shortcut

	        var cipherCfg = encryptor.cfg; // Create and return serializable cipher params

	        return CipherParams.create({
	          ciphertext: ciphertext,
	          key: key,
	          iv: cipherCfg.iv,
	          algorithm: cipher,
	          mode: cipherCfg.mode,
	          padding: cipherCfg.padding,
	          blockSize: cipher.blockSize,
	          formatter: cfg.format
	        });
	      },

	      /**
	       * Decrypts serialized ciphertext.
	       *
	       * @param {Cipher} cipher The cipher algorithm to use.
	       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	       * @param {WordArray} key The key.
	       * @param {Object} cfg (Optional) The configuration options to use for this operation.
	       *
	       * @return {WordArray} The plaintext.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	       */
	      decrypt: function decrypt(cipher, ciphertext, key, cfg) {
	        // Apply config defaults
	        cfg = this.cfg.extend(cfg); // Convert string to CipherParams

	        ciphertext = this._parse(ciphertext, cfg.format); // Decrypt

	        var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
	        return plaintext;
	      },

	      /**
	       * Converts serialized ciphertext to CipherParams,
	       * else assumed CipherParams already and returns ciphertext unchanged.
	       *
	       * @param {CipherParams|string} ciphertext The ciphertext.
	       * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	       *
	       * @return {CipherParams} The unserialized ciphertext.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	       */
	      _parse: function _parse(ciphertext, format) {
	        if (typeof ciphertext == 'string') {
	          return format.parse(ciphertext, this);
	        } else {
	          return ciphertext;
	        }
	      }
	    });
	    /**
	     * Key derivation function namespace.
	     */

	    var C_kdf = C.kdf = {};
	    /**
	     * OpenSSL key derivation function.
	     */

	    var OpenSSLKdf = C_kdf.OpenSSL = {
	      /**
	       * Derives a key and IV from a password.
	       *
	       * @param {string} password The password to derive from.
	       * @param {number} keySize The size in words of the key to generate.
	       * @param {number} ivSize The size in words of the IV to generate.
	       * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	       *
	       * @return {CipherParams} A cipher params object with the key, IV, and salt.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	       */
	      execute: function execute(password, keySize, ivSize, salt) {
	        // Generate random salt
	        if (!salt) {
	          salt = WordArray.random(64 / 8);
	        } // Derive key and IV


	        var key = EvpKDF.create({
	          keySize: keySize + ivSize
	        }).compute(password, salt); // Separate key and IV

	        var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	        key.sigBytes = keySize * 4; // Return params

	        return CipherParams.create({
	          key: key,
	          iv: iv,
	          salt: salt
	        });
	      }
	    };
	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */

	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	       */
	      cfg: SerializableCipher.cfg.extend({
	        kdf: OpenSSLKdf
	      }),

	      /**
	       * Encrypts a message using a password.
	       *
	       * @param {Cipher} cipher The cipher algorithm to use.
	       * @param {WordArray|string} message The message to encrypt.
	       * @param {string} password The password.
	       * @param {Object} cfg (Optional) The configuration options to use for this operation.
	       *
	       * @return {CipherParams} A cipher params object.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	       */
	      encrypt: function encrypt(cipher, message, password, cfg) {
	        // Apply config defaults
	        cfg = this.cfg.extend(cfg); // Derive key and other params

	        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); // Add IV to config

	        cfg.iv = derivedParams.iv; // Encrypt

	        var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg); // Mix in derived params

	        ciphertext.mixIn(derivedParams);
	        return ciphertext;
	      },

	      /**
	       * Decrypts serialized ciphertext using a password.
	       *
	       * @param {Cipher} cipher The cipher algorithm to use.
	       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	       * @param {string} password The password.
	       * @param {Object} cfg (Optional) The configuration options to use for this operation.
	       *
	       * @return {WordArray} The plaintext.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	       */
	      decrypt: function decrypt(cipher, ciphertext, password, cfg) {
	        // Apply config defaults
	        cfg = this.cfg.extend(cfg); // Convert string to CipherParams

	        ciphertext = this._parse(ciphertext, cfg.format); // Derive key and other params

	        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt); // Add IV to config

	        cfg.iv = derivedParams.iv; // Decrypt

	        var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
	        return plaintext;
	      }
	    });
	  }();
	});
	});

	var modeCfb = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * Cipher Feedback block mode.
	   */
	  CryptoJS.mode.CFB = function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();
	    CFB.Encryptor = CFB.extend({
	      processBlock: function processBlock(words, offset) {
	        // Shortcuts
	        var cipher = this._cipher;
	        var blockSize = cipher.blockSize;
	        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // Remember this block to use with next block

	        this._prevBlock = words.slice(offset, offset + blockSize);
	      }
	    });
	    CFB.Decryptor = CFB.extend({
	      processBlock: function processBlock(words, offset) {
	        // Shortcuts
	        var cipher = this._cipher;
	        var blockSize = cipher.blockSize; // Remember this block to use with next block

	        var thisBlock = words.slice(offset, offset + blockSize);
	        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // This block becomes the previous block

	        this._prevBlock = thisBlock;
	      }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	      var keystream; // Shortcut

	      var iv = this._iv; // Generate keystream

	      if (iv) {
	        keystream = iv.slice(0); // Remove IV for subsequent blocks

	        this._iv = undefined;
	      } else {
	        keystream = this._prevBlock;
	      }

	      cipher.encryptBlock(keystream, 0); // Encrypt

	      for (var i = 0; i < blockSize; i++) {
	        words[offset + i] ^= keystream[i];
	      }
	    }

	    return CFB;
	  }();

	  return CryptoJS.mode.CFB;
	});
	});

	var modeCtr = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * Counter block mode.
	   */
	  CryptoJS.mode.CTR = function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();
	    var Encryptor = CTR.Encryptor = CTR.extend({
	      processBlock: function processBlock(words, offset) {
	        // Shortcuts
	        var cipher = this._cipher;
	        var blockSize = cipher.blockSize;
	        var iv = this._iv;
	        var counter = this._counter; // Generate keystream

	        if (iv) {
	          counter = this._counter = iv.slice(0); // Remove IV for subsequent blocks

	          this._iv = undefined;
	        }

	        var keystream = counter.slice(0);
	        cipher.encryptBlock(keystream, 0); // Increment counter

	        counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0; // Encrypt

	        for (var i = 0; i < blockSize; i++) {
	          words[offset + i] ^= keystream[i];
	        }
	      }
	    });
	    CTR.Decryptor = Encryptor;
	    return CTR;
	  }();

	  return CryptoJS.mode.CTR;
	});
	});

	var modeCtrGladman = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /** @preserve
	   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	   * derived from CryptoJS.mode.CTR
	   * Jan Hruby jhruby.web@gmail.com
	   */
	  CryptoJS.mode.CTRGladman = function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

	    function incWord(word) {
	      if ((word >> 24 & 0xff) === 0xff) {
	        //overflow
	        var b1 = word >> 16 & 0xff;
	        var b2 = word >> 8 & 0xff;
	        var b3 = word & 0xff;

	        if (b1 === 0xff) // overflow b1
	          {
	            b1 = 0;

	            if (b2 === 0xff) {
	              b2 = 0;

	              if (b3 === 0xff) {
	                b3 = 0;
	              } else {
	                ++b3;
	              }
	            } else {
	              ++b2;
	            }
	          } else {
	          ++b1;
	        }

	        word = 0;
	        word += b1 << 16;
	        word += b2 << 8;
	        word += b3;
	      } else {
	        word += 0x01 << 24;
	      }

	      return word;
	    }

	    function incCounter(counter) {
	      if ((counter[0] = incWord(counter[0])) === 0) {
	        // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
	        counter[1] = incWord(counter[1]);
	      }

	      return counter;
	    }

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	      processBlock: function processBlock(words, offset) {
	        // Shortcuts
	        var cipher = this._cipher;
	        var blockSize = cipher.blockSize;
	        var iv = this._iv;
	        var counter = this._counter; // Generate keystream

	        if (iv) {
	          counter = this._counter = iv.slice(0); // Remove IV for subsequent blocks

	          this._iv = undefined;
	        }

	        incCounter(counter);
	        var keystream = counter.slice(0);
	        cipher.encryptBlock(keystream, 0); // Encrypt

	        for (var i = 0; i < blockSize; i++) {
	          words[offset + i] ^= keystream[i];
	        }
	      }
	    });
	    CTRGladman.Decryptor = Encryptor;
	    return CTRGladman;
	  }();

	  return CryptoJS.mode.CTRGladman;
	});
	});

	var modeOfb = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * Output Feedback block mode.
	   */
	  CryptoJS.mode.OFB = function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();
	    var Encryptor = OFB.Encryptor = OFB.extend({
	      processBlock: function processBlock(words, offset) {
	        // Shortcuts
	        var cipher = this._cipher;
	        var blockSize = cipher.blockSize;
	        var iv = this._iv;
	        var keystream = this._keystream; // Generate keystream

	        if (iv) {
	          keystream = this._keystream = iv.slice(0); // Remove IV for subsequent blocks

	          this._iv = undefined;
	        }

	        cipher.encryptBlock(keystream, 0); // Encrypt

	        for (var i = 0; i < blockSize; i++) {
	          words[offset + i] ^= keystream[i];
	        }
	      }
	    });
	    OFB.Decryptor = Encryptor;
	    return OFB;
	  }();

	  return CryptoJS.mode.OFB;
	});
	});

	var modeEcb = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * Electronic Codebook block mode.
	   */
	  CryptoJS.mode.ECB = function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();
	    ECB.Encryptor = ECB.extend({
	      processBlock: function processBlock(words, offset) {
	        this._cipher.encryptBlock(words, offset);
	      }
	    });
	    ECB.Decryptor = ECB.extend({
	      processBlock: function processBlock(words, offset) {
	        this._cipher.decryptBlock(words, offset);
	      }
	    });
	    return ECB;
	  }();

	  return CryptoJS.mode.ECB;
	});
	});

	var padAnsix923 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * ANSI X.923 padding strategy.
	   */
	  CryptoJS.pad.AnsiX923 = {
	    pad: function pad(data, blockSize) {
	      // Shortcuts
	      var dataSigBytes = data.sigBytes;
	      var blockSizeBytes = blockSize * 4; // Count padding bytes

	      var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes; // Compute last byte position

	      var lastBytePos = dataSigBytes + nPaddingBytes - 1; // Pad

	      data.clamp();
	      data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
	      data.sigBytes += nPaddingBytes;
	    },
	    unpad: function unpad(data) {
	      // Get number of padding bytes from last byte
	      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff; // Remove padding

	      data.sigBytes -= nPaddingBytes;
	    }
	  };
	  return CryptoJS.pad.Ansix923;
	});
	});

	var padIso10126 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * ISO 10126 padding strategy.
	   */
	  CryptoJS.pad.Iso10126 = {
	    pad: function pad(data, blockSize) {
	      // Shortcut
	      var blockSizeBytes = blockSize * 4; // Count padding bytes

	      var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Pad

	      data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },
	    unpad: function unpad(data) {
	      // Get number of padding bytes from last byte
	      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff; // Remove padding

	      data.sigBytes -= nPaddingBytes;
	    }
	  };
	  return CryptoJS.pad.Iso10126;
	});
	});

	var padIso97971 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * ISO/IEC 9797-1 Padding Method 2.
	   */
	  CryptoJS.pad.Iso97971 = {
	    pad: function pad(data, blockSize) {
	      // Add 0x80 byte
	      data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1)); // Zero pad the rest

	      CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },
	    unpad: function unpad(data) {
	      // Remove zero padding
	      CryptoJS.pad.ZeroPadding.unpad(data); // Remove one more byte -- the 0x80 byte

	      data.sigBytes--;
	    }
	  };
	  return CryptoJS.pad.Iso97971;
	});
	});

	var padZeropadding = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * Zero padding strategy.
	   */
	  CryptoJS.pad.ZeroPadding = {
	    pad: function pad(data, blockSize) {
	      // Shortcut
	      var blockSizeBytes = blockSize * 4; // Pad

	      data.clamp();
	      data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
	    },
	    unpad: function unpad(data) {
	      // Shortcut
	      var dataWords = data.words; // Unpad

	      var i = data.sigBytes - 1;

	      for (var i = data.sigBytes - 1; i >= 0; i--) {
	        if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff) {
	          data.sigBytes = i + 1;
	          break;
	        }
	      }
	    }
	  };
	  return CryptoJS.pad.ZeroPadding;
	});
	});

	var padNopadding = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  /**
	   * A noop padding strategy.
	   */
	  CryptoJS.pad.NoPadding = {
	    pad: function pad() {},
	    unpad: function unpad() {}
	  };
	  return CryptoJS.pad.NoPadding;
	});
	});

	var formatHex = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function (undefined$1) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;
	    C_format.Hex = {
	      /**
	       * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	       *
	       * @param {CipherParams} cipherParams The cipher params object.
	       *
	       * @return {string} The hexadecimally encoded string.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	       */
	      stringify: function stringify(cipherParams) {
	        return cipherParams.ciphertext.toString(Hex);
	      },

	      /**
	       * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	       *
	       * @param {string} input The hexadecimally encoded string.
	       *
	       * @return {CipherParams} The cipher params object.
	       *
	       * @static
	       *
	       * @example
	       *
	       *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	       */
	      parse: function parse(input) {
	        var ciphertext = Hex.parse(input);
	        return CipherParams.create({
	          ciphertext: ciphertext
	        });
	      }
	    };
	  })();

	  return CryptoJS.format.Hex;
	});
	});

	var aes = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, encBase64, md5, evpkdf, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo; // Lookup tables

	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = []; // Compute lookup tables

	    (function () {
	      // Compute double table
	      var d = [];

	      for (var i = 0; i < 256; i++) {
	        if (i < 128) {
	          d[i] = i << 1;
	        } else {
	          d[i] = i << 1 ^ 0x11b;
	        }
	      } // Walk GF(2^8)


	      var x = 0;
	      var xi = 0;

	      for (var i = 0; i < 256; i++) {
	        // Compute sbox
	        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
	        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
	        SBOX[x] = sx;
	        INV_SBOX[sx] = x; // Compute multiplication

	        var x2 = d[x];
	        var x4 = d[x2];
	        var x8 = d[x4]; // Compute sub bytes, mix columns tables

	        var t = d[sx] * 0x101 ^ sx * 0x1010100;
	        SUB_MIX_0[x] = t << 24 | t >>> 8;
	        SUB_MIX_1[x] = t << 16 | t >>> 16;
	        SUB_MIX_2[x] = t << 8 | t >>> 24;
	        SUB_MIX_3[x] = t; // Compute inv sub bytes, inv mix columns tables

	        var t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
	        INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
	        INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
	        INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
	        INV_SUB_MIX_3[sx] = t; // Compute next counter

	        if (!x) {
	          x = xi = 1;
	        } else {
	          x = x2 ^ d[d[d[x8 ^ x2]]];
	          xi ^= d[d[xi]];
	        }
	      }
	    })(); // Precomputed Rcon lookup


	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	    /**
	     * AES block cipher algorithm.
	     */

	    var AES = C_algo.AES = BlockCipher.extend({
	      _doReset: function _doReset() {
	        var t; // Skip reset of nRounds has been set before and key did not change

	        if (this._nRounds && this._keyPriorReset === this._key) {
	          return;
	        } // Shortcuts


	        var key = this._keyPriorReset = this._key;
	        var keyWords = key.words;
	        var keySize = key.sigBytes / 4; // Compute number of rounds

	        var nRounds = this._nRounds = keySize + 6; // Compute number of key schedule rows

	        var ksRows = (nRounds + 1) * 4; // Compute key schedule

	        var keySchedule = this._keySchedule = [];

	        for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	          if (ksRow < keySize) {
	            keySchedule[ksRow] = keyWords[ksRow];
	          } else {
	            t = keySchedule[ksRow - 1];

	            if (!(ksRow % keySize)) {
	              // Rot word
	              t = t << 8 | t >>> 24; // Sub word

	              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff]; // Mix Rcon

	              t ^= RCON[ksRow / keySize | 0] << 24;
	            } else if (keySize > 6 && ksRow % keySize == 4) {
	              // Sub word
	              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff];
	            }

	            keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	          }
	        } // Compute inv key schedule


	        var invKeySchedule = this._invKeySchedule = [];

	        for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	          var ksRow = ksRows - invKsRow;

	          if (invKsRow % 4) {
	            var t = keySchedule[ksRow];
	          } else {
	            var t = keySchedule[ksRow - 4];
	          }

	          if (invKsRow < 4 || ksRow <= 4) {
	            invKeySchedule[invKsRow] = t;
	          } else {
	            invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	          }
	        }
	      },
	      encryptBlock: function encryptBlock(M, offset) {
	        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	      },
	      decryptBlock: function decryptBlock(M, offset) {
	        // Swap 2nd and 4th rows
	        var t = M[offset + 1];
	        M[offset + 1] = M[offset + 3];
	        M[offset + 3] = t;

	        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); // Inv swap 2nd and 4th rows


	        var t = M[offset + 1];
	        M[offset + 1] = M[offset + 3];
	        M[offset + 3] = t;
	      },
	      _doCryptBlock: function _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	        // Shortcut
	        var nRounds = this._nRounds; // Get input, add round key

	        var s0 = M[offset] ^ keySchedule[0];
	        var s1 = M[offset + 1] ^ keySchedule[1];
	        var s2 = M[offset + 2] ^ keySchedule[2];
	        var s3 = M[offset + 3] ^ keySchedule[3]; // Key schedule row counter

	        var ksRow = 4; // Rounds

	        for (var round = 1; round < nRounds; round++) {
	          // Shift rows, sub bytes, mix columns, add round key
	          var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	          var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	          var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	          var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++]; // Update state

	          s0 = t0;
	          s1 = t1;
	          s2 = t2;
	          s3 = t3;
	        } // Shift rows, sub bytes, add round key


	        var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	        var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	        var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	        var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]; // Set output

	        M[offset] = t0;
	        M[offset + 1] = t1;
	        M[offset + 2] = t2;
	        M[offset + 3] = t3;
	      },
	      keySize: 256 / 32
	    });
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */

	    C.AES = BlockCipher._createHelper(AES);
	  })();

	  return CryptoJS.AES;
	});
	});

	var tripledes = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, encBase64, md5, evpkdf, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo; // Permuted Choice 1 constants

	    var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]; // Permuted Choice 2 constants

	    var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]; // Cumulative bit shift constants

	    var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]; // SBOXes and round permutation constants

	    var SBOX_P = [{
	      0x0: 0x808200,
	      0x10000000: 0x8000,
	      0x20000000: 0x808002,
	      0x30000000: 0x2,
	      0x40000000: 0x200,
	      0x50000000: 0x808202,
	      0x60000000: 0x800202,
	      0x70000000: 0x800000,
	      0x80000000: 0x202,
	      0x90000000: 0x800200,
	      0xa0000000: 0x8200,
	      0xb0000000: 0x808000,
	      0xc0000000: 0x8002,
	      0xd0000000: 0x800002,
	      0xe0000000: 0x0,
	      0xf0000000: 0x8202,
	      0x8000000: 0x0,
	      0x18000000: 0x808202,
	      0x28000000: 0x8202,
	      0x38000000: 0x8000,
	      0x48000000: 0x808200,
	      0x58000000: 0x200,
	      0x68000000: 0x808002,
	      0x78000000: 0x2,
	      0x88000000: 0x800200,
	      0x98000000: 0x8200,
	      0xa8000000: 0x808000,
	      0xb8000000: 0x800202,
	      0xc8000000: 0x800002,
	      0xd8000000: 0x8002,
	      0xe8000000: 0x202,
	      0xf8000000: 0x800000,
	      0x1: 0x8000,
	      0x10000001: 0x2,
	      0x20000001: 0x808200,
	      0x30000001: 0x800000,
	      0x40000001: 0x808002,
	      0x50000001: 0x8200,
	      0x60000001: 0x200,
	      0x70000001: 0x800202,
	      0x80000001: 0x808202,
	      0x90000001: 0x808000,
	      0xa0000001: 0x800002,
	      0xb0000001: 0x8202,
	      0xc0000001: 0x202,
	      0xd0000001: 0x800200,
	      0xe0000001: 0x8002,
	      0xf0000001: 0x0,
	      0x8000001: 0x808202,
	      0x18000001: 0x808000,
	      0x28000001: 0x800000,
	      0x38000001: 0x200,
	      0x48000001: 0x8000,
	      0x58000001: 0x800002,
	      0x68000001: 0x2,
	      0x78000001: 0x8202,
	      0x88000001: 0x8002,
	      0x98000001: 0x800202,
	      0xa8000001: 0x202,
	      0xb8000001: 0x808200,
	      0xc8000001: 0x800200,
	      0xd8000001: 0x0,
	      0xe8000001: 0x8200,
	      0xf8000001: 0x808002
	    }, {
	      0x0: 0x40084010,
	      0x1000000: 0x4000,
	      0x2000000: 0x80000,
	      0x3000000: 0x40080010,
	      0x4000000: 0x40000010,
	      0x5000000: 0x40084000,
	      0x6000000: 0x40004000,
	      0x7000000: 0x10,
	      0x8000000: 0x84000,
	      0x9000000: 0x40004010,
	      0xa000000: 0x40000000,
	      0xb000000: 0x84010,
	      0xc000000: 0x80010,
	      0xd000000: 0x0,
	      0xe000000: 0x4010,
	      0xf000000: 0x40080000,
	      0x800000: 0x40004000,
	      0x1800000: 0x84010,
	      0x2800000: 0x10,
	      0x3800000: 0x40004010,
	      0x4800000: 0x40084010,
	      0x5800000: 0x40000000,
	      0x6800000: 0x80000,
	      0x7800000: 0x40080010,
	      0x8800000: 0x80010,
	      0x9800000: 0x0,
	      0xa800000: 0x4000,
	      0xb800000: 0x40080000,
	      0xc800000: 0x40000010,
	      0xd800000: 0x84000,
	      0xe800000: 0x40084000,
	      0xf800000: 0x4010,
	      0x10000000: 0x0,
	      0x11000000: 0x40080010,
	      0x12000000: 0x40004010,
	      0x13000000: 0x40084000,
	      0x14000000: 0x40080000,
	      0x15000000: 0x10,
	      0x16000000: 0x84010,
	      0x17000000: 0x4000,
	      0x18000000: 0x4010,
	      0x19000000: 0x80000,
	      0x1a000000: 0x80010,
	      0x1b000000: 0x40000010,
	      0x1c000000: 0x84000,
	      0x1d000000: 0x40004000,
	      0x1e000000: 0x40000000,
	      0x1f000000: 0x40084010,
	      0x10800000: 0x84010,
	      0x11800000: 0x80000,
	      0x12800000: 0x40080000,
	      0x13800000: 0x4000,
	      0x14800000: 0x40004000,
	      0x15800000: 0x40084010,
	      0x16800000: 0x10,
	      0x17800000: 0x40000000,
	      0x18800000: 0x40084000,
	      0x19800000: 0x40000010,
	      0x1a800000: 0x40004010,
	      0x1b800000: 0x80010,
	      0x1c800000: 0x0,
	      0x1d800000: 0x4010,
	      0x1e800000: 0x40080010,
	      0x1f800000: 0x84000
	    }, {
	      0x0: 0x104,
	      0x100000: 0x0,
	      0x200000: 0x4000100,
	      0x300000: 0x10104,
	      0x400000: 0x10004,
	      0x500000: 0x4000004,
	      0x600000: 0x4010104,
	      0x700000: 0x4010000,
	      0x800000: 0x4000000,
	      0x900000: 0x4010100,
	      0xa00000: 0x10100,
	      0xb00000: 0x4010004,
	      0xc00000: 0x4000104,
	      0xd00000: 0x10000,
	      0xe00000: 0x4,
	      0xf00000: 0x100,
	      0x80000: 0x4010100,
	      0x180000: 0x4010004,
	      0x280000: 0x0,
	      0x380000: 0x4000100,
	      0x480000: 0x4000004,
	      0x580000: 0x10000,
	      0x680000: 0x10004,
	      0x780000: 0x104,
	      0x880000: 0x4,
	      0x980000: 0x100,
	      0xa80000: 0x4010000,
	      0xb80000: 0x10104,
	      0xc80000: 0x10100,
	      0xd80000: 0x4000104,
	      0xe80000: 0x4010104,
	      0xf80000: 0x4000000,
	      0x1000000: 0x4010100,
	      0x1100000: 0x10004,
	      0x1200000: 0x10000,
	      0x1300000: 0x4000100,
	      0x1400000: 0x100,
	      0x1500000: 0x4010104,
	      0x1600000: 0x4000004,
	      0x1700000: 0x0,
	      0x1800000: 0x4000104,
	      0x1900000: 0x4000000,
	      0x1a00000: 0x4,
	      0x1b00000: 0x10100,
	      0x1c00000: 0x4010000,
	      0x1d00000: 0x104,
	      0x1e00000: 0x10104,
	      0x1f00000: 0x4010004,
	      0x1080000: 0x4000000,
	      0x1180000: 0x104,
	      0x1280000: 0x4010100,
	      0x1380000: 0x0,
	      0x1480000: 0x10004,
	      0x1580000: 0x4000100,
	      0x1680000: 0x100,
	      0x1780000: 0x4010004,
	      0x1880000: 0x10000,
	      0x1980000: 0x4010104,
	      0x1a80000: 0x10104,
	      0x1b80000: 0x4000004,
	      0x1c80000: 0x4000104,
	      0x1d80000: 0x4010000,
	      0x1e80000: 0x4,
	      0x1f80000: 0x10100
	    }, {
	      0x0: 0x80401000,
	      0x10000: 0x80001040,
	      0x20000: 0x401040,
	      0x30000: 0x80400000,
	      0x40000: 0x0,
	      0x50000: 0x401000,
	      0x60000: 0x80000040,
	      0x70000: 0x400040,
	      0x80000: 0x80000000,
	      0x90000: 0x400000,
	      0xa0000: 0x40,
	      0xb0000: 0x80001000,
	      0xc0000: 0x80400040,
	      0xd0000: 0x1040,
	      0xe0000: 0x1000,
	      0xf0000: 0x80401040,
	      0x8000: 0x80001040,
	      0x18000: 0x40,
	      0x28000: 0x80400040,
	      0x38000: 0x80001000,
	      0x48000: 0x401000,
	      0x58000: 0x80401040,
	      0x68000: 0x0,
	      0x78000: 0x80400000,
	      0x88000: 0x1000,
	      0x98000: 0x80401000,
	      0xa8000: 0x400000,
	      0xb8000: 0x1040,
	      0xc8000: 0x80000000,
	      0xd8000: 0x400040,
	      0xe8000: 0x401040,
	      0xf8000: 0x80000040,
	      0x100000: 0x400040,
	      0x110000: 0x401000,
	      0x120000: 0x80000040,
	      0x130000: 0x0,
	      0x140000: 0x1040,
	      0x150000: 0x80400040,
	      0x160000: 0x80401000,
	      0x170000: 0x80001040,
	      0x180000: 0x80401040,
	      0x190000: 0x80000000,
	      0x1a0000: 0x80400000,
	      0x1b0000: 0x401040,
	      0x1c0000: 0x80001000,
	      0x1d0000: 0x400000,
	      0x1e0000: 0x40,
	      0x1f0000: 0x1000,
	      0x108000: 0x80400000,
	      0x118000: 0x80401040,
	      0x128000: 0x0,
	      0x138000: 0x401000,
	      0x148000: 0x400040,
	      0x158000: 0x80000000,
	      0x168000: 0x80001040,
	      0x178000: 0x40,
	      0x188000: 0x80000040,
	      0x198000: 0x1000,
	      0x1a8000: 0x80001000,
	      0x1b8000: 0x80400040,
	      0x1c8000: 0x1040,
	      0x1d8000: 0x80401000,
	      0x1e8000: 0x400000,
	      0x1f8000: 0x401040
	    }, {
	      0x0: 0x80,
	      0x1000: 0x1040000,
	      0x2000: 0x40000,
	      0x3000: 0x20000000,
	      0x4000: 0x20040080,
	      0x5000: 0x1000080,
	      0x6000: 0x21000080,
	      0x7000: 0x40080,
	      0x8000: 0x1000000,
	      0x9000: 0x20040000,
	      0xa000: 0x20000080,
	      0xb000: 0x21040080,
	      0xc000: 0x21040000,
	      0xd000: 0x0,
	      0xe000: 0x1040080,
	      0xf000: 0x21000000,
	      0x800: 0x1040080,
	      0x1800: 0x21000080,
	      0x2800: 0x80,
	      0x3800: 0x1040000,
	      0x4800: 0x40000,
	      0x5800: 0x20040080,
	      0x6800: 0x21040000,
	      0x7800: 0x20000000,
	      0x8800: 0x20040000,
	      0x9800: 0x0,
	      0xa800: 0x21040080,
	      0xb800: 0x1000080,
	      0xc800: 0x20000080,
	      0xd800: 0x21000000,
	      0xe800: 0x1000000,
	      0xf800: 0x40080,
	      0x10000: 0x40000,
	      0x11000: 0x80,
	      0x12000: 0x20000000,
	      0x13000: 0x21000080,
	      0x14000: 0x1000080,
	      0x15000: 0x21040000,
	      0x16000: 0x20040080,
	      0x17000: 0x1000000,
	      0x18000: 0x21040080,
	      0x19000: 0x21000000,
	      0x1a000: 0x1040000,
	      0x1b000: 0x20040000,
	      0x1c000: 0x40080,
	      0x1d000: 0x20000080,
	      0x1e000: 0x0,
	      0x1f000: 0x1040080,
	      0x10800: 0x21000080,
	      0x11800: 0x1000000,
	      0x12800: 0x1040000,
	      0x13800: 0x20040080,
	      0x14800: 0x20000000,
	      0x15800: 0x1040080,
	      0x16800: 0x80,
	      0x17800: 0x21040000,
	      0x18800: 0x40080,
	      0x19800: 0x21040080,
	      0x1a800: 0x0,
	      0x1b800: 0x21000000,
	      0x1c800: 0x1000080,
	      0x1d800: 0x40000,
	      0x1e800: 0x20040000,
	      0x1f800: 0x20000080
	    }, {
	      0x0: 0x10000008,
	      0x100: 0x2000,
	      0x200: 0x10200000,
	      0x300: 0x10202008,
	      0x400: 0x10002000,
	      0x500: 0x200000,
	      0x600: 0x200008,
	      0x700: 0x10000000,
	      0x800: 0x0,
	      0x900: 0x10002008,
	      0xa00: 0x202000,
	      0xb00: 0x8,
	      0xc00: 0x10200008,
	      0xd00: 0x202008,
	      0xe00: 0x2008,
	      0xf00: 0x10202000,
	      0x80: 0x10200000,
	      0x180: 0x10202008,
	      0x280: 0x8,
	      0x380: 0x200000,
	      0x480: 0x202008,
	      0x580: 0x10000008,
	      0x680: 0x10002000,
	      0x780: 0x2008,
	      0x880: 0x200008,
	      0x980: 0x2000,
	      0xa80: 0x10002008,
	      0xb80: 0x10200008,
	      0xc80: 0x0,
	      0xd80: 0x10202000,
	      0xe80: 0x202000,
	      0xf80: 0x10000000,
	      0x1000: 0x10002000,
	      0x1100: 0x10200008,
	      0x1200: 0x10202008,
	      0x1300: 0x2008,
	      0x1400: 0x200000,
	      0x1500: 0x10000000,
	      0x1600: 0x10000008,
	      0x1700: 0x202000,
	      0x1800: 0x202008,
	      0x1900: 0x0,
	      0x1a00: 0x8,
	      0x1b00: 0x10200000,
	      0x1c00: 0x2000,
	      0x1d00: 0x10002008,
	      0x1e00: 0x10202000,
	      0x1f00: 0x200008,
	      0x1080: 0x8,
	      0x1180: 0x202000,
	      0x1280: 0x200000,
	      0x1380: 0x10000008,
	      0x1480: 0x10002000,
	      0x1580: 0x2008,
	      0x1680: 0x10202008,
	      0x1780: 0x10200000,
	      0x1880: 0x10202000,
	      0x1980: 0x10200008,
	      0x1a80: 0x2000,
	      0x1b80: 0x202008,
	      0x1c80: 0x200008,
	      0x1d80: 0x0,
	      0x1e80: 0x10000000,
	      0x1f80: 0x10002008
	    }, {
	      0x0: 0x100000,
	      0x10: 0x2000401,
	      0x20: 0x400,
	      0x30: 0x100401,
	      0x40: 0x2100401,
	      0x50: 0x0,
	      0x60: 0x1,
	      0x70: 0x2100001,
	      0x80: 0x2000400,
	      0x90: 0x100001,
	      0xa0: 0x2000001,
	      0xb0: 0x2100400,
	      0xc0: 0x2100000,
	      0xd0: 0x401,
	      0xe0: 0x100400,
	      0xf0: 0x2000000,
	      0x8: 0x2100001,
	      0x18: 0x0,
	      0x28: 0x2000401,
	      0x38: 0x2100400,
	      0x48: 0x100000,
	      0x58: 0x2000001,
	      0x68: 0x2000000,
	      0x78: 0x401,
	      0x88: 0x100401,
	      0x98: 0x2000400,
	      0xa8: 0x2100000,
	      0xb8: 0x100001,
	      0xc8: 0x400,
	      0xd8: 0x2100401,
	      0xe8: 0x1,
	      0xf8: 0x100400,
	      0x100: 0x2000000,
	      0x110: 0x100000,
	      0x120: 0x2000401,
	      0x130: 0x2100001,
	      0x140: 0x100001,
	      0x150: 0x2000400,
	      0x160: 0x2100400,
	      0x170: 0x100401,
	      0x180: 0x401,
	      0x190: 0x2100401,
	      0x1a0: 0x100400,
	      0x1b0: 0x1,
	      0x1c0: 0x0,
	      0x1d0: 0x2100000,
	      0x1e0: 0x2000001,
	      0x1f0: 0x400,
	      0x108: 0x100400,
	      0x118: 0x2000401,
	      0x128: 0x2100001,
	      0x138: 0x1,
	      0x148: 0x2000000,
	      0x158: 0x100000,
	      0x168: 0x401,
	      0x178: 0x2100400,
	      0x188: 0x2000001,
	      0x198: 0x2100000,
	      0x1a8: 0x0,
	      0x1b8: 0x2100401,
	      0x1c8: 0x100401,
	      0x1d8: 0x400,
	      0x1e8: 0x2000400,
	      0x1f8: 0x100001
	    }, {
	      0x0: 0x8000820,
	      0x1: 0x20000,
	      0x2: 0x8000000,
	      0x3: 0x20,
	      0x4: 0x20020,
	      0x5: 0x8020820,
	      0x6: 0x8020800,
	      0x7: 0x800,
	      0x8: 0x8020000,
	      0x9: 0x8000800,
	      0xa: 0x20800,
	      0xb: 0x8020020,
	      0xc: 0x820,
	      0xd: 0x0,
	      0xe: 0x8000020,
	      0xf: 0x20820,
	      0x80000000: 0x800,
	      0x80000001: 0x8020820,
	      0x80000002: 0x8000820,
	      0x80000003: 0x8000000,
	      0x80000004: 0x8020000,
	      0x80000005: 0x20800,
	      0x80000006: 0x20820,
	      0x80000007: 0x20,
	      0x80000008: 0x8000020,
	      0x80000009: 0x820,
	      0x8000000a: 0x20020,
	      0x8000000b: 0x8020800,
	      0x8000000c: 0x0,
	      0x8000000d: 0x8020020,
	      0x8000000e: 0x8000800,
	      0x8000000f: 0x20000,
	      0x10: 0x20820,
	      0x11: 0x8020800,
	      0x12: 0x20,
	      0x13: 0x800,
	      0x14: 0x8000800,
	      0x15: 0x8000020,
	      0x16: 0x8020020,
	      0x17: 0x20000,
	      0x18: 0x0,
	      0x19: 0x20020,
	      0x1a: 0x8020000,
	      0x1b: 0x8000820,
	      0x1c: 0x8020820,
	      0x1d: 0x20800,
	      0x1e: 0x820,
	      0x1f: 0x8000000,
	      0x80000010: 0x20000,
	      0x80000011: 0x800,
	      0x80000012: 0x8020020,
	      0x80000013: 0x20820,
	      0x80000014: 0x20,
	      0x80000015: 0x8020000,
	      0x80000016: 0x8000000,
	      0x80000017: 0x8000820,
	      0x80000018: 0x8020820,
	      0x80000019: 0x8000020,
	      0x8000001a: 0x8000800,
	      0x8000001b: 0x0,
	      0x8000001c: 0x20800,
	      0x8000001d: 0x820,
	      0x8000001e: 0x20020,
	      0x8000001f: 0x8020800
	    }]; // Masks that select the SBOX input

	    var SBOX_MASK = [0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000, 0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f];
	    /**
	     * DES block cipher algorithm.
	     */

	    var DES = C_algo.DES = BlockCipher.extend({
	      _doReset: function _doReset() {
	        // Shortcuts
	        var key = this._key;
	        var keyWords = key.words; // Select 56 bits according to PC1

	        var keyBits = [];

	        for (var i = 0; i < 56; i++) {
	          var keyBitPos = PC1[i] - 1;
	          keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
	        } // Assemble 16 subkeys


	        var subKeys = this._subKeys = [];

	        for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	          // Create subkey
	          var subKey = subKeys[nSubKey] = []; // Shortcut

	          var bitShift = BIT_SHIFTS[nSubKey]; // Select 48 bits according to PC2

	          for (var i = 0; i < 24; i++) {
	            // Select from the left 28 key bits
	            subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6; // Select from the right 28 key bits

	            subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
	          } // Since each subkey is applied to an expanded 32-bit input,
	          // the subkey can be broken into 8 values scaled to 32-bits,
	          // which allows the key to be used without expansion


	          subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;

	          for (var i = 1; i < 7; i++) {
	            subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
	          }

	          subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
	        } // Compute inverse subkeys


	        var invSubKeys = this._invSubKeys = [];

	        for (var i = 0; i < 16; i++) {
	          invSubKeys[i] = subKeys[15 - i];
	        }
	      },
	      encryptBlock: function encryptBlock(M, offset) {
	        this._doCryptBlock(M, offset, this._subKeys);
	      },
	      decryptBlock: function decryptBlock(M, offset) {
	        this._doCryptBlock(M, offset, this._invSubKeys);
	      },
	      _doCryptBlock: function _doCryptBlock(M, offset, subKeys) {
	        // Get input
	        this._lBlock = M[offset];
	        this._rBlock = M[offset + 1]; // Initial permutation

	        exchangeLR.call(this, 4, 0x0f0f0f0f);
	        exchangeLR.call(this, 16, 0x0000ffff);
	        exchangeRL.call(this, 2, 0x33333333);
	        exchangeRL.call(this, 8, 0x00ff00ff);
	        exchangeLR.call(this, 1, 0x55555555); // Rounds

	        for (var round = 0; round < 16; round++) {
	          // Shortcuts
	          var subKey = subKeys[round];
	          var lBlock = this._lBlock;
	          var rBlock = this._rBlock; // Feistel function

	          var f = 0;

	          for (var i = 0; i < 8; i++) {
	            f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	          }

	          this._lBlock = rBlock;
	          this._rBlock = lBlock ^ f;
	        } // Undo swap from last round


	        var t = this._lBlock;
	        this._lBlock = this._rBlock;
	        this._rBlock = t; // Final permutation

	        exchangeLR.call(this, 1, 0x55555555);
	        exchangeRL.call(this, 8, 0x00ff00ff);
	        exchangeRL.call(this, 2, 0x33333333);
	        exchangeLR.call(this, 16, 0x0000ffff);
	        exchangeLR.call(this, 4, 0x0f0f0f0f); // Set output

	        M[offset] = this._lBlock;
	        M[offset + 1] = this._rBlock;
	      },
	      keySize: 64 / 32,
	      ivSize: 64 / 32,
	      blockSize: 64 / 32
	    }); // Swap bits across the left and right words

	    function exchangeLR(offset, mask) {
	      var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
	      this._rBlock ^= t;
	      this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	      var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
	      this._lBlock ^= t;
	      this._rBlock ^= t << offset;
	    }
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */


	    C.DES = BlockCipher._createHelper(DES);
	    /**
	     * Triple-DES block cipher algorithm.
	     */

	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	      _doReset: function _doReset() {
	        // Shortcuts
	        var key = this._key;
	        var keyWords = key.words; // Make sure the key length is valid (64, 128 or >= 192 bit)

	        if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
	          throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
	        } // Extend the key according to the keying options defined in 3DES standard


	        var key1 = keyWords.slice(0, 2);
	        var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
	        var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6); // Create DES instances

	        this._des1 = DES.createEncryptor(WordArray.create(key1));
	        this._des2 = DES.createEncryptor(WordArray.create(key2));
	        this._des3 = DES.createEncryptor(WordArray.create(key3));
	      },
	      encryptBlock: function encryptBlock(M, offset) {
	        this._des1.encryptBlock(M, offset);

	        this._des2.decryptBlock(M, offset);

	        this._des3.encryptBlock(M, offset);
	      },
	      decryptBlock: function decryptBlock(M, offset) {
	        this._des3.decryptBlock(M, offset);

	        this._des2.encryptBlock(M, offset);

	        this._des1.decryptBlock(M, offset);
	      },
	      keySize: 192 / 32,
	      ivSize: 64 / 32,
	      blockSize: 64 / 32
	    });
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */

	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	  })();

	  return CryptoJS.TripleDES;
	});
	});

	var rc4 = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, encBase64, md5, evpkdf, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;
	    /**
	     * RC4 stream cipher algorithm.
	     */

	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	      _doReset: function _doReset() {
	        // Shortcuts
	        var key = this._key;
	        var keyWords = key.words;
	        var keySigBytes = key.sigBytes; // Init sbox

	        var S = this._S = [];

	        for (var i = 0; i < 256; i++) {
	          S[i] = i;
	        } // Key setup


	        for (var i = 0, j = 0; i < 256; i++) {
	          var keyByteIndex = i % keySigBytes;
	          var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 0xff;
	          j = (j + S[i] + keyByte) % 256; // Swap

	          var t = S[i];
	          S[i] = S[j];
	          S[j] = t;
	        } // Counters


	        this._i = this._j = 0;
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        M[offset] ^= generateKeystreamWord.call(this);
	      },
	      keySize: 256 / 32,
	      ivSize: 0
	    });

	    function generateKeystreamWord() {
	      // Shortcuts
	      var S = this._S;
	      var i = this._i;
	      var j = this._j; // Generate keystream word

	      var keystreamWord = 0;

	      for (var n = 0; n < 4; n++) {
	        i = (i + 1) % 256;
	        j = (j + S[i]) % 256; // Swap

	        var t = S[i];
	        S[i] = S[j];
	        S[j] = t;
	        keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
	      } // Update counters


	      this._i = i;
	      this._j = j;
	      return keystreamWord;
	    }
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */


	    C.RC4 = StreamCipher._createHelper(RC4);
	    /**
	     * Modified RC4 stream cipher algorithm.
	     */

	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	      /**
	       * Configuration options.
	       *
	       * @property {number} drop The number of keystream words to drop. Default 192
	       */
	      cfg: RC4.cfg.extend({
	        drop: 192
	      }),
	      _doReset: function _doReset() {
	        RC4._doReset.call(this); // Drop


	        for (var i = this.cfg.drop; i > 0; i--) {
	          generateKeystreamWord.call(this);
	        }
	      }
	    });
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */

	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	  })();

	  return CryptoJS.RC4;
	});
	});

	var rabbit = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, encBase64, md5, evpkdf, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo; // Reusable objects

	    var S = [];
	    var C_ = [];
	    var G = [];
	    /**
	     * Rabbit stream cipher algorithm
	     */

	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	      _doReset: function _doReset() {
	        // Shortcuts
	        var K = this._key.words;
	        var iv = this.cfg.iv; // Swap endian

	        for (var i = 0; i < 4; i++) {
	          K[i] = (K[i] << 8 | K[i] >>> 24) & 0x00ff00ff | (K[i] << 24 | K[i] >>> 8) & 0xff00ff00;
	        } // Generate initial state values


	        var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16]; // Generate initial counter values

	        var C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff]; // Carry bit

	        this._b = 0; // Iterate the system four times

	        for (var i = 0; i < 4; i++) {
	          nextState.call(this);
	        } // Modify the counters


	        for (var i = 0; i < 8; i++) {
	          C[i] ^= X[i + 4 & 7];
	        } // IV setup


	        if (iv) {
	          // Shortcuts
	          var IV = iv.words;
	          var IV_0 = IV[0];
	          var IV_1 = IV[1]; // Generate four subvectors

	          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;
	          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;
	          var i1 = i0 >>> 16 | i2 & 0xffff0000;
	          var i3 = i2 << 16 | i0 & 0x0000ffff; // Modify counter values

	          C[0] ^= i0;
	          C[1] ^= i1;
	          C[2] ^= i2;
	          C[3] ^= i3;
	          C[4] ^= i0;
	          C[5] ^= i1;
	          C[6] ^= i2;
	          C[7] ^= i3; // Iterate the system four times

	          for (var i = 0; i < 4; i++) {
	            nextState.call(this);
	          }
	        }
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Shortcut
	        var X = this._X; // Iterate the system

	        nextState.call(this); // Generate four keystream words

	        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
	        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
	        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
	        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;

	        for (var i = 0; i < 4; i++) {
	          // Swap endian
	          S[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00; // Encrypt

	          M[offset + i] ^= S[i];
	        }
	      },
	      blockSize: 128 / 32,
	      ivSize: 64 / 32
	    });

	    function nextState() {
	      // Shortcuts
	      var X = this._X;
	      var C = this._C; // Save old counter values

	      for (var i = 0; i < 8; i++) {
	        C_[i] = C[i];
	      } // Calculate new counter values


	      C[0] = C[0] + 0x4d34d34d + this._b | 0;
	      C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
	      C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
	      C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
	      C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
	      C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
	      C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
	      C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
	      this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0; // Calculate the g-values

	      for (var i = 0; i < 8; i++) {
	        var gx = X[i] + C[i]; // Construct high and low argument for squaring

	        var ga = gx & 0xffff;
	        var gb = gx >>> 16; // Calculate high and low result of squaring

	        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
	        var gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0); // High XOR low

	        G[i] = gh ^ gl;
	      } // Calculate new state values


	      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
	      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
	      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
	      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
	      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
	      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
	      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
	      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
	    }
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */


	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	  })();

	  return CryptoJS.Rabbit;
	});
	});

	var rabbitLegacy = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, encBase64, md5, evpkdf, cipherCore);
	  } else {
	    // Global (browser)
	    factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  (function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo; // Reusable objects

	    var S = [];
	    var C_ = [];
	    var G = [];
	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */

	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	      _doReset: function _doReset() {
	        // Shortcuts
	        var K = this._key.words;
	        var iv = this.cfg.iv; // Generate initial state values

	        var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16]; // Generate initial counter values

	        var C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff]; // Carry bit

	        this._b = 0; // Iterate the system four times

	        for (var i = 0; i < 4; i++) {
	          nextState.call(this);
	        } // Modify the counters


	        for (var i = 0; i < 8; i++) {
	          C[i] ^= X[i + 4 & 7];
	        } // IV setup


	        if (iv) {
	          // Shortcuts
	          var IV = iv.words;
	          var IV_0 = IV[0];
	          var IV_1 = IV[1]; // Generate four subvectors

	          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;
	          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;
	          var i1 = i0 >>> 16 | i2 & 0xffff0000;
	          var i3 = i2 << 16 | i0 & 0x0000ffff; // Modify counter values

	          C[0] ^= i0;
	          C[1] ^= i1;
	          C[2] ^= i2;
	          C[3] ^= i3;
	          C[4] ^= i0;
	          C[5] ^= i1;
	          C[6] ^= i2;
	          C[7] ^= i3; // Iterate the system four times

	          for (var i = 0; i < 4; i++) {
	            nextState.call(this);
	          }
	        }
	      },
	      _doProcessBlock: function _doProcessBlock(M, offset) {
	        // Shortcut
	        var X = this._X; // Iterate the system

	        nextState.call(this); // Generate four keystream words

	        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
	        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
	        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
	        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;

	        for (var i = 0; i < 4; i++) {
	          // Swap endian
	          S[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00; // Encrypt

	          M[offset + i] ^= S[i];
	        }
	      },
	      blockSize: 128 / 32,
	      ivSize: 64 / 32
	    });

	    function nextState() {
	      // Shortcuts
	      var X = this._X;
	      var C = this._C; // Save old counter values

	      for (var i = 0; i < 8; i++) {
	        C_[i] = C[i];
	      } // Calculate new counter values


	      C[0] = C[0] + 0x4d34d34d + this._b | 0;
	      C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
	      C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
	      C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
	      C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
	      C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
	      C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
	      C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
	      this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0; // Calculate the g-values

	      for (var i = 0; i < 8; i++) {
	        var gx = X[i] + C[i]; // Construct high and low argument for squaring

	        var ga = gx & 0xffff;
	        var gb = gx >>> 16; // Calculate high and low result of squaring

	        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
	        var gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0); // High XOR low

	        G[i] = gh ^ gl;
	      } // Calculate new state values


	      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
	      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
	      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
	      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
	      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
	      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
	      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
	      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
	    }
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */


	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	  })();

	  return CryptoJS.RabbitLegacy;
	});
	});

	var cryptoJs = createCommonjsModule(function (module, exports) {
	var _typeof = _typeof_1["default"];

	(function (root, factory, undef) {
	  if ((_typeof(exports)) === "object") {
	    // CommonJS
	    module.exports = exports = factory(core, x64Core, libTypedarrays, encUtf16, encBase64, encBase64url, md5, sha1, sha256, sha224, sha512, sha384, sha3, ripemd160, hmac, pbkdf2, evpkdf, cipherCore, modeCfb, modeCtr, modeCtrGladman, modeOfb, modeEcb, padAnsix923, padIso10126, padIso97971, padZeropadding, padNopadding, formatHex, aes, tripledes, rc4, rabbit, rabbitLegacy);
	  } else {
	    // Global (browser)
	    root.CryptoJS = factory(root.CryptoJS);
	  }
	})(commonjsGlobal, function (CryptoJS) {
	  return CryptoJS;
	});
	});

	var bind = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);

	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    return fn.apply(thisArg, args);
	  };
	};

	var _typeof = _typeof_1["default"];




















	/*global toString:true*/
	// utils is a library of generic helper functions non-specific to axios


	var toString = Object.prototype.toString;
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */

	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */


	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */


	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
	}
	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */


	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}
	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */


	function isFormData(val) {
	  return typeof FormData !== 'undefined' && val instanceof FormData;
	}
	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */


	function isArrayBufferView(val) {
	  var result;

	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
	  }

	  return result;
	}
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */


	function isString(val) {
	  return typeof val === 'string';
	}
	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */


	function isNumber(val) {
	  return typeof val === 'number';
	}
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */


	function isObject(val) {
	  return val !== null && _typeof(val) === 'object';
	}
	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */


	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}
	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */


	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}
	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */


	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */


	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}
	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */


	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}
	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */


	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}
	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */


	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}
	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 */


	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
	    return false;
	  }

	  return typeof window !== 'undefined' && typeof document !== 'undefined';
	}
	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */


	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  } // Force an array if not already something iterable


	  if (_typeof(obj) !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}
	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */


	function
	  /* obj1, obj2, obj3, ... */
	merge() {
	  var result = {};

	  function assignValue(val, key) {
	    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }

	  return result;
	}
	/**
	 * Function equal to merge with the difference being that no reference
	 * to original objects is kept.
	 *
	 * @see merge
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */


	function
	  /* obj1, obj2, obj3, ... */
	deepMerge() {
	  var result = {};

	  function assignValue(val, key) {
	    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
	      result[key] = deepMerge(result[key], val);
	    } else if (_typeof(val) === 'object') {
	      result[key] = deepMerge({}, val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }

	  return result;
	}
	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */


	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	var utils = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  deepMerge: deepMerge,
	  extend: extend,
	  trim: trim
	};

	var Array$1 = global_1.Array;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var exec = functionUncurryThis(/./.exec);
	var charAt$1 = functionUncurryThis(''.charAt);
	var charCodeAt$1 = functionUncurryThis(''.charCodeAt);
	var replace = functionUncurryThis(''.replace);
	var numberToString = functionUncurryThis(1.0.toString);
	var tester = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var fix = function fix(match, offset, string) {
	  var prev = charAt$1(string, offset - 1);
	  var next = charAt$1(string, offset + 1);

	  if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
	    return "\\u" + numberToString(charCodeAt$1(match, 0), 16);
	  }

	  return match;
	};

	var FORCED = fails(function () {
	  return $stringify("\uDF06\uD834") !== "\"\\udf06\\ud834\"" || $stringify("\uDEAD") !== "\"\\udead\"";
	});

	if ($stringify) {
	  // `JSON.stringify` method
	  // https://tc39.es/ecma262/#sec-json.stringify
	  // https://github.com/tc39/proposal-well-formed-stringify
	  _export({
	    target: 'JSON',
	    stat: true,
	    forced: FORCED
	  }, {
	    // eslint-disable-next-line no-unused-vars -- required for `.length`
	    stringify: function stringify(it, replacer, space) {
	      for (var i = 0, l = arguments.length, args = Array$1(l); i < l; i++) {
	        args[i] = arguments[i];
	      }

	      var result = functionApply($stringify, null, args);
	      return typeof result == 'string' ? replace(result, tester, fix) : result;
	    }
	  });
	}

	function encode(val) {
	  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	}
	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */


	var buildURL = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;

	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];
	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }

	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });
	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    var hashmarkIndex = url.indexOf('#');

	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }

	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};

	function InterceptorManager() {
	  this.handlers = [];
	}
	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */


	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};
	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */


	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};
	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */


	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	var InterceptorManager_1 = InterceptorManager;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */


	var transformData = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });
	  return data;
	};

	var isCancel = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};

	var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

	var itoc$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	var ctoi = {};

	for (var index = 0; index < 66; index++) {
	  ctoi[itoc$1.charAt(index)] = index;
	}

	var base64Map = {
	  itoc: itoc$1,
	  ctoi: ctoi
	};

	var itoc = base64Map.itoc;

	var $btoa = getBuiltIn('btoa');
	var charAt = functionUncurryThis(''.charAt);
	var charCodeAt = functionUncurryThis(''.charCodeAt);
	var NO_ARG_RECEIVING_CHECK = !!$btoa && !fails(function () {
	  $btoa();
	}); // `btoa` method
	// https://html.spec.whatwg.org/multipage/webappapis.html#dom-btoa

	_export({
	  global: true,
	  enumerable: true,
	  forced: NO_ARG_RECEIVING_CHECK
	}, {
	  btoa: function btoa(data) {
	    validateArgumentsLength(arguments.length, 1);
	    if (NO_ARG_RECEIVING_CHECK) return $btoa(data);
	    var string = toString_1(data);
	    var output = '';
	    var position = 0;
	    var map = itoc;
	    var block, charCode;

	    while (charAt(string, position) || (map = '=', position % 1)) {
	      charCode = charCodeAt(string, position += 3 / 4);

	      if (charCode > 0xFF) {
	        throw new (getBuiltIn('DOMException'))('The string contains characters outside of the Latin1 range', 'InvalidCharacterError');
	      }

	      block = block << 8 | charCode;
	      output += charAt(map, 63 & block >> 8 - position % 1 * 8);
	    }

	    return output;
	  }
	});

	var tryNodeRequire = function (name) {
	  try {
	    // eslint-disable-next-line no-new-func -- safe
	    if (engineIsNode) return Function('return require("' + name + '")')();
	  } catch (error) {
	    /* empty */
	  }
	};

	var domExceptionConstants = {
	  IndexSizeError: {
	    s: 'INDEX_SIZE_ERR',
	    c: 1,
	    m: 1
	  },
	  DOMStringSizeError: {
	    s: 'DOMSTRING_SIZE_ERR',
	    c: 2,
	    m: 0
	  },
	  HierarchyRequestError: {
	    s: 'HIERARCHY_REQUEST_ERR',
	    c: 3,
	    m: 1
	  },
	  WrongDocumentError: {
	    s: 'WRONG_DOCUMENT_ERR',
	    c: 4,
	    m: 1
	  },
	  InvalidCharacterError: {
	    s: 'INVALID_CHARACTER_ERR',
	    c: 5,
	    m: 1
	  },
	  NoDataAllowedError: {
	    s: 'NO_DATA_ALLOWED_ERR',
	    c: 6,
	    m: 0
	  },
	  NoModificationAllowedError: {
	    s: 'NO_MODIFICATION_ALLOWED_ERR',
	    c: 7,
	    m: 1
	  },
	  NotFoundError: {
	    s: 'NOT_FOUND_ERR',
	    c: 8,
	    m: 1
	  },
	  NotSupportedError: {
	    s: 'NOT_SUPPORTED_ERR',
	    c: 9,
	    m: 1
	  },
	  InUseAttributeError: {
	    s: 'INUSE_ATTRIBUTE_ERR',
	    c: 10,
	    m: 1
	  },
	  InvalidStateError: {
	    s: 'INVALID_STATE_ERR',
	    c: 11,
	    m: 1
	  },
	  SyntaxError: {
	    s: 'SYNTAX_ERR',
	    c: 12,
	    m: 1
	  },
	  InvalidModificationError: {
	    s: 'INVALID_MODIFICATION_ERR',
	    c: 13,
	    m: 1
	  },
	  NamespaceError: {
	    s: 'NAMESPACE_ERR',
	    c: 14,
	    m: 1
	  },
	  InvalidAccessError: {
	    s: 'INVALID_ACCESS_ERR',
	    c: 15,
	    m: 1
	  },
	  ValidationError: {
	    s: 'VALIDATION_ERR',
	    c: 16,
	    m: 0
	  },
	  TypeMismatchError: {
	    s: 'TYPE_MISMATCH_ERR',
	    c: 17,
	    m: 1
	  },
	  SecurityError: {
	    s: 'SECURITY_ERR',
	    c: 18,
	    m: 1
	  },
	  NetworkError: {
	    s: 'NETWORK_ERR',
	    c: 19,
	    m: 1
	  },
	  AbortError: {
	    s: 'ABORT_ERR',
	    c: 20,
	    m: 1
	  },
	  URLMismatchError: {
	    s: 'URL_MISMATCH_ERR',
	    c: 21,
	    m: 1
	  },
	  QuotaExceededError: {
	    s: 'QUOTA_EXCEEDED_ERR',
	    c: 22,
	    m: 1
	  },
	  TimeoutError: {
	    s: 'TIMEOUT_ERR',
	    c: 23,
	    m: 1
	  },
	  InvalidNodeTypeError: {
	    s: 'INVALID_NODE_TYPE_ERR',
	    c: 24,
	    m: 1
	  },
	  DataCloneError: {
	    s: 'DATA_CLONE_ERR',
	    c: 25,
	    m: 1
	  }
	};
	domExceptionConstants.IndexSizeError;
	domExceptionConstants.DOMStringSizeError;
	domExceptionConstants.HierarchyRequestError;
	domExceptionConstants.WrongDocumentError;
	domExceptionConstants.InvalidCharacterError;
	domExceptionConstants.NoDataAllowedError;
	domExceptionConstants.NoModificationAllowedError;
	domExceptionConstants.NotFoundError;
	domExceptionConstants.NotSupportedError;
	domExceptionConstants.InUseAttributeError;
	domExceptionConstants.InvalidStateError;
	domExceptionConstants.InvalidModificationError;
	domExceptionConstants.NamespaceError;
	domExceptionConstants.InvalidAccessError;
	domExceptionConstants.ValidationError;
	domExceptionConstants.TypeMismatchError;
	domExceptionConstants.SecurityError;
	domExceptionConstants.NetworkError;
	domExceptionConstants.AbortError;
	domExceptionConstants.URLMismatchError;
	domExceptionConstants.QuotaExceededError;
	domExceptionConstants.TimeoutError;
	domExceptionConstants.InvalidNodeTypeError;
	domExceptionConstants.DataCloneError;

	var defineProperty$3 = objectDefineProperty.f;

	var defineProperties = objectDefineProperties.f;























	var DOM_EXCEPTION$2 = 'DOMException';
	var DATA_CLONE_ERR = 'DATA_CLONE_ERR';
	var Error$3 = getBuiltIn('Error'); // NodeJS < 17.0 does not expose `DOMException` to global

	var NativeDOMException$1 = getBuiltIn(DOM_EXCEPTION$2) || function () {
	  try {
	    // NodeJS < 15.0 does not expose `MessageChannel` to global
	    var MessageChannel = getBuiltIn('MessageChannel') || tryNodeRequire('worker_threads').MessageChannel; // eslint-disable-next-line es/no-weak-map, unicorn/require-post-message-target-origin -- safe

	    new MessageChannel().port1.postMessage(new WeakMap());
	  } catch (error) {
	    if (error.name == DATA_CLONE_ERR && error.code == 25) return error.constructor;
	  }
	}();

	var NativeDOMExceptionPrototype = NativeDOMException$1 && NativeDOMException$1.prototype;
	var ErrorPrototype = Error$3.prototype;
	var setInternalState = internalState.set;
	var getInternalState$2 = internalState.getterFor(DOM_EXCEPTION$2);
	var HAS_STACK = ('stack' in Error$3(DOM_EXCEPTION$2));

	var codeFor = function codeFor(name) {
	  return hasOwnProperty_1(domExceptionConstants, name) && domExceptionConstants[name].m ? domExceptionConstants[name].c : 0;
	};

	var $DOMException$1 = function DOMException() {
	  anInstance(this, DOMExceptionPrototype$1);
	  var argumentsLength = arguments.length;
	  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
	  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
	  var code = codeFor(name);
	  setInternalState(this, {
	    type: DOM_EXCEPTION$2,
	    name: name,
	    message: message,
	    code: code
	  });

	  if (!descriptors) {
	    this.name = name;
	    this.message = message;
	    this.code = code;
	  }

	  if (HAS_STACK) {
	    var error = Error$3(message);
	    error.name = DOM_EXCEPTION$2;
	    defineProperty$3(this, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
	  }
	};

	var DOMExceptionPrototype$1 = $DOMException$1.prototype = objectCreate(ErrorPrototype);

	var createGetterDescriptor = function createGetterDescriptor(get) {
	  return {
	    enumerable: true,
	    configurable: true,
	    get: get
	  };
	};

	var getterFor = function getterFor(key) {
	  return createGetterDescriptor(function () {
	    return getInternalState$2(this)[key];
	  });
	};

	if (descriptors) defineProperties(DOMExceptionPrototype$1, {
	  name: getterFor('name'),
	  message: getterFor('message'),
	  code: getterFor('code')
	});
	defineProperty$3(DOMExceptionPrototype$1, 'constructor', createPropertyDescriptor(1, $DOMException$1)); // FF36- DOMException is a function, but can't be constructed

	var INCORRECT_CONSTRUCTOR = fails(function () {
	  return !(new NativeDOMException$1() instanceof Error$3);
	}); // Safari 10.1 / Chrome 32- / IE8- DOMException.prototype.toString bugs

	var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function () {
	  return ErrorPrototype.toString !== errorToString || String(new NativeDOMException$1(1, 2)) !== '2: 1';
	}); // Deno 1.6.3- DOMException.prototype.code just missed

	var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function () {
	  return new NativeDOMException$1(1, 'DataCloneError').code !== 25;
	}); // Deno 1.6.3- DOMException constants just missed

	INCORRECT_CONSTRUCTOR || NativeDOMException$1[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
	var FORCED_CONSTRUCTOR$1 = INCORRECT_CONSTRUCTOR; // `DOMException` constructor
	// https://webidl.spec.whatwg.org/#idl-DOMException

	_export({
	  global: true,
	  forced: FORCED_CONSTRUCTOR$1
	}, {
	  DOMException: FORCED_CONSTRUCTOR$1 ? $DOMException$1 : NativeDOMException$1
	});
	var PolyfilledDOMException$1 = getBuiltIn(DOM_EXCEPTION$2);
	var PolyfilledDOMExceptionPrototype$1 = PolyfilledDOMException$1.prototype;

	if (INCORRECT_TO_STRING && (NativeDOMException$1 === PolyfilledDOMException$1)) {
	  redefine(PolyfilledDOMExceptionPrototype$1, 'toString', errorToString);
	}

	if (INCORRECT_CODE && descriptors && NativeDOMException$1 === PolyfilledDOMException$1) {
	  defineProperty$3(PolyfilledDOMExceptionPrototype$1, 'code', createGetterDescriptor(function () {
	    return codeFor(anObject(this).name);
	  }));
	}

	for (var key$1 in domExceptionConstants) {
	  if (hasOwnProperty_1(domExceptionConstants, key$1)) {
	    var constant$1 = domExceptionConstants[key$1];
	    var constantName$1 = constant$1.s;
	    var descriptor = createPropertyDescriptor(6, constant$1.c);

	    if (!hasOwnProperty_1(PolyfilledDOMException$1, constantName$1)) {
	      defineProperty$3(PolyfilledDOMException$1, constantName$1, descriptor);
	    }

	    if (!hasOwnProperty_1(PolyfilledDOMExceptionPrototype$1, constantName$1)) {
	      defineProperty$3(PolyfilledDOMExceptionPrototype$1, constantName$1, descriptor);
	    }
	  }
	}

	var defineProperty$2 = objectDefineProperty.f;















	var DOM_EXCEPTION$1 = 'DOMException';
	var Error$2 = getBuiltIn('Error');
	var NativeDOMException = getBuiltIn(DOM_EXCEPTION$1);

	var $DOMException = function DOMException() {
	  anInstance(this, DOMExceptionPrototype);
	  var argumentsLength = arguments.length;
	  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
	  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
	  var that = new NativeDOMException(message, name);
	  var error = Error$2(message);
	  error.name = DOM_EXCEPTION$1;
	  defineProperty$2(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
	  inheritIfRequired(that, this, $DOMException);
	  return that;
	};

	var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
	var ERROR_HAS_STACK = ('stack' in Error$2(DOM_EXCEPTION$1));
	var DOM_EXCEPTION_HAS_STACK = ('stack' in new NativeDOMException(1, 2));
	var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !DOM_EXCEPTION_HAS_STACK; // `DOMException` constructor patch for `.stack` where it's required
	// https://webidl.spec.whatwg.org/#es-DOMException-specialness

	_export({
	  global: true,
	  forced: FORCED_CONSTRUCTOR
	}, {
	  // TODO: fix export logic
	  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
	});
	var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION$1);
	var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;

	if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
	  {
	    defineProperty$2(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));
	  }

	  for (var key in domExceptionConstants) {
	    if (hasOwnProperty_1(domExceptionConstants, key)) {
	      var constant = domExceptionConstants[key];
	      var constantName = constant.s;

	      if (!hasOwnProperty_1(PolyfilledDOMException, constantName)) {
	        defineProperty$2(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
	      }
	    }
	  }
	}

	var DOM_EXCEPTION = 'DOMException';
	setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */











	var enhanceError = function enhanceError(error, config, code, request, response) {
	  error.config = config;

	  if (code) {
	    error.code = code;
	  }

	  error.request = request;
	  error.response = response;
	  error.isAxiosError = true;

	  error.toJSON = function () {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code
	    };
	  };

	  return error;
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */


	var createError = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, request, response);
	};

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */


	var settle = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;

	  if (!validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
	  }
	};

	var DELEGATES_TO_EXEC = function () {
	  var execCalled = false;
	  var re = /[ac]/;

	  re.exec = function () {
	    execCalled = true;
	    return /./.exec.apply(this, arguments);
	  };

	  return re.test('abc') === true && execCalled;
	}();

	var Error$1 = global_1.Error;
	var un$Test = functionUncurryThis(/./.test); // `RegExp.prototype.test` method
	// https://tc39.es/ecma262/#sec-regexp.prototype.test

	_export({
	  target: 'RegExp',
	  proto: true,
	  forced: !DELEGATES_TO_EXEC
	}, {
	  test: function test(str) {
	    var exec = this.exec;
	    if (!isCallable(exec)) return un$Test(this, str);
	    var result = functionCall(exec, this, str);

	    if (result !== null && !isObject$1(result)) {
	      throw new Error$1('RegExp exec method returned something other than an Object or null');
	    }

	    return !!result;
	  }
	});

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */





	var isAbsoluteURL = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */





	var combineURLs = function combineURLs(baseURL, relativeURL) {
	  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
	};

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 * @returns {string} The combined full path
	 */


	var buildFullPath = function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }

	  return requestedURL;
	};

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers


	var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */

	var parseHeaders = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) {
	    return parsed;
	  }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }

	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });
	  return parsed;
	};

	var isURLSameOrigin = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
	// whether the request URL is of the same origin as current location.
	function standardBrowserEnv() {
	  var msie = /(msie|trident)/i.test(navigator.userAgent);
	  var urlParsingNode = document.createElement('a');
	  var originURL;
	  /**
	  * Parse a URL to discover it's components
	  *
	  * @param {String} url The URL to be parsed
	  * @returns {Object}
	  */

	  function resolveURL(url) {
	    var href = url;

	    if (msie) {
	      // IE needs attribute set twice to normalize properties
	      urlParsingNode.setAttribute('href', href);
	      href = urlParsingNode.href;
	    }

	    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

	    return {
	      href: urlParsingNode.href,
	      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	      host: urlParsingNode.host,
	      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	      hostname: urlParsingNode.hostname,
	      port: urlParsingNode.port,
	      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
	    };
	  }

	  originURL = resolveURL(window.location.href);
	  /**
	  * Determine if a URL shares the same origin as the current location
	  *
	  * @param {String} requestURL The URL to test
	  * @returns {boolean} True if URL shares the same origin, otherwise false
	  */

	  return function isURLSameOrigin(requestURL) {
	    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
	    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
	  };
	}() : // Non standard browser envs (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return function isURLSameOrigin() {
	    return true;
	  };
	}();

	// `Date.prototype.toGMTString` method
	// https://tc39.es/ecma262/#sec-date.prototype.togmtstring


	_export({
	  target: 'Date',
	  proto: true
	}, {
	  toGMTString: Date.prototype.toUTCString
	});

	var defineProperty$1 = objectDefineProperty.f;

	var getInternalState$1 = internalState.get;

	var RegExpPrototype$1 = RegExp.prototype;
	var TypeError$2 = global_1.TypeError; // `RegExp.prototype.dotAll` getter
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.dotall

	if (descriptors && regexpUnsupportedDotAll) {
	  defineProperty$1(RegExpPrototype$1, 'dotAll', {
	    configurable: true,
	    get: function get() {
	      if (this === RegExpPrototype$1) return undefined; // We can't use InternalStateModule.getterFor because
	      // we don't add metadata for regexps created by a literal.

	      if (classofRaw(this) === 'RegExp') {
	        return !!getInternalState$1(this).dotAll;
	      }

	      throw TypeError$2('Incompatible receiver, RegExp required');
	    }
	  });
	}

	var MISSED_STICKY = regexpStickyHelpers.MISSED_STICKY;



	var defineProperty = objectDefineProperty.f;

	var getInternalState = internalState.get;

	var RegExpPrototype = RegExp.prototype;
	var TypeError$1 = global_1.TypeError; // `RegExp.prototype.sticky` getter
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky

	if (descriptors && MISSED_STICKY) {
	  defineProperty(RegExpPrototype, 'sticky', {
	    configurable: true,
	    get: function get() {
	      if (this === RegExpPrototype) return undefined; // We can't use InternalStateModule.getterFor because
	      // we don't add metadata for regexps created by a literal.

	      if (classofRaw(this) === 'RegExp') {
	        return !!getInternalState(this).sticky;
	      }

	      throw TypeError$1('Incompatible receiver, RegExp required');
	    }
	  });
	}

	var cookies = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
	function standardBrowserEnv() {
	  return {
	    write: function write(name, value, expires, path, domain, secure) {
	      var cookie = [];
	      cookie.push(name + '=' + encodeURIComponent(value));

	      if (utils.isNumber(expires)) {
	        cookie.push('expires=' + new Date(expires).toGMTString());
	      }

	      if (utils.isString(path)) {
	        cookie.push('path=' + path);
	      }

	      if (utils.isString(domain)) {
	        cookie.push('domain=' + domain);
	      }

	      if (secure === true) {
	        cookie.push('secure');
	      }

	      document.cookie = cookie.join('; ');
	    },
	    read: function read(name) {
	      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return match ? decodeURIComponent(match[3]) : null;
	    },
	    remove: function remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  };
	}() : // Non standard browser env (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return {
	    write: function write() {},
	    read: function read() {
	      return null;
	    },
	    remove: function remove() {}
	  };
	}();

	var xhr = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest(); // HTTP basic authentication

	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    var fullPath = buildFullPath(config.baseURL, config.url);
	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

	    request.timeout = config.timeout; // Listen for ready state

	    request.onreadystatechange = function handleLoad() {
	      if (!request || request.readyState !== 4) {
	        return;
	      } // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request


	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      } // Prepare the response


	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };
	      settle(resolve, reject, response); // Clean up request

	      request = null;
	    }; // Handle browser request cancellation (as opposed to a manual cancellation)


	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

	      request = null;
	    }; // Handle low level network errors


	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config, null, request)); // Clean up request

	      request = null;
	    }; // Handle timeout


	    request.ontimeout = function handleTimeout() {
	      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }

	      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

	      request = null;
	    }; // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.


	    if (utils.isStandardBrowserEnv()) {
	      var cookies$1 = cookies; // Add xsrf header


	      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies$1.read(config.xsrfCookieName) : undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    } // Add headers to the request


	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    } // Add withCredentials to request if needed


	    if (!utils.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    } // Add responseType to request if needed


	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
	        if (config.responseType !== 'json') {
	          throw e;
	        }
	      }
	    } // Handle progress if needed


	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    } // Not all browsers support upload events


	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel); // Clean up request

	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    } // Send the request


	    request.send(requestData);
	  });
	};

	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;

	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = xhr;
	  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
	    // For node use HTTP adapter
	    adapter = xhr;
	  }

	  return adapter;
	}

	var defaults = {
	  adapter: getDefaultAdapter(),
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Accept');
	    normalizeHeaderName(headers, 'Content-Type');

	    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
	      return data;
	    }

	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }

	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }

	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }

	    return data;
	  }],
	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      try {
	        data = JSON.parse(data);
	      } catch (e) {
	        /* Ignore */
	      }
	    }

	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	  maxContentLength: -1,
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};
	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults.headers[method] = {};
	});
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});
	var defaults_1 = defaults;

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */


	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}
	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */


	var dispatchRequest = function dispatchRequest(config) {
	  throwIfCancellationRequested(config); // Ensure headers exist

	  config.headers = config.headers || {}; // Transform request data

	  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

	  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
	  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
	    delete config.headers[method];
	  });
	  var adapter = config.adapter || defaults_1.adapter;
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config); // Transform response data

	    response.data = transformData(response.data, response.headers, config.transformResponse);
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config); // Transform response data

	      if (reason && reason.response) {
	        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
	      }
	    }

	    return Promise.reject(reason);
	  });
	};

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 * @returns {Object} New object resulting from merging config2 to config1
	 */


	var mergeConfig = function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  var config = {};
	  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
	  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
	  var defaultToConfig2Keys = ['baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath'];
	  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    }
	  });
	  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
	    if (utils.isObject(config2[prop])) {
	      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
	    } else if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (utils.isObject(config1[prop])) {
	      config[prop] = utils.deepMerge(config1[prop]);
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });
	  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });
	  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys);
	  var otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key) {
	    return axiosKeys.indexOf(key) === -1;
	  });
	  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });
	  return config;
	};

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */


	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager_1(),
	    response: new InterceptorManager_1()
	  };
	}
	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */


	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = arguments[1] || {};
	    config.url = arguments[0];
	  } else {
	    config = config || {};
	  }

	  config = mergeConfig(this.defaults, config); // Set config.method

	  if (config.method) {
	    config.method = config.method.toLowerCase();
	  } else if (this.defaults.method) {
	    config.method = this.defaults.method.toLowerCase();
	  } else {
	    config.method = 'get';
	  } // Hook up interceptors middleware


	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	Axios.prototype.getUri = function getUri(config) {
	  config = mergeConfig(this.defaults, config);
	  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
	}; // Provide aliases for supported request methods


	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});
	var Axios_1 = Axios;

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */









	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;
	var Cancel_1 = Cancel;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */


	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });
	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel_1(message);
	    resolvePromise(token.reason);
	  });
	}
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */


	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};
	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */


	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	var CancelToken_1 = CancelToken;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */

	var spread = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

	var axios_1 = createCommonjsModule(function (module) {
















	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */


	function createInstance(defaultConfig) {
	  var context = new Axios_1(defaultConfig);
	  var instance = bind(Axios_1.prototype.request, context); // Copy axios.prototype to instance

	  utils.extend(instance, Axios_1.prototype, context); // Copy context to instance

	  utils.extend(instance, context);
	  return instance;
	} // Create the default instance to be exported


	var axios = createInstance(defaults_1); // Expose Axios class to allow class inheritance

	axios.Axios = Axios_1; // Factory for creating new instances

	axios.create = function create(instanceConfig) {
	  return createInstance(mergeConfig(axios.defaults, instanceConfig));
	}; // Expose Cancel & CancelToken


	axios.Cancel = Cancel_1;
	axios.CancelToken = CancelToken_1;
	axios.isCancel = isCancel; // Expose all/spread

	axios.all = function all(promises) {
	  return Promise.all(promises);
	};

	axios.spread = spread;
	module.exports = axios; // Allow use of default import syntax in TypeScript

	module.exports["default"] = axios;
	});

	var axios = axios_1;

	/**
	 * 获取设备类型
	 */

	function getDevice() {
	  var platform = "HP-UX, Linux i686, Linux armv7l, Mac68K, MacPPC, MacIntel, SunOS, Win16, Win32, WinCE";

	  if (platform.indexOf(navigator.platform) > -1) {
	    return 'pc';
	  } else {
	    return 'mobile';
	  }
	}

	var instance = axios.create();
	instance.defaults = {
	  // baseURL: BASE_URL,
	  headers: {
	    'Content-Type': 'application/json',
	    'st-origin': window.location.href || '',
	    'st-device': getDevice(),
	    'st-version': 'v1.4.4'
	  },
	  timeout: 120000 // 毫秒

	};
	instance.interceptors.request.use(function (config) {
	  config.data = JSON.stringify(config.data);
	  return config;
	}, function (error) {
	  return Promise.reject(new Error('[ST Error(请求参数错误)]:' + error));
	});
	instance.interceptors.response.use(function (response) {
	  var res = response.data;

	  if (res) {
	    if (res.code === 2909) ; else if (res.code === 2910) ; else {
	      return res;
	    }
	  }

	  return response;
	}, function (error) {
	  return Promise.reject(new Error('[ST Error(响应错误)]:' + error));
	});
	/**
	 * 合并axios实例的自定义和默认配置
	 * @private
	 * @param {AxiosRequestConfig} [config] - 请求配置信息 
	 * @param {AxiosRequestConfig} defaultConfig - 默认配置
	 * @return {AxiosRequestConfig} axios 请求配置信息
	 */

	function getMergedConfig(config, defaultConfig) {
	  if (config) {
	    var headers = config.headers;

	    if (headers) {
	      var _headers = defaultConfig.headers;
	      !headers['Content-Type'] && (config['Content-Type'] = _headers['Content-Type']);
	      !headers['st-origin'] && (config['st-origin'] = _headers['st-origin']);
	      !headers['st-device'] && (config['st-device'] = _headers['Cst-device']);
	      !headers['st-version'] && (config['st-version'] = _headers['Cst-version']);
	    } else {
	      config['headers'] = defaultConfig.headers;
	    }

	    !config['baseURL'] && (config['baseURL'] = defaultConfig.baseURL);
	    !config['timeout'] && (config['timeout'] = defaultConfig.timeout || 0);
	    return config;
	  }

	  return defaultConfig;
	}
	/**
	 * http请求封装
	 * @mixin
	 */


	var http = {
	  /**
	   * get 请求
	   * @param {string} url - 请求url地址
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {Promise}
	   */
	  get: function get(url, config) {
	    return instance.get(url, getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * post 请求
	   * @param {string} url - 请求url地址
	   * @param {Object} [data] - 请求传参
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {Promise}
	   */
	  post: function post(url, data, config) {
	    return instance.post(url, data, getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * request 请求
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {Promise}
	   */
	  request: function request(config) {
	    return instance.request(getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * delete 请求
	   * @param {string} url - 请求url地址
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {Promise}
	   */
	  "delete": function _delete(url, config) {
	    return instance["delete"](url, getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * head 请求
	   * @param {string} url - 请求url地址
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {Promise}
	   */
	  head: function head(url, config) {
	    return instance.head(url, getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * options 请求
	   * @param {string} url - 请求url地址
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {*}
	   */
	  options: function options(url, config) {
	    return instance.options(url, getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * put 请求
	   * @param {string} url - 请求url地址
	   * @param {Object} [data] - 请求传参
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {Promise}
	   */
	  put: function put(url, data, config) {
	    return instance.put(url, data, getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * put 请求
	   * @param {string} url - 请求url地址
	   * @param {Object} [data] - 请求传参
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {Promise}
	   */
	  patch: function patch(url, data, config) {
	    return instance.patch(url, data, getMergedConfig(config, instance.defaults));
	  },

	  /**
	   * 获取资源文件路径
	   * @param {AxiosRequestConfig} [config] - 请求配置信息
	   * @return {string}
	   */
	  getUri: function getUri(config) {
	    return instance.getUri(getMergedConfig(config, instance.defaults));
	  },
	  setHeaders: function setHeaders(headers) {
	    for (var key in headers) {
	      instance.defaults.headers[key] = headers[key];
	    }
	  }
	};

	var rrwebRecord = function () {

	  var _assign = function __assign() {
	    _assign = Object.assign || function __assign(t) {
	      for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];

	        for (var p in s) {
	          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	      }

	      return t;
	    };

	    return _assign.apply(this, arguments);
	  };

	  function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator,
	        m = s && o[s],
	        i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	      next: function next() {
	        if (o && i >= o.length) o = void 0;
	        return {
	          value: o && o[i++],
	          done: !o
	        };
	      }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	  }

	  function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o),
	        r,
	        ar = [],
	        e;

	    try {
	      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
	        ar.push(r.value);
	      }
	    } catch (error) {
	      e = {
	        error: error
	      };
	    } finally {
	      try {
	        if (r && !r.done && (m = i["return"])) m.call(i);
	      } finally {
	        if (e) throw e.error;
	      }
	    }

	    return ar;
	  }

	  function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++) {
	      ar = ar.concat(__read(arguments[i]));
	    }

	    return ar;
	  }

	  var NodeType;

	  (function (NodeType) {
	    NodeType[NodeType["Document"] = 0] = "Document";
	    NodeType[NodeType["DocumentType"] = 1] = "DocumentType";
	    NodeType[NodeType["Element"] = 2] = "Element";
	    NodeType[NodeType["Text"] = 3] = "Text";
	    NodeType[NodeType["CDATA"] = 4] = "CDATA";
	    NodeType[NodeType["Comment"] = 5] = "Comment";
	  })(NodeType || (NodeType = {}));

	  var _id = 1;
	  var tagNameRegex = RegExp('[^a-z1-6-_]');

	  function genId() {
	    return _id++;
	  }

	  function getValidTagName(tagName) {
	    var processedTagName = tagName.toLowerCase().trim();

	    if (tagNameRegex.test(processedTagName)) {
	      return 'div';
	    }

	    return processedTagName;
	  }

	  function getCssRulesString(s) {
	    try {
	      var rules = s.rules || s.cssRules;
	      return rules ? Array.from(rules).reduce(function (prev, cur) {
	        return prev + getCssRuleString(cur);
	      }, '') : null;
	    } catch (error) {
	      return null;
	    }
	  }

	  function getCssRuleString(rule) {
	    return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText;
	  }

	  function isCSSImportRule(rule) {
	    return 'styleSheet' in rule;
	  }

	  function extractOrigin(url) {
	    var origin;

	    if (url.indexOf('//') > -1) {
	      origin = url.split('/').slice(0, 3).join('/');
	    } else {
	      origin = url.split('/')[0];
	    }

	    origin = origin.split('?')[0];
	    return origin;
	  }

	  var URL_IN_CSS_REF = /url\((?:'([^']*)'|"([^"]*)"|([^)]*))\)/gm;
	  var RELATIVE_PATH = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/).*/;
	  var DATA_URI = /^(data:)([\w\/\+\-]+);(charset=[\w-]+|base64).*,(.*)/i;

	  function absoluteToStylesheet(cssText, href) {
	    return (cssText || '').replace(URL_IN_CSS_REF, function (origin, path1, path2, path3) {
	      var filePath = path1 || path2 || path3;

	      if (!filePath) {
	        return origin;
	      }

	      if (!RELATIVE_PATH.test(filePath)) {
	        return "url('" + filePath + "')";
	      }

	      if (DATA_URI.test(filePath)) {
	        return "url(" + filePath + ")";
	      }

	      if (filePath[0] === '/') {
	        return "url('" + (extractOrigin(href) + filePath) + "')";
	      }

	      var stack = href.split('/');
	      var parts = filePath.split('/');
	      stack.pop();

	      for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
	        var part = parts_1[_i];

	        if (part === '.') {
	          continue;
	        } else if (part === '..') {
	          stack.pop();
	        } else {
	          stack.push(part);
	        }
	      }

	      return "url('" + stack.join('/') + "')";
	    });
	  }

	  function getAbsoluteSrcsetString(doc, attributeValue) {
	    if (attributeValue.trim() === '') {
	      return attributeValue;
	    }

	    var srcsetValues = attributeValue.split(',');
	    var resultingSrcsetString = srcsetValues.map(function (srcItem) {
	      var trimmedSrcItem = srcItem.trimLeft().trimRight();
	      var urlAndSize = trimmedSrcItem.split(' ');

	      if (urlAndSize.length === 2) {
	        var absUrl = absoluteToDoc(doc, urlAndSize[0]);
	        return absUrl + " " + urlAndSize[1];
	      } else if (urlAndSize.length === 1) {
	        var absUrl = absoluteToDoc(doc, urlAndSize[0]);
	        return "" + absUrl;
	      }

	      return '';
	    }).join(', ');
	    return resultingSrcsetString;
	  }

	  function absoluteToDoc(doc, attributeValue) {
	    if (!attributeValue || attributeValue.trim() === '') {
	      return attributeValue;
	    }

	    var a = doc.createElement('a');
	    a.href = attributeValue;
	    return a.href;
	  }

	  function isSVGElement(el) {
	    return el.tagName === 'svg' || el instanceof SVGElement;
	  }

	  function transformAttribute(doc, name, value) {
	    if (name === 'src' || name === 'href' && value) {
	      return absoluteToDoc(doc, value);
	    } else if (name === 'srcset' && value) {
	      return getAbsoluteSrcsetString(doc, value);
	    } else if (name === 'style' && value) {
	      return absoluteToStylesheet(value, location.href);
	    } else {
	      return value;
	    }
	  }

	  function serializeNode(n, doc, blockClass, inlineStylesheet, maskInputOptions, recordCanvas) {
	    if (maskInputOptions === void 0) {
	      maskInputOptions = {};
	    }

	    switch (n.nodeType) {
	      case n.DOCUMENT_NODE:
	        return {
	          type: NodeType.Document,
	          childNodes: []
	        };

	      case n.DOCUMENT_TYPE_NODE:
	        return {
	          type: NodeType.DocumentType,
	          name: n.name,
	          publicId: n.publicId,
	          systemId: n.systemId
	        };

	      case n.ELEMENT_NODE:
	        var needBlock_1 = false;

	        if (typeof blockClass === 'string') {
	          needBlock_1 = n.classList.contains(blockClass);
	        } else {
	          n.classList.forEach(function (className) {
	            if (blockClass.test(className)) {
	              needBlock_1 = true;
	            }
	          });
	        }

	        var tagName = getValidTagName(n.tagName);
	        var attributes_1 = {};

	        for (var _i = 0, _a = Array.from(n.attributes); _i < _a.length; _i++) {
	          var _b = _a[_i],
	              name = _b.name,
	              value = _b.value;
	          attributes_1[name] = transformAttribute(doc, name, value);
	        }

	        if (tagName === 'link' && inlineStylesheet) {
	          var stylesheet = Array.from(doc.styleSheets).find(function (s) {
	            return s.href === n.href;
	          });
	          var cssText = getCssRulesString(stylesheet);

	          if (cssText) {
	            delete attributes_1.rel;
	            delete attributes_1.href;
	            attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);
	          }
	        }

	        if (tagName === 'style' && n.sheet && !(n.innerText || n.textContent || '').trim().length) {
	          var cssText = getCssRulesString(n.sheet);

	          if (cssText) {
	            attributes_1._cssText = absoluteToStylesheet(cssText, location.href);
	          }
	        }

	        if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {
	          var value = n.value;

	          if (attributes_1.type !== 'radio' && attributes_1.type !== 'checkbox' && attributes_1.type !== 'submit' && attributes_1.type !== 'button' && value) {
	            attributes_1.value = maskInputOptions[attributes_1.type] || maskInputOptions[tagName] ? '*'.repeat(value.length) : value;
	          } else if (n.checked) {
	            attributes_1.checked = n.checked;
	          }
	        }

	        if (tagName === 'option') {
	          var selectValue = n.parentElement;

	          if (attributes_1.value === selectValue.value) {
	            attributes_1.selected = n.selected;
	          }
	        }

	        if (tagName === 'canvas' && recordCanvas) {
	          attributes_1.rr_dataURL = n.toDataURL();
	        }

	        if (tagName === 'audio' || tagName === 'video') {
	          attributes_1.rr_mediaState = n.paused ? 'paused' : 'played';
	        }

	        if (n.scrollLeft) {
	          attributes_1.rr_scrollLeft = n.scrollLeft;
	        }

	        if (n.scrollTop) {
	          attributes_1.rr_scrollTop = n.scrollTop;
	        }

	        if (needBlock_1) {
	          var _c = n.getBoundingClientRect(),
	              width = _c.width,
	              height = _c.height;

	          attributes_1.rr_width = width + "px";
	          attributes_1.rr_height = height + "px";
	        }

	        return {
	          type: NodeType.Element,
	          tagName: tagName,
	          attributes: attributes_1,
	          childNodes: [],
	          isSVG: isSVGElement(n) || undefined,
	          needBlock: needBlock_1
	        };

	      case n.TEXT_NODE:
	        var parentTagName = n.parentNode && n.parentNode.tagName;
	        var textContent = n.textContent;
	        var isStyle = parentTagName === 'STYLE' ? true : undefined;

	        if (isStyle && textContent) {
	          textContent = absoluteToStylesheet(textContent, location.href);
	        }

	        if (parentTagName === 'SCRIPT') {
	          textContent = ''; // 宁波银行出现这里，不显示占位符
	          // textContent = 'SCRIPT_PLACEHOLDER';
	        }

	        return {
	          type: NodeType.Text,
	          textContent: textContent || '',
	          isStyle: isStyle
	        };

	      case n.CDATA_SECTION_NODE:
	        return {
	          type: NodeType.CDATA,
	          textContent: ''
	        };

	      case n.COMMENT_NODE:
	        return {
	          type: NodeType.Comment,
	          textContent: n.textContent || ''
	        };

	      default:
	        return false;
	    }
	  }

	  function serializeNodeWithId(n, doc, map, blockClass, skipChild, inlineStylesheet, maskInputOptions, recordCanvas) {
	    if (skipChild === void 0) {
	      skipChild = false;
	    }

	    if (inlineStylesheet === void 0) {
	      inlineStylesheet = true;
	    }

	    var _serializedNode = serializeNode(n, doc, blockClass, inlineStylesheet, maskInputOptions, recordCanvas || false);

	    if (!_serializedNode) {
	      console.warn(n, 'not serialized');
	      return null;
	    }

	    var id;

	    if ('__sn' in n) {
	      id = n.__sn.id;
	    } else {
	      id = genId();
	    }

	    var serializedNode = Object.assign(_serializedNode, {
	      id: id
	    });
	    n.__sn = serializedNode;
	    map[id] = n;
	    var recordChild = !skipChild;

	    if (serializedNode.type === NodeType.Element) {
	      recordChild = recordChild && !serializedNode.needBlock;
	      delete serializedNode.needBlock;
	    }

	    if ((serializedNode.type === NodeType.Document || serializedNode.type === NodeType.Element) && recordChild) {
	      for (var _i = 0, _a = Array.from(n.childNodes); _i < _a.length; _i++) {
	        var childN = _a[_i];
	        var serializedChildNode = serializeNodeWithId(childN, doc, map, blockClass, skipChild, inlineStylesheet, maskInputOptions, recordCanvas);

	        if (serializedChildNode) {
	          serializedNode.childNodes.push(serializedChildNode);
	        }
	      }
	    }

	    return serializedNode;
	  }

	  function snapshot(n, blockClass, inlineStylesheet, maskAllInputsOrOptions, recordCanvas) {
	    if (blockClass === void 0) {
	      blockClass = 'rr-block';
	    }

	    if (inlineStylesheet === void 0) {
	      inlineStylesheet = true;
	    }

	    var idNodeMap = {};
	    var maskInputOptions = maskAllInputsOrOptions === true ? {
	      color: true,
	      date: true,
	      'datetime-local': true,
	      email: true,
	      month: true,
	      number: true,
	      range: true,
	      search: true,
	      tel: true,
	      text: true,
	      time: true,
	      url: true,
	      week: true,
	      textarea: true,
	      select: true
	    } : maskAllInputsOrOptions === false ? {} : maskAllInputsOrOptions;
	    return [serializeNodeWithId(n, n, idNodeMap, blockClass, false, inlineStylesheet, maskInputOptions, recordCanvas), idNodeMap];
	  }

	  var EventType;

	  (function (EventType) {
	    EventType[EventType["DomContentLoaded"] = 0] = "DomContentLoaded";
	    EventType[EventType["Load"] = 1] = "Load";
	    EventType[EventType["FullSnapshot"] = 2] = "FullSnapshot";
	    EventType[EventType["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
	    EventType[EventType["Meta"] = 4] = "Meta";
	    EventType[EventType["Custom"] = 5] = "Custom";
	  })(EventType || (EventType = {}));

	  var IncrementalSource;

	  (function (IncrementalSource) {
	    IncrementalSource[IncrementalSource["Mutation"] = 0] = "Mutation";
	    IncrementalSource[IncrementalSource["MouseMove"] = 1] = "MouseMove";
	    IncrementalSource[IncrementalSource["MouseInteraction"] = 2] = "MouseInteraction";
	    IncrementalSource[IncrementalSource["Scroll"] = 3] = "Scroll";
	    IncrementalSource[IncrementalSource["ViewportResize"] = 4] = "ViewportResize";
	    IncrementalSource[IncrementalSource["Input"] = 5] = "Input";
	    IncrementalSource[IncrementalSource["TouchMove"] = 6] = "TouchMove";
	    IncrementalSource[IncrementalSource["MediaInteraction"] = 7] = "MediaInteraction";
	    IncrementalSource[IncrementalSource["StyleSheetRule"] = 8] = "StyleSheetRule";
	    IncrementalSource[IncrementalSource["CanvasMutation"] = 9] = "CanvasMutation";
	    IncrementalSource[IncrementalSource["Font"] = 10] = "Font";
	  })(IncrementalSource || (IncrementalSource = {}));

	  var MouseInteractions;

	  (function (MouseInteractions) {
	    MouseInteractions[MouseInteractions["MouseUp"] = 0] = "MouseUp";
	    MouseInteractions[MouseInteractions["MouseDown"] = 1] = "MouseDown";
	    MouseInteractions[MouseInteractions["Click"] = 2] = "Click";
	    MouseInteractions[MouseInteractions["ContextMenu"] = 3] = "ContextMenu";
	    MouseInteractions[MouseInteractions["DblClick"] = 4] = "DblClick";
	    MouseInteractions[MouseInteractions["Focus"] = 5] = "Focus";
	    MouseInteractions[MouseInteractions["Blur"] = 6] = "Blur";
	    MouseInteractions[MouseInteractions["TouchStart"] = 7] = "TouchStart";
	    MouseInteractions[MouseInteractions["TouchMove_Departed"] = 8] = "TouchMove_Departed";
	    MouseInteractions[MouseInteractions["TouchEnd"] = 9] = "TouchEnd";
	  })(MouseInteractions || (MouseInteractions = {}));

	  var MediaInteractions;

	  (function (MediaInteractions) {
	    MediaInteractions[MediaInteractions["Play"] = 0] = "Play";
	    MediaInteractions[MediaInteractions["Pause"] = 1] = "Pause";
	  })(MediaInteractions || (MediaInteractions = {}));

	  var ReplayerEvents;

	  (function (ReplayerEvents) {
	    ReplayerEvents["Start"] = "start";
	    ReplayerEvents["Pause"] = "pause";
	    ReplayerEvents["Resume"] = "resume";
	    ReplayerEvents["Resize"] = "resize";
	    ReplayerEvents["Finish"] = "finish";
	    ReplayerEvents["FullsnapshotRebuilded"] = "fullsnapshot-rebuilded";
	    ReplayerEvents["LoadStylesheetStart"] = "load-stylesheet-start";
	    ReplayerEvents["LoadStylesheetEnd"] = "load-stylesheet-end";
	    ReplayerEvents["SkipStart"] = "skip-start";
	    ReplayerEvents["SkipEnd"] = "skip-end";
	    ReplayerEvents["MouseInteraction"] = "mouse-interaction";
	    ReplayerEvents["EventCast"] = "event-cast";
	    ReplayerEvents["CustomEvent"] = "custom-event";
	    ReplayerEvents["Flush"] = "flush";
	    ReplayerEvents["StateChange"] = "state-change";
	  })(ReplayerEvents || (ReplayerEvents = {}));

	  function on(type, fn, target) {
	    if (target === void 0) {
	      target = document;
	    }

	    var options = {
	      capture: true,
	      passive: true
	    };
	    target.addEventListener(type, fn, options);
	    return function () {
	      return target.removeEventListener(type, fn, options);
	    };
	  }

	  var mirror = {
	    map: {},
	    getId: function getId(n) {
	      if (!n.__sn) {
	        return -1;
	      }

	      return n.__sn.id;
	    },
	    getNode: function getNode(id) {
	      return mirror.map[id] || null;
	    },
	    removeNodeFromMap: function removeNodeFromMap(n) {
	      var id = n.__sn && n.__sn.id;
	      delete mirror.map[id];

	      if (n.childNodes) {
	        n.childNodes.forEach(function (child) {
	          return mirror.removeNodeFromMap(child);
	        });
	      }
	    },
	    has: function has(id) {
	      return mirror.map.hasOwnProperty(id);
	    }
	  };

	  function throttle(func, wait, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    var timeout = null;
	    var previous = 0;
	    return function (arg) {
	      var now = Date.now();

	      if (!previous && options.leading === false) {
	        previous = now;
	      }

	      var remaining = wait - (now - previous);
	      var context = this;
	      var args = arguments;

	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          window.clearTimeout(timeout);
	          timeout = null;
	        }

	        previous = now;
	        func.apply(context, args);
	      } else if (!timeout && options.trailing !== false) {
	        timeout = window.setTimeout(function () {
	          previous = options.leading === false ? 0 : Date.now();
	          timeout = null;
	          func.apply(context, args);
	        }, remaining);
	      }
	    };
	  }

	  function hookSetter(target, key, d, isRevoked, win) {
	    if (win === void 0) {
	      win = window;
	    }

	    var original = win.Object.getOwnPropertyDescriptor(target, key);
	    win.Object.defineProperty(target, key, isRevoked ? d : {
	      set: function set(value) {
	        var _this = this;

	        setTimeout(function () {
	          d.set.call(_this, value);
	        }, 0);

	        if (original && original.set) {
	          original.set.call(this, value);
	        }
	      }
	    });
	    return function () {
	      return hookSetter(target, key, original || {}, true);
	    };
	  }

	  function patch(source, name, replacement) {
	    try {
	      if (!(name in source)) {
	        return function () {};
	      }

	      var original_1 = source[name];
	      var wrapped = replacement(original_1);

	      if (typeof wrapped === 'function') {
	        wrapped.prototype = wrapped.prototype || {};
	        Object.defineProperties(wrapped, {
	          __rrweb_original__: {
	            enumerable: false,
	            value: original_1
	          }
	        });
	      }

	      source[name] = wrapped;
	      return function () {
	        source[name] = original_1;
	      };
	    } catch (_a) {
	      return function () {};
	    }
	  }

	  function getWindowHeight() {
	    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
	  }

	  function getWindowWidth() {
	    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
	  }

	  function isBlocked(node, blockClass) {
	    if (!node) {
	      return false;
	    }

	    if (node.nodeType === node.ELEMENT_NODE) {
	      var needBlock_1 = false;

	      if (typeof blockClass === 'string') {
	        needBlock_1 = node.classList.contains(blockClass);
	      } else {
	        node.classList.forEach(function (className) {
	          if (blockClass.test(className)) {
	            needBlock_1 = true;
	          }
	        });
	      }

	      return needBlock_1 || isBlocked(node.parentNode, blockClass);
	    }

	    if (node.nodeType === node.TEXT_NODE) {
	      return isBlocked(node.parentNode, blockClass);
	    }

	    return isBlocked(node.parentNode, blockClass);
	  }

	  function isAncestorRemoved(target) {
	    var id = mirror.getId(target);

	    if (!mirror.has(id)) {
	      return true;
	    }

	    if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {
	      return false;
	    }

	    if (!target.parentNode) {
	      return true;
	    }

	    return isAncestorRemoved(target.parentNode);
	  }

	  function isTouchEvent(event) {
	    return Boolean(event.changedTouches);
	  }

	  function polyfill(win) {
	    if (win === void 0) {
	      win = window;
	    }

	    if ('NodeList' in win && !win.NodeList.prototype.forEach) {
	      win.NodeList.prototype.forEach = Array.prototype.forEach;
	    }

	    if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {
	      win.DOMTokenList.prototype.forEach = Array.prototype.forEach;
	    }
	  }

	  function isNodeInLinkedList(n) {
	    return '__ln' in n;
	  }

	  var DoubleLinkedList = function () {
	    function DoubleLinkedList() {
	      this.length = 0;
	      this.head = null;
	    }

	    DoubleLinkedList.prototype.get = function (position) {
	      if (position >= this.length) {
	        throw new Error('Position outside of list range');
	      }

	      var current = this.head;

	      for (var index = 0; index < position; index++) {
	        current = (current === null || current === void 0 ? void 0 : current.next) || null;
	      }

	      return current;
	    };

	    DoubleLinkedList.prototype.addNode = function (n) {
	      var node = {
	        value: n,
	        previous: null,
	        next: null
	      };
	      n.__ln = node;

	      if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {
	        var current = n.previousSibling.__ln.next;
	        node.next = current;
	        node.previous = n.previousSibling.__ln;
	        n.previousSibling.__ln.next = node;

	        if (current) {
	          current.previous = node;
	        }
	      } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling)) {
	        var current = n.nextSibling.__ln.previous;
	        node.previous = current;
	        node.next = n.nextSibling.__ln;
	        n.nextSibling.__ln.previous = node;

	        if (current) {
	          current.next = node;
	        }
	      } else {
	        if (this.head) {
	          this.head.previous = node;
	        }

	        node.next = this.head;
	        this.head = node;
	      }

	      this.length++;
	    };

	    DoubleLinkedList.prototype.removeNode = function (n) {
	      var current = n.__ln;

	      if (!this.head) {
	        return;
	      }

	      if (!current.previous) {
	        this.head = current.next;

	        if (this.head) {
	          this.head.previous = null;
	        }
	      } else {
	        current.previous.next = current.next;

	        if (current.next) {
	          current.next.previous = current.previous;
	        }
	      }

	      if (n.__ln) {
	        delete n.__ln;
	      }

	      this.length--;
	    };

	    return DoubleLinkedList;
	  }();

	  var moveKey = function moveKey(id, parentId) {
	    return id + "@" + parentId;
	  };

	  function isINode(n) {
	    return '__sn' in n;
	  }

	  var MutationBuffer = function () {
	    function MutationBuffer(cb, blockClass, inlineStylesheet, maskInputOptions, recordCanvas) {
	      var _this = this;

	      this.texts = [];
	      this.attributes = [];
	      this.removes = [];
	      this.adds = [];
	      this.movedMap = {};
	      this.addedSet = new Set();
	      this.movedSet = new Set();
	      this.droppedSet = new Set();

	      this.processMutations = function (mutations) {
	        var e_1, _a, e_2, _b;

	        mutations.forEach(_this.processMutation);
	        var addList = new DoubleLinkedList();

	        var getNextId = function getNextId(n) {
	          var nextId = n.nextSibling && mirror.getId(n.nextSibling);

	          if (nextId === -1 && isBlocked(n.nextSibling, _this.blockClass)) {
	            nextId = null;
	          }

	          return nextId;
	        };

	        var pushAdd = function pushAdd(n) {
	          if (!n.parentNode) {
	            return;
	          }

	          var parentId = mirror.getId(n.parentNode);
	          var nextId = getNextId(n);

	          if (parentId === -1 || nextId === -1) {
	            return addList.addNode(n);
	          }

	          _this.adds.push({
	            parentId: parentId,
	            nextId: nextId,
	            node: serializeNodeWithId(n, document, mirror.map, _this.blockClass, true, _this.inlineStylesheet, _this.maskInputOptions, _this.recordCanvas)
	          });
	        };

	        try {
	          for (var _c = __values(_this.movedSet), _d = _c.next(); !_d.done; _d = _c.next()) {
	            var n = _d.value;
	            pushAdd(n);
	          }
	        } catch (e_1_1) {
	          e_1 = {
	            error: e_1_1
	          };
	        } finally {
	          try {
	            if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
	          } finally {
	            if (e_1) throw e_1.error;
	          }
	        }

	        try {
	          for (var _e = __values(_this.addedSet), _f = _e.next(); !_f.done; _f = _e.next()) {
	            var n = _f.value;

	            if (!isAncestorInSet(_this.droppedSet, n) && !isParentRemoved(_this.removes, n)) {
	              pushAdd(n);
	            } else if (isAncestorInSet(_this.movedSet, n)) {
	              pushAdd(n);
	            } else {
	              _this.droppedSet.add(n);
	            }
	          }
	        } catch (e_2_1) {
	          e_2 = {
	            error: e_2_1
	          };
	        } finally {
	          try {
	            if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
	          } finally {
	            if (e_2) throw e_2.error;
	          }
	        }

	        var candidate = null;

	        while (addList.length) {
	          var node = null;

	          if (candidate) {
	            var parentId = mirror.getId(candidate.value.parentNode);
	            var nextId = getNextId(candidate.value);

	            if (parentId !== -1 && nextId !== -1) {
	              node = candidate;
	            }
	          }

	          if (!node) {
	            for (var index = addList.length - 1; index >= 0; index--) {
	              var _node = addList.get(index);

	              if (_node) {
	                var parentId = mirror.getId(_node.value.parentNode);
	                var nextId = getNextId(_node.value);

	                if (parentId !== -1 && nextId !== -1) {
	                  node = _node;
	                  break;
	                }
	              }
	            }
	          }

	          if (!node) {
	            break;
	          }

	          candidate = node.previous;
	          addList.removeNode(node.value);
	          pushAdd(node.value);
	        }

	        _this.emit();
	      };

	      this.emit = function () {
	        var payload = {
	          texts: _this.texts.map(function (text) {
	            return {
	              id: mirror.getId(text.node),
	              value: text.value
	            };
	          }).filter(function (text) {
	            return mirror.has(text.id);
	          }),
	          attributes: _this.attributes.map(function (attribute) {
	            return {
	              id: mirror.getId(attribute.node),
	              attributes: attribute.attributes
	            };
	          }).filter(function (attribute) {
	            return mirror.has(attribute.id);
	          }),
	          removes: _this.removes,
	          adds: _this.adds
	        };

	        if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {
	          return;
	        }

	        _this.emissionCallback(payload);

	        _this.texts = [];
	        _this.attributes = [];
	        _this.removes = [];
	        _this.adds = [];
	        _this.addedSet = new Set();
	        _this.movedSet = new Set();
	        _this.droppedSet = new Set();
	        _this.movedMap = {};
	      };

	      this.processMutation = function (m) {
	        switch (m.type) {
	          case 'characterData':
	            {
	              var value = m.target.textContent;

	              if (!isBlocked(m.target, _this.blockClass) && value !== m.oldValue) {
	                _this.texts.push({
	                  value: value,
	                  node: m.target
	                });
	              }

	              break;
	            }

	          case 'attributes':
	            {
	              var value = m.target.getAttribute(m.attributeName);

	              if (isBlocked(m.target, _this.blockClass) || value === m.oldValue) {
	                return;
	              }

	              var item = _this.attributes.find(function (a) {
	                return a.node === m.target;
	              });

	              if (!item) {
	                item = {
	                  node: m.target,
	                  attributes: {}
	                };

	                _this.attributes.push(item);
	              }

	              item.attributes[m.attributeName] = transformAttribute(document, m.attributeName, value);
	              break;
	            }

	          case 'childList':
	            {
	              m.addedNodes.forEach(function (n) {
	                return _this.genAdds(n, m.target);
	              });
	              m.removedNodes.forEach(function (n) {
	                var nodeId = mirror.getId(n);
	                var parentId = mirror.getId(m.target);

	                if (isBlocked(n, _this.blockClass) || isBlocked(m.target, _this.blockClass)) {
	                  return;
	                }

	                if (_this.addedSet.has(n)) {
	                  deepDelete(_this.addedSet, n);

	                  _this.droppedSet.add(n);
	                } else if (_this.addedSet.has(m.target) && nodeId === -1) ;else if (isAncestorRemoved(m.target)) ;else if (_this.movedSet.has(n) && _this.movedMap[moveKey(nodeId, parentId)]) {
	                  deepDelete(_this.movedSet, n);
	                } else {
	                  _this.removes.push({
	                    parentId: parentId,
	                    id: nodeId
	                  });
	                }

	                mirror.removeNodeFromMap(n);
	              });
	              break;
	            }
	        }
	      };

	      this.genAdds = function (n, target) {
	        if (isBlocked(n, _this.blockClass)) {
	          return;
	        }

	        if (isINode(n)) {
	          _this.movedSet.add(n);

	          var targetId = null;

	          if (target && isINode(target)) {
	            targetId = target.__sn.id;
	          }

	          if (targetId) {
	            _this.movedMap[moveKey(n.__sn.id, targetId)] = true;
	          }
	        } else {
	          _this.addedSet.add(n);

	          _this.droppedSet["delete"](n);
	        }

	        n.childNodes.forEach(function (childN) {
	          return _this.genAdds(childN);
	        });
	      };

	      this.blockClass = blockClass;
	      this.inlineStylesheet = inlineStylesheet;
	      this.maskInputOptions = maskInputOptions;
	      this.recordCanvas = recordCanvas;
	      this.emissionCallback = cb;
	    }

	    return MutationBuffer;
	  }();

	  function deepDelete(addsSet, n) {
	    addsSet["delete"](n);
	    n.childNodes.forEach(function (childN) {
	      return deepDelete(addsSet, childN);
	    });
	  }

	  function isParentRemoved(removes, n) {
	    var parentNode = n.parentNode;

	    if (!parentNode) {
	      return false;
	    }

	    var parentId = mirror.getId(parentNode);

	    if (removes.some(function (r) {
	      return r.id === parentId;
	    })) {
	      return true;
	    }

	    return isParentRemoved(removes, parentNode);
	  }

	  function isAncestorInSet(set, n) {
	    var parentNode = n.parentNode;

	    if (!parentNode) {
	      return false;
	    }

	    if (set.has(parentNode)) {
	      return true;
	    }

	    return isAncestorInSet(set, parentNode);
	  }

	  function initMutationObserver(cb, blockClass, inlineStylesheet, maskInputOptions, recordCanvas) {
	    var mutationBuffer = new MutationBuffer(cb, blockClass, inlineStylesheet, maskInputOptions, recordCanvas);
	    var observer = new MutationObserver(mutationBuffer.processMutations);
	    observer.observe(document, {
	      attributes: true,
	      attributeOldValue: true,
	      characterData: true,
	      characterDataOldValue: true,
	      childList: true,
	      subtree: true
	    });
	    return observer;
	  }

	  function initMoveObserver(cb, sampling) {
	    if (sampling.mousemove === false) {
	      return function () {};
	    }

	    var threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;
	    var positions = [];
	    var timeBaseline;
	    var wrappedCb = throttle(function (isTouch) {
	      var totalOffset = Date.now() - timeBaseline;
	      cb(positions.map(function (p) {
	        p.timeOffset -= totalOffset;
	        return p;
	      }), isTouch ? IncrementalSource.TouchMove : IncrementalSource.MouseMove);
	      positions = [];
	      timeBaseline = null;
	    }, 500);
	    var updatePosition = throttle(function (evt) {
	      var target = evt.target;

	      var _a = isTouchEvent(evt) ? evt.changedTouches[0] : evt,
	          clientX = _a.clientX,
	          clientY = _a.clientY;

	      if (!timeBaseline) {
	        timeBaseline = Date.now();
	      }

	      positions.push({
	        x: clientX,
	        y: clientY,
	        id: mirror.getId(target),
	        timeOffset: Date.now() - timeBaseline
	      });
	      wrappedCb(isTouchEvent(evt));
	    }, threshold, {
	      trailing: false
	    });
	    var handlers = [on('mousemove', updatePosition), on('touchmove', updatePosition)];
	    return function () {
	      handlers.forEach(function (h) {
	        return h();
	      });
	    };
	  }

	  function initMouseInteractionObserver(cb, blockClass, sampling) {
	    if (sampling.mouseInteraction === false) {
	      return function () {};
	    }

	    var disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === undefined ? {} : sampling.mouseInteraction;
	    var handlers = [];

	    var getHandler = function getHandler(eventKey) {
	      return function (event) {
	        if (isBlocked(event.target, blockClass)) {
	          return;
	        }

	        var id = mirror.getId(event.target);

	        var _a = isTouchEvent(event) ? event.changedTouches[0] : event,
	            clientX = _a.clientX,
	            clientY = _a.clientY;

	        cb({
	          type: MouseInteractions[eventKey],
	          id: id,
	          x: clientX,
	          y: clientY
	        });
	      };
	    };

	    Object.keys(MouseInteractions).filter(function (key) {
	      return Number.isNaN(Number(key)) && !key.endsWith('_Departed') && disableMap[key] !== false;
	    }).forEach(function (eventKey) {
	      var eventName = eventKey.toLowerCase();
	      var handler = getHandler(eventKey);
	      handlers.push(on(eventName, handler));
	    });
	    return function () {
	      handlers.forEach(function (h) {
	        return h();
	      });
	    };
	  }

	  function initScrollObserver(cb, blockClass, sampling) {
	    var updatePosition = throttle(function (evt) {
	      if (!evt.target || isBlocked(evt.target, blockClass)) {
	        return;
	      }

	      var id = mirror.getId(evt.target);

	      if (evt.target === document) {
	        var scrollEl = document.scrollingElement || document.documentElement;
	        cb({
	          id: id,
	          x: scrollEl.scrollLeft,
	          y: scrollEl.scrollTop
	        });
	      } else {
	        cb({
	          id: id,
	          x: evt.target.scrollLeft,
	          y: evt.target.scrollTop
	        });
	      }
	    }, sampling.scroll || 100);
	    return on('scroll', updatePosition);
	  }

	  function initViewportResizeObserver(cb) {
	    var updateDimension = throttle(function () {
	      var height = getWindowHeight();
	      var width = getWindowWidth();
	      cb({
	        width: Number(width),
	        height: Number(height)
	      });
	    }, 200);
	    return on('resize', updateDimension, window);
	  }

	  var INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];
	  var lastInputValueMap = new WeakMap();

	  function initInputObserver(cb, blockClass, ignoreClass, maskInputOptions, sampling) {
	    function eventHandler(event) {
	      var target = event.target;

	      if (!target || !target.tagName || INPUT_TAGS.indexOf(target.tagName) < 0 || isBlocked(target, blockClass)) {
	        return;
	      }

	      var type = target.type;

	      if (type === 'password' || target.classList.contains(ignoreClass)) {
	        return;
	      }

	      var text = target.value;
	      var isChecked = false;

	      if (type === 'radio' || type === 'checkbox') {
	        isChecked = target.checked;
	      }

	      cbWithDedup(target, {
	        text: text,
	        isChecked: isChecked
	      });
	      var name = target.name;

	      if (type === 'radio' && name && isChecked) {
	        document.querySelectorAll("input[type=\"radio\"][name=\"" + name + "\"]").forEach(function (el) {
	          if (el !== target) {
	            cbWithDedup(el, {
	              text: el.value,
	              isChecked: !isChecked
	            });
	          }
	        });
	      }
	    }

	    function cbWithDedup(target, v) {
	      var lastInputValue = lastInputValueMap.get(target);

	      if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {
	        lastInputValueMap.set(target, v);
	        var id = mirror.getId(target);
	        cb(_assign(_assign({}, v), {
	          id: id
	        }));
	      }
	    }

	    var events = sampling.input === 'last' ? ['change'] : ['input', 'change'];
	    var handlers = events.map(function (eventName) {
	      return on(eventName, eventHandler);
	    });
	    var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
	    var hookProperties = [[HTMLInputElement.prototype, 'value'], [HTMLInputElement.prototype, 'checked'], [HTMLSelectElement.prototype, 'value'], [HTMLTextAreaElement.prototype, 'value'], [HTMLSelectElement.prototype, 'selectedIndex']];

	    if (propertyDescriptor && propertyDescriptor.set) {
	      handlers.push.apply(handlers, __spread(hookProperties.map(function (p) {
	        return hookSetter(p[0], p[1], {
	          set: function set() {
	            eventHandler({
	              target: this
	            });
	          }
	        });
	      })));
	    }

	    return function () {
	      handlers.forEach(function (h) {
	        return h();
	      });
	    };
	  }

	  function initStyleSheetObserver(cb) {
	    var insertRule = CSSStyleSheet.prototype.insertRule;

	    CSSStyleSheet.prototype.insertRule = function (rule, index) {
	      var id = mirror.getId(this.ownerNode);

	      if (id !== -1) {
	        cb({
	          id: id,
	          adds: [{
	            rule: rule,
	            index: index
	          }]
	        });
	      }

	      return insertRule.apply(this, arguments);
	    };

	    var deleteRule = CSSStyleSheet.prototype.deleteRule;

	    CSSStyleSheet.prototype.deleteRule = function (index) {
	      var id = mirror.getId(this.ownerNode);

	      if (id !== -1) {
	        cb({
	          id: id,
	          removes: [{
	            index: index
	          }]
	        });
	      }

	      return deleteRule.apply(this, arguments);
	    };

	    return function () {
	      CSSStyleSheet.prototype.insertRule = insertRule;
	      CSSStyleSheet.prototype.deleteRule = deleteRule;
	    };
	  }

	  function initMediaInteractionObserver(mediaInteractionCb, blockClass) {
	    var handler = function handler(type) {
	      return function (event) {
	        var target = event.target;

	        if (!target || isBlocked(target, blockClass)) {
	          return;
	        }

	        mediaInteractionCb({
	          type: type === 'play' ? MediaInteractions.Play : MediaInteractions.Pause,
	          id: mirror.getId(target)
	        });
	      };
	    };

	    var handlers = [on('play', handler('play')), on('pause', handler('pause'))];
	    return function () {
	      handlers.forEach(function (h) {
	        return h();
	      });
	    };
	  }

	  function initCanvasMutationObserver(cb, blockClass) {
	    var e_1, _a;

	    var props = Object.getOwnPropertyNames(CanvasRenderingContext2D.prototype);
	    var handlers = [];

	    var _loop_1 = function _loop_1(prop) {
	      try {
	        if (typeof CanvasRenderingContext2D.prototype[prop] !== 'function') {
	          return "continue";
	        }

	        var restoreHandler = patch(CanvasRenderingContext2D.prototype, prop, function (original) {
	          return function () {
	            var _this = this;

	            var args = [];

	            for (var _i = 0; _i < arguments.length; _i++) {
	              args[_i] = arguments[_i];
	            }

	            if (!isBlocked(this.canvas, blockClass)) {
	              setTimeout(function () {
	                var recordArgs = __spread(args);

	                if (prop === 'drawImage') {
	                  if (recordArgs[0] && recordArgs[0] instanceof HTMLCanvasElement) {
	                    recordArgs[0] = recordArgs[0].toDataURL();
	                  }
	                }

	                cb({
	                  id: mirror.getId(_this.canvas),
	                  property: prop,
	                  args: recordArgs
	                });
	              }, 0);
	            }

	            return original.apply(this, args);
	          };
	        });
	        handlers.push(restoreHandler);
	      } catch (_a) {
	        var hookHandler = hookSetter(CanvasRenderingContext2D.prototype, prop, {
	          set: function set(v) {
	            cb({
	              id: mirror.getId(this.canvas),
	              property: prop,
	              args: [v],
	              setter: true
	            });
	          }
	        });
	        handlers.push(hookHandler);
	      }
	    };

	    try {
	      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
	        var prop = props_1_1.value;

	        _loop_1(prop);
	      }
	    } catch (e_1_1) {
	      e_1 = {
	        error: e_1_1
	      };
	    } finally {
	      try {
	        if (props_1_1 && !props_1_1.done && (_a = props_1["return"])) _a.call(props_1);
	      } finally {
	        if (e_1) throw e_1.error;
	      }
	    }

	    return function () {
	      handlers.forEach(function (h) {
	        return h();
	      });
	    };
	  }

	  function initFontObserver(cb) {
	    var handlers = [];
	    var fontMap = new WeakMap();
	    var originalFontFace = FontFace;

	    window.FontFace = function FontFace(family, source, descriptors) {
	      var fontFace = new originalFontFace(family, source, descriptors);
	      fontMap.set(fontFace, {
	        family: family,
	        buffer: typeof source !== 'string',
	        descriptors: descriptors,
	        fontSource: typeof source === 'string' ? source : JSON.stringify(Array.from(new Uint8Array(source)))
	      });
	      return fontFace;
	    };

	    var restoreHandler = patch(document.fonts, 'add', function (original) {
	      return function (fontFace) {
	        setTimeout(function () {
	          var p = fontMap.get(fontFace);

	          if (p) {
	            cb(p);
	            fontMap["delete"](fontFace);
	          }
	        }, 0);
	        return original.apply(this, [fontFace]);
	      };
	    });
	    handlers.push(function () {
	      window.FonFace = originalFontFace;
	    });
	    handlers.push(restoreHandler);
	    return function () {
	      handlers.forEach(function (h) {
	        return h();
	      });
	    };
	  }

	  function mergeHooks(o, hooks) {
	    var mutationCb = o.mutationCb,
	        mousemoveCb = o.mousemoveCb,
	        mouseInteractionCb = o.mouseInteractionCb,
	        scrollCb = o.scrollCb,
	        viewportResizeCb = o.viewportResizeCb,
	        inputCb = o.inputCb,
	        mediaInteractionCb = o.mediaInteractionCb,
	        styleSheetRuleCb = o.styleSheetRuleCb,
	        canvasMutationCb = o.canvasMutationCb,
	        fontCb = o.fontCb;

	    o.mutationCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.mutation) {
	        hooks.mutation.apply(hooks, __spread(p));
	      }

	      mutationCb.apply(void 0, __spread(p));
	    };

	    o.mousemoveCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.mousemove) {
	        hooks.mousemove.apply(hooks, __spread(p));
	      }

	      mousemoveCb.apply(void 0, __spread(p));
	    };

	    o.mouseInteractionCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.mouseInteraction) {
	        hooks.mouseInteraction.apply(hooks, __spread(p));
	      }

	      mouseInteractionCb.apply(void 0, __spread(p));
	    };

	    o.scrollCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.scroll) {
	        hooks.scroll.apply(hooks, __spread(p));
	      }

	      scrollCb.apply(void 0, __spread(p));
	    };

	    o.viewportResizeCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.viewportResize) {
	        hooks.viewportResize.apply(hooks, __spread(p));
	      }

	      viewportResizeCb.apply(void 0, __spread(p));
	    };

	    o.inputCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.input) {
	        hooks.input.apply(hooks, __spread(p));
	      }

	      inputCb.apply(void 0, __spread(p));
	    };

	    o.mediaInteractionCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.mediaInteaction) {
	        hooks.mediaInteaction.apply(hooks, __spread(p));
	      }

	      mediaInteractionCb.apply(void 0, __spread(p));
	    };

	    o.styleSheetRuleCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.styleSheetRule) {
	        hooks.styleSheetRule.apply(hooks, __spread(p));
	      }

	      styleSheetRuleCb.apply(void 0, __spread(p));
	    };

	    o.canvasMutationCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.canvasMutation) {
	        hooks.canvasMutation.apply(hooks, __spread(p));
	      }

	      canvasMutationCb.apply(void 0, __spread(p));
	    };

	    o.fontCb = function () {
	      var p = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        p[_i] = arguments[_i];
	      }

	      if (hooks.font) {
	        hooks.font.apply(hooks, __spread(p));
	      }

	      fontCb.apply(void 0, __spread(p));
	    };
	  }

	  function initObservers(o, hooks) {
	    if (hooks === void 0) {
	      hooks = {};
	    }

	    mergeHooks(o, hooks);
	    var mutationObserver = initMutationObserver(o.mutationCb, o.blockClass, o.inlineStylesheet, o.maskInputOptions, o.recordCanvas);
	    var mousemoveHandler = initMoveObserver(o.mousemoveCb, o.sampling);
	    var mouseInteractionHandler = initMouseInteractionObserver(o.mouseInteractionCb, o.blockClass, o.sampling);
	    var scrollHandler = initScrollObserver(o.scrollCb, o.blockClass, o.sampling);
	    var viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);
	    var inputHandler = initInputObserver(o.inputCb, o.blockClass, o.ignoreClass, o.maskInputOptions, o.sampling);
	    var mediaInteractionHandler = initMediaInteractionObserver(o.mediaInteractionCb, o.blockClass);
	    var styleSheetObserver = initStyleSheetObserver(o.styleSheetRuleCb);
	    var canvasMutationObserver = o.recordCanvas ? initCanvasMutationObserver(o.canvasMutationCb, o.blockClass) : function () {};
	    var fontObserver = o.collectFonts ? initFontObserver(o.fontCb) : function () {};
	    return function () {
	      mutationObserver.disconnect();
	      mousemoveHandler();
	      mouseInteractionHandler();
	      scrollHandler();
	      viewportResizeHandler();
	      inputHandler();
	      mediaInteractionHandler();
	      styleSheetObserver();
	      canvasMutationObserver();
	      fontObserver();
	    };
	  }

	  function wrapEvent(e) {
	    return _assign(_assign({}, e), {
	      timestamp: Date.now()
	    });
	  }

	  var wrappedEmit;

	  function record(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    var emit = options.emit,
	        checkoutEveryNms = options.checkoutEveryNms,
	        checkoutEveryNth = options.checkoutEveryNth,
	        _a = options.blockClass,
	        blockClass = _a === void 0 ? 'situ-placeholder' : _a,
	        _b = options.ignoreClass,
	        ignoreClass = _b === void 0 ? 'situ-ignore' : _b,
	        _c = options.inlineStylesheet,
	        inlineStylesheet = _c === void 0 ? true : _c,
	        maskAllInputs = options.maskAllInputs,
	        _maskInputOptions = options.maskInputOptions,
	        hooks = options.hooks,
	        packFn = options.packFn,
	        _d = options.sampling,
	        sampling = _d === void 0 ? {} : _d,
	        mousemoveWait = options.mousemoveWait,
	        _e = options.recordCanvas,
	        recordCanvas = _e === void 0 ? false : _e,
	        _f = options.collectFonts,
	        collectFonts = _f === void 0 ? false : _f;

	    if (!emit) {
	      throw new Error('emit function is required');
	    }

	    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {
	      sampling.mousemove = mousemoveWait;
	    }

	    var maskInputOptions = maskAllInputs === true ? {
	      color: true,
	      date: true,
	      'datetime-local': true,
	      email: true,
	      month: true,
	      number: true,
	      range: true,
	      search: true,
	      tel: true,
	      text: true,
	      time: true,
	      url: true,
	      week: true,
	      textarea: true,
	      select: true
	    } : _maskInputOptions !== undefined ? _maskInputOptions : {};
	    polyfill();
	    var lastFullSnapshotEvent;
	    var incrementalSnapshotCount = 0;

	    wrappedEmit = function wrappedEmit(e, isCheckout) {
	      emit(packFn ? packFn(e) : e, isCheckout);

	      if (e.type === EventType.FullSnapshot) {
	        lastFullSnapshotEvent = e;
	        incrementalSnapshotCount = 0;
	      } else if (e.type === EventType.IncrementalSnapshot) {
	        incrementalSnapshotCount++;
	        var exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
	        var exceedTime = checkoutEveryNms && e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;

	        if (exceedCount || exceedTime) {
	          takeFullSnapshot(true);
	        }
	      }
	    };

	    function takeFullSnapshot(isCheckout) {
	      var _a, _b, _c, _d;

	      if (isCheckout === void 0) {
	        isCheckout = false;
	      }

	      wrappedEmit(wrapEvent({
	        type: EventType.Meta,
	        data: {
	          href: window.location.href,
	          width: getWindowWidth(),
	          height: getWindowHeight()
	        }
	      }), isCheckout);

	      var _e = __read(snapshot(document, blockClass, inlineStylesheet, maskInputOptions, recordCanvas), 2),
	          node = _e[0],
	          idNodeMap = _e[1];

	      if (!node) {
	        return console.warn('Failed to snapshot the document');
	      }

	      mirror.map = idNodeMap;
	      wrappedEmit(wrapEvent({
	        type: EventType.FullSnapshot,
	        data: {
	          node: node,
	          initialOffset: {
	            left: window.pageXOffset !== undefined ? window.pageXOffset : (document === null || document === void 0 ? void 0 : document.documentElement.scrollLeft) || ((_b = (_a = document === null || document === void 0 ? void 0 : document.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.scrollLeft) || (document === null || document === void 0 ? void 0 : document.body.scrollLeft) || 0,
	            top: window.pageYOffset !== undefined ? window.pageYOffset : (document === null || document === void 0 ? void 0 : document.documentElement.scrollTop) || ((_d = (_c = document === null || document === void 0 ? void 0 : document.body) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.scrollTop) || (document === null || document === void 0 ? void 0 : document.body.scrollTop) || 0
	          }
	        }
	      }));
	    }

	    try {
	      var handlers_1 = [];
	      handlers_1.push(on('DOMContentLoaded', function () {
	        wrappedEmit(wrapEvent({
	          type: EventType.DomContentLoaded,
	          data: {}
	        }));
	      }));

	      var init_1 = function init_1() {
	        takeFullSnapshot();
	        handlers_1.push(initObservers({
	          mutationCb: function mutationCb(m) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.Mutation
	              }, m)
	            }));
	          },
	          mousemoveCb: function mousemoveCb(positions, source) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: {
	                source: source,
	                positions: positions
	              }
	            }));
	          },
	          mouseInteractionCb: function mouseInteractionCb(d) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.MouseInteraction
	              }, d)
	            }));
	          },
	          scrollCb: function scrollCb(p) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.Scroll
	              }, p)
	            }));
	          },
	          viewportResizeCb: function viewportResizeCb(d) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.ViewportResize
	              }, d)
	            }));
	          },
	          inputCb: function inputCb(v) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.Input
	              }, v)
	            }));
	          },
	          mediaInteractionCb: function mediaInteractionCb(p) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.MediaInteraction
	              }, p)
	            }));
	          },
	          styleSheetRuleCb: function styleSheetRuleCb(r) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.StyleSheetRule
	              }, r)
	            }));
	          },
	          canvasMutationCb: function canvasMutationCb(p) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.CanvasMutation
	              }, p)
	            }));
	          },
	          fontCb: function fontCb(p) {
	            return wrappedEmit(wrapEvent({
	              type: EventType.IncrementalSnapshot,
	              data: _assign({
	                source: IncrementalSource.Font
	              }, p)
	            }));
	          },
	          blockClass: blockClass,
	          ignoreClass: ignoreClass,
	          maskInputOptions: maskInputOptions,
	          inlineStylesheet: inlineStylesheet,
	          sampling: sampling,
	          recordCanvas: recordCanvas,
	          collectFonts: collectFonts
	        }, hooks));
	      };

	      if (document.readyState === 'interactive' || document.readyState === 'complete') {
	        init_1();
	      } else {
	        handlers_1.push(on('load', function () {
	          wrappedEmit(wrapEvent({
	            type: EventType.Load,
	            data: {}
	          }));
	          init_1();
	        }, window));
	      }

	      return function () {
	        handlers_1.forEach(function (h) {
	          return h();
	        });
	      };
	    } catch (error) {
	      console.warn(error);
	    }
	  }

	  record.addCustomEvent = function (tag, payload) {
	    if (!wrappedEmit) {
	      throw new Error('please add custom event after start recording');
	    }

	    wrappedEmit(wrapEvent({
	      type: EventType.Custom,
	      data: {
	        tag: tag,
	        payload: payload
	      }
	    }));
	  };

	  return record;
	}();
	 // situ 手动添加 0.9.7

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) {
	    arr2[i] = arr[i];
	  }

	  return arr2;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

	  if (!it) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function F() {};

	      return {
	        s: F,
	        n: function n() {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function e(_e) {
	          throw _e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function s() {
	      it = it.call(o);
	    },
	    n: function n() {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function e(_e2) {
	      didErr = true;
	      err = _e2;
	    },
	    f: function f() {
	      try {
	        if (!normalCompletion && it["return"] != null) it["return"]();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	// 条款录制的处理，主要是使用canvas显示pdf，只支持来源于条款管理系统的pdf
	var observer = null;
	/**
	 * pdf渲染的容器元素上需定义属性data-record-pdf-key、data-record-pdf-url，值不能为空
	 * 目前只支持匹配类名含pdfViewer或vue-pdf-embed的父级元素
	 * <div class="pdfViewer" data-record-pdf-key="" data-record-pdf-url=""></div>
	 * <div class="vue-pdf-embed" data-record-pdf-key="" data-record-pdf-url=""></div>
	 * @param {*} canvas 
	 * @returns 
	 */

	var setPdfCanvas = function setPdfCanvas(canvas) {
	  var parentElement = canvas.parentElement;

	  while (parentElement && parentElement !== document.documentElement) {
	    var classList = parentElement.classList;

	    if (classList.contains('pdfViewer') || classList.contains('vue-pdf-embed')) {
	      var children = parentElement.children;
	      var pageNumber = -1;

	      for (var i = 0, ilen = children.length; i < ilen; i++) {
	        var element = children[i];

	        if (element === canvas || element.contains(canvas)) {
	          pageNumber = i + 1;
	          break;
	        }
	      }

	      parentElement.setAttribute('data-record-pdf-pages', children.length);

	      if (!parentElement.getAttribute('data-record-id-ivbor')) {
	        parentElement.setAttribute('data-record-id-ivbor', String(Math.random()).slice(-6));
	      }

	      var idIvbor = parentElement.getAttribute('data-record-id-ivbor');
	      canvas.setAttribute('data-record-pdf-id', idIvbor);
	      canvas.setAttribute('data-record-pdf-page-number', pageNumber);
	      return true;
	    }

	    parentElement = parentElement.parentElement;
	  }

	  return false;
	};

	var isCanvasNode = function isCanvasNode(node) {
	  if (node && node.nodeType === Node.ELEMENT_NODE) {
	    var tagName = node.tagName;
	    return tagName === 'CANVAS' || tagName === 'canvas';
	  }

	  return false;
	};

	var clause = {
	  observe: function observe() {
	    var canvases = document.getElementsByTagName('canvas');

	    for (var i = 0, ilen = canvases.length; i < ilen; i++) {
	      setPdfCanvas(canvases[i]);
	    }

	    if (!observer) {
	      var targetNode = document.documentElement;
	      var config = {
	        childList: true,
	        subtree: true
	      };

	      var callback = function callback(mutationList, observer) {
	        var _iterator = _createForOfIteratorHelper(mutationList),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var mutation = _step.value;

	            if (mutation.type === 'childList') {
	              if (mutation.addedNodes) {
	                mutation.addedNodes.forEach(function (node) {
	                  if (node && node.nodeType === Node.ELEMENT_NODE) {
	                    if (isCanvasNode(node)) {
	                      setPdfCanvas(node);
	                    } else {
	                      var _canvases = node.getElementsByTagName('canvas');

	                      for (var _i = 0, _ilen = _canvases.length; _i < _ilen; _i++) {
	                        setPdfCanvas(_canvases[_i]);
	                      }
	                    }
	                  }
	                });
	              }
	            }
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	      };

	      observer = new MutationObserver(callback);
	      observer.observe(targetNode, config);
	    }
	  },
	  disconnect: function disconnect() {
	    if (observer) {
	      observer.disconnect();
	      observer = null;
	    }
	  },
	  getPdfPages: function getPdfPages(canvas) {
	    var pdfId = canvas.getAttribute('data-record-pdf-id');
	    var pdfElement = document.querySelector('[data-record-id-ivbor="' + pdfId + '"]');
	    var pdfPages = pdfElement ? pdfElement.getAttribute('data-record-pdf-pages') : -1;
	    return pdfPages ? Number(pdfPages) : -1;
	  }
	};

	console.log('[ST INFO]:SDK 版本 v1.5.8.072301');
	/***************************************************
	 * 系统初始化参数
	 ***************************************************/

	var default_publicKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCe2RMZXmxMDhz9uQVVz7dGWlFhHQvHJ9hpEqpXouS8flMfTPWH5lwtT41UUvq70c5RarCVZO/8jYamKW6RaIlMAddXtPVKtTf0kc1TiZ2BhhkQm0vLCbmxXhNLWBKLRoJyZYhHiiMXxNH8s4dCIULaSIuoXkbnFkKGpExbX95OhwIDAQAB"; // 公钥（根据不同客户由后端生成）

	var default_staging_baseUrl = 'http://staging-idr-record-video.situdata.com'; // 后端staging访问地址

	var default_baseUrl = default_staging_baseUrl; // 后端默认访问地址

	var default_dev_baseUrl = 'http://staging-idr-record-video.situdata.com'; // env属性存在时，后端开发环境访问地址

	var default_prod_baseUrl = 'https://sinosafekhs.cias.cn'; // env属性存在时，后端生产环境访问地址

	var default_timeout = 3600; // 超时时长，单位：秒

	var default_maxSize = 8 * 1024 * 1024; // 最大录制容量，单位：Byte

	var default_cookieExpires = getTimestamp() + 24 * 3600 * 1000; // cookie过期时间，24小时，时间戳

	var default_encode_mode = 1; // 录制信息封装模式：1=AES加密，2=明文，3=protobuf，4=JSON序列化明文

	var publicKey = default_publicKey; // 公钥（根据不同客户由后端生成）

	var baseUrl = default_baseUrl; // 后端访问地址

	var timeout = default_timeout; // 超时时长，单位：秒

	var maxSize = default_maxSize; // 最大录制容量，Byte

	var cookieExpires = default_cookieExpires; // cookie过期时间，24小时

	var encodeMode = default_encode_mode; // 录制信息封装模式：1=AES加密，2=明文，3=protobuf，4=JSON序列化明文，默认为AES加密

	var urls = []; // 录制url地址数组

	var limit_timeout = 10; // 单次录制超时时间约束，单位：秒

	var limit_videoMaxSize = 1; // 录制视频容量约束，单位：M

	var limit_recordPerTime = 1; // 定时推送录制内容时长约束，单位：秒

	var limit_cookieExpires = getTimestamp() + 3600000; // cookie过期时长约束，时间戳，1小时

	var load_page = 'LOAD_PAGE'; // 页面加载

	var click_enter = 'CLICK_ENTER'; // 点击输入

	var click_button = 'CLICK_BUTTON'; // 点击按钮

	var click_select = 'CLICK_SELECT'; // 点击选中

	var SituWorker; // web worker 子线程对象

	var SituWorkerPostMessage;
	/***************************************************
	 * 内部逻辑控制模块参数
	 ***************************************************/

	var events = []; // 录制内容封装

	var temp_events = []; // 传输录制内容片段数组，仅做容量超过限制判断

	var current_event_index = 0; // events中已分片上传的索引，默认-1，从0开始计数

	var recordFn; // 录制函数

	var recordMode = 0; // 录制模式，1=整段录制，2=时间片录制

	var isRecording = false; // 是否正在录制标志

	var autoDot = false; // 自动埋点标识，默认false

	var recordNum = 0; // 录制片段数量

	/**
	 * 商务需求参数
	 */

	var gdym_signature = false; // 光大定制参数：true开启签字模式，false关闭签字模式

	var page_id = generatePageID(); // 页面ID，以便播放时识别是同一个页面

	var eventSortNo = 0; // 事件排序序号，避免分片数据上传时后台接收存储的顺序不一致

	/**
	 * 生成页面ID
	 */

	function generatePageID() {
	  var date = new Date();
	  var year = date.getFullYear();
	  var month = date.getMonth() + 1;
	  var day = date.getDate();
	  var substr = generateUUID().slice(-4);
	  return "".concat(year).concat(month > 9 ? '' : '0').concat(month).concat(day > 9 ? '' : '0').concat(day).concat(substr);
	}
	/**
	 * 启动设备录制
	 */


	function startRecording(params) {
	  window.rrwebEvents = events = [];
	  current_event_index = 0;
	  recordFn = rrwebRecord({
	    emit: function emit(event) {
	      eventSortNo++;
	      event.type === 4 && urls.push(event.data.href);
	      event.timestamp = getTimestamp(event.timestamp);
	      event.pageId = page_id;
	      event.sortNo = eventSortNo; // 加密模式下，条款pdf iframe的元数据很大，会导致iPhone内存溢出，需要不加密单独上传

	      if (encodeMode == 1 && event.data && event.data.isAttachIframe && event.data.isClausePdf) {
	        // 上传前先把之前的events自动上传，保证index是顺序的
	        var promise = stopRecord({
	          last: 0
	        }, true);
	        var data = getRecordExtraData({
	          taskId: taskId,
	          timestamp: getTimestamp(),
	          last: 0,
	          isManualCall: false,
	          urls: urls
	        }, 2);
	        var _encodeMode = 4; // 条款数据不加密，只是JSON序列化的明文

	        var arr = [event];
	        promise["finally"](function () {
	          var isSkipCheckStop = true;

	          if (SituWorker && recordMode === 2) {
	            var onmessage = /*#__PURE__*/function () {
	              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(event) {
	                return regeneratorRuntime.wrap(function _callee$(_context) {
	                  while (1) {
	                    switch (_context.prev = _context.next) {
	                      case 0:
	                        data.recordInfo = event.data[0];
	                        doRecording(data, [], isSkipCheckStop);

	                      case 2:
	                      case "end":
	                        return _context.stop();
	                    }
	                  }
	                }, _callee);
	              }));

	              return function onmessage(_x) {
	                return _ref.apply(this, arguments);
	              };
	            }();

	            SituWorkerPostMessage({
	              events: arr,
	              encodeMode: _encodeMode
	            }, onmessage);
	          } else {
	            data.recordInfo = encodingHandler(_encodeMode, arr);
	            doRecording(data, [], isSkipCheckStop);
	          }
	        });
	      } else {
	        events.push(event);
	      }
	    },
	    recordCanvas: recordCanvasToBase64 === true ? false : Boolean(params && params.recordCanvas),
	    // 默认为false，置为true会导致canvas录制容量过大
	    recordCrossOriginIframes: Boolean(params && params.recordCrossOriginIframes)
	  });
	  isRecording = true;
	}
	/**
	 * 结束设备录制
	 */


	function stopRecording() {
	  recordFn();
	  isRecording = false;
	  current_event_index = 0;
	}
	/**
	 * 生成UUID
	 * @returns {string} 返回UUID字符串
	 */


	function generateUUID() {
	  var d = new Date().getTime();
	  var uuid = 'xxxxxxxxxxxx8xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = (d + Math.random() * 16) % 16 | 0;
	    d = Math.floor(d / 16);
	    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);
	  });
	  return uuid;
	}
	/**
	 * 获取时间戳
	 */


	function getTimestamp(time) {
	  if (time) {
	    if (isNaN(time)) {
	      try {
	        var _time = new Date(time).getTime();

	        return _time;
	      } catch (error) {
	        console.error('[ST Error(时间转换异常)]:', error);
	      }
	    } else {
	      return time;
	    }
	  }

	  return new Date().getTime();
	}
	/**
	 * 生成密文
	 * @param {Object} data 
	 */


	function generateSign(data) {
	  if (data instanceof Object) {
	    data.stamp = generateUUID();
	    data.stampSign = generateCipherText(data.stamp);
	    !data.stampSign && console.error('[ST Error(参数错误)]:公钥错误');
	  }

	  return data;
	}
	/**
	 * 生成非对称加密信息
	 * 公钥 + data
	 * @param {Object} data 传参内容
	 */


	function generateCipherText(data) {
	  var encrypt = new JSEncrypt();
	  encrypt.setPublicKey(publicKey);
	  var dataStr = JSON.stringify(data);
	  var encrypted = encrypt.encrypt(dataStr); // todo 调试用，解密
	  // var decrypt = new JSEncrypt()
	  // let privateKey = `MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJ7ZExlebEwOHP25BVXPt0ZaUWEdC8cn2GkSqlei5Lx+Ux9M9YfmXC1PjVRS+rvRzlFqsJVk7/yNhqYpbpFoiUwB11e09Uq1N/SRzVOJnYGGGRCbS8sJubFeE0tYEotGgnJliEeKIxfE0fyzh0IhQtpIi6heRucWQoakTFtf3k6HAgMBAAECgYAJFFtVHeKOzle14Pd/GipdqRfxtxlPPuXNy7VU4Qi2BXp21Y1LQU2PgXaQlVWjmrByUujZATX+d5B0uvWI9jKywDe8kyTJb2t86tl6MykplduLv8CcukbnZf5Drmq3ZQWaN4ecyr+zZmzbuKNKD35L\nPPN2KN+EeAC4NrzImmxy0QJBAOg4usNUHlv6zsNgQSSWl57cTvXPeMmW1NCFIK5R2pd9xuUJwgdsSJL5+8yfa90QTPviePL3XdjzLe43TdMMU8UCQQCvHPyyHg7yzZgvB/6IVXQEItB0qp9p2TazKkbFvqciTqpUxMCrADIkS3zEh7QuB/6odiDFin1hlduv3Q8+kWHbAkEAxru16W/Vw3Wy+TUoyr0t6MA1utvhTPQOEJ29yDE41yjGzEA7ksqymUXinc1ZLAjFOVMpmxTjdcU3a4Rcz97e2QJAb2UHMt+ALuCugKybNGr3xHHJHY40nob5DvxDzSM8+swD+qy2y5DyVLhYhES3T9jyHIQY0NEKdXt5JuR/ABRHpQJAciA3EACGJtrwVCApzI1KvkHg16hoTTWbF5P+Kj8vWWQfpYqni+ubbPmyoZpkrLYIkjuKdkeGd9gfShOfke/SbA==`
	  // decrypt.setPrivateKey(privateKey)
	  // var uncrypted = decrypt.decrypt(encrypted)
	  // console.log('解密：')
	  // console.log(uncrypted)

	  return encrypted;
	}
	/**
	 * 生成对称加密信息
	 * @param {*} data 
	 */


	function generateSymEncrypt(data) {
	  // Encrypt-v2
	  var key = '0ca03a92751282f6ee05f8e6e42020b5';

	  var _key = cryptoJs.enc.Utf8.parse(key);

	  var _data = cryptoJs.enc.Utf8.parse(data);

	  var ciphertext = cryptoJs.AES.encrypt(_data, _key, {
	    mode: cryptoJs.mode.ECB,
	    padding: cryptoJs.pad.Pkcs7
	  }).toString(); // console.log('密文：')
	  // console.log(ciphertext)

	  return ciphertext;
	}
	/***************************************************
	 * 业务逻辑控制模块
	 ***************************************************/


	var taskId;
	/**
	 * 外部接口：启动录制
	 * @param {Object} [initParams] 初始化参数
	 */

	function startRecord(initParams) {
	  if (isRecording) {
	    return {
	      code: 20008,
	      msg: '正在录制，请勿重复启动'
	    };
	  }

	  if (typeof MutationObserver !== 'function') {
	    return {
	      code: 20005,
	      msg: '您的浏览器不支持录制，请使用最新版本'
	    };
	  }

	  if (initParams) {
	    var validateInfo = validateInitParams(initParams);

	    if (validateInfo.code !== 10000) {
	      return validateInfo;
	    }

	    setInitParams(initParams);
	    setMonitor(initParams);

	    if (initParams.hasOwnProperty('recordPerTime')) {
	      recordMode = 2;
	      setRecordTimer(initParams.recordPerTime);
	    } else {
	      recordMode = 1;
	    } // taskId取值顺序：传参获取（存cookie），为空则判断first是否为1（为1则new一个taskId存cookie），为空则从cookie获取，为空则生成taskId


	    if (initParams.taskId) {
	      taskId = String(initParams.taskId);
	      setSituCookieTaskId(taskId, cookieExpires);
	    } else if (initParams.first === 1) {
	      taskId = generateUUID();
	      setSituCookieTaskId(taskId, cookieExpires);
	    } else {
	      taskId = getSituCookieTaskId();
	    }
	  } else {
	    recordMode = 1;
	  }

	  if (!taskId) {
	    taskId = generateUUID();
	    setSituCookieTaskId(taskId, cookieExpires);
	  }

	  recordCanvasToBase64 = initParams && initParams.recordCanvasToBase64;

	  if (recordCanvasToBase64) {
	    clause.observe();
	    handleRecordCanvasToBase64(initParams.recordCanvasToBase64Options || {});
	  }

	  startRecording(initParams);
	  console.log('[ST Info]:录制开始'); // todo 调试用
	  // autoDot = true

	  autoDot && setOperationMonitor();
	  return {
	    code: 10000,
	    msg: '成功',
	    result: {
	      taskId: taskId
	    }
	  };
	}
	/**
	 * 校验初始化参数
	 * @param {Object} initParams 初始化参数
	 */


	function validateInitParams(initParams) {
	  if (initParams instanceof Object) {
	    if (initParams.hasOwnProperty('baseUrl') && typeof initParams.baseUrl !== 'string' || initParams.hasOwnProperty('publicKey') && typeof initParams.publicKey !== 'string' || initParams.hasOwnProperty('cookieExpires') && (isNaN(parseInt(initParams.cookieExpires)) || initParams.cookieExpires <= limit_cookieExpires) || initParams.hasOwnProperty('timeout') && (isNaN(parseInt(initParams.timeout)) || initParams.timeout < limit_timeout) || initParams.hasOwnProperty('videoMaxSize') && (isNaN(parseInt(initParams.videoMaxSize)) || initParams.videoMaxSize < limit_videoMaxSize) || initParams.hasOwnProperty('recordPerTime') && (isNaN(parseInt(initParams.recordPerTime)) || initParams.recordPerTime < limit_recordPerTime) || initParams.hasOwnProperty('first') && isNaN(parseInt(initParams.first)) || initParams.hasOwnProperty('taskId') && typeof initParams.taskId !== 'string' || initParams.taskId === 'null' || initParams.taskId === 'undefined' || initParams.hasOwnProperty('autoDot') && typeof initParams.autoDot !== 'boolean' || initParams.hasOwnProperty('encodeType') && isNaN(parseInt(initParams.encodeType))) {
	      return {
	        code: 20001,
	        msg: '参数错误'
	      };
	    } else {
	      return {
	        code: 10000,
	        msg: '参数校验成功'
	      };
	    }
	  }

	  return {
	    code: 20001,
	    msg: '参数错误'
	  };
	}
	/**
	 * 设置初始化参数
	 * @param {Object} initParams 初始化参数
	 */


	function setInitParams(initParams) {
	  if (initParams && initParams instanceof Object) {
	    publicKey = initParams.publicKey || default_publicKey;

	    if (initParams.baseUrl) {
	      baseUrl = '#situ_user_define#' + initParams.baseUrl;
	    } else {
	      baseUrl = default_baseUrl;
	    }

	    timeout = initParams.timeout || default_timeout;
	    maxSize = initParams.videoMaxSize * 1024 * 1024 || default_maxSize;
	    cookieExpires = initParams.cookieExpires || default_cookieExpires;
	    autoDot = initParams.autoDot || false;
	    encodeMode = initParams.encodeType || default_encode_mode; // 华安定制，env参数未向外暴露

	    if (initParams.hasOwnProperty('env')) {
	      baseUrl = initParams.env === 'prd' ? default_prod_baseUrl : default_dev_baseUrl;
	    } // 光大定制，signature参数表示光大两版sdk是否合并，true开启签字模式，false关闭签字模式


	    if (initParams.hasOwnProperty('signature') && !!initParams.signature) {
	      gdym_signature = true;
	    }
	  }
	}

	var taskId_cookie_key = "taskId_cookie";
	var taskId_session_key = "situ_taskId";
	/**
	 * 获取cookie二级域名的domain设置
	 */

	function getCookieDomainSetting() {
	  var arr = document.domain.split(':');
	  arr = arr[0].split('.');

	  if (arr.length > 2 && isNaN(Number(arr[arr.length - 1]))) {
	    return "domain=.".concat(arr[arr.length - 2] + '.' + arr[arr.length - 1]);
	  }

	  return '';
	}
	/**
	 * 设置situ cookie
	 * @param {string} taskId 任务ID
	 */


	function setSituCookieTaskId(_taskId, _cookieExpires) {
	  /**
	   * 获取cookie二级域名的domain设置
	   */
	  // function getCookieDomainSetting() {
	  //   let arr = document.domain.split(':')
	  //   arr = arr[0].split('.')
	  //   if (arr.length > 2 && isNaN(Number(arr[arr.length - 1]))) {
	  //     return `domain=.${arr[arr.length - 2] + '.' + arr[arr.length - 1]}`
	  //   }
	  //   return ''
	  // }
	  // console.log('cookie 中设置的 taskId：', taskId)
	  taskId = _taskId || generateUUID();
	  document.cookie = "".concat(taskId_cookie_key, "=").concat(taskId, "; expires=").concat(new Date(_cookieExpires).toUTCString(), "; path=/; ").concat(getCookieDomainSetting());
	  sessionStorage.setItem(taskId_session_key, String(taskId));
	}
	/**
	 * 从cookie中获取taskId
	 */


	function getSituCookieTaskId() {
	  var task_id = '';
	  var cookieArr = document.cookie.split('; ');
	  cookieArr.find(function (item) {
	    var arr = item.split('=');
	    var prefix = arr[0] || '';

	    if (prefix === taskId_cookie_key && arr[1]) {
	      // console.log('cookie 中存储的 taskId：', arr[1])
	      task_id = arr[1];
	      return true;
	    }
	  });
	  return task_id;
	}
	/**
	 * 清除situ cookie
	 */


	function clearSituCookie() {
	  document.cookie = "".concat(taskId_cookie_key, "=; expires=").concat(new Date(getTimestamp() - 1).toUTCString(), "; path=/; ").concat(getCookieDomainSetting());
	}
	/**
	 * 移除SessionStorage中存储的taskId
	 */


	function clearSituSessionStorage() {
	  sessionStorage.removeItem(taskId_session_key);
	}
	/**
	 * 生成taskId，保持taskId一直有值
	 */


	function generateTaskId() {
	  var _taskId = getSituCookieTaskId();

	  if (!_taskId) {
	    _taskId = generateUUID();
	    setSituCookieTaskId(_taskId, cookieExpires);
	  }

	  return _taskId;
	}
	/**
	 * 设置录制监听器，超时、超容量限制等则自动上传
	 * @param {Object} initParams 初始化参数
	 */


	function setMonitor(initParams) {
	  if (initParams instanceof Object) {
	    initParams.timeout >= default_timeout && setTimerMonitor();
	    initParams.videoMaxSize * 1024 * 1024 >= default_maxSize && setVideoSizeMonitor();
	  }
	}
	/**
	 * 设置超时监听，自动上传
	 */


	var timeout_timer;

	function setTimerMonitor() {
	  timeout_timer = setTimeout(function () {
	    // console.log('时间片超时，上传录制结果')
	    stopRecord({
	      last: 0
	    }).then(function (res) {
	      if (res.code === 10000) {
	        clearTimeout(timeout_timer);
	        isRecording && setTimerMonitor();
	      }
	    });
	  }, timeout * 1000);
	}
	/**
	 * 设置容量超过限制监听，自动上传
	 */


	var videoSize_timer;

	function setVideoSizeMonitor() {
	  videoSize_timer = setInterval(function () {
	    var temp_events_length = JSON.stringify(temp_events).length;

	    if (temp_events_length >= maxSize) {
	      // console.log('录制容量超过限制，上传录制结果')
	      stopRecord({
	        last: 0
	      }).then(function (res) {
	        if (res.code === 10000) {
	          clearInterval(videoSize_timer);
	          isRecording && setVideoSizeMonitor();
	        }
	      });
	    }
	  }, 5000);
	}
	/**
	 * 定时录制
	 * @param {number} sliceTime 时间片，单位：秒
	 */


	var slice_timer;

	function setRecordTimer(sliceTime) {
	  slice_timer = setInterval(function () {
	    stopRecord({
	      taskId: taskId,
	      last: 0
	    });
	  }, sliceTime * 1000);
	}
	/**
	 * 自动打点日志
	 * 1、页面加载及导航（前进、后退、go）监控
	 * 2、按钮
	 * 3、输入框
	 * 4、单选
	 * 5、复选
	 * 6、下拉框
	 */


	function setOperationMonitor() {
	  // 页面监听
	  handleStPageLoad();
	  location.href.indexOf('#') > -1 ? window.addEventListener('hashchange', handleStPageLoad) : window.addEventListener('popstate', handleStPageLoad); // 按钮监听

	  var btnArr = document.querySelectorAll('button');
	  btnArr.forEach(function (btn) {
	    btn.addEventListener('click', handleStBtnClick);
	  });
	  var inputBtnArr = document.querySelectorAll('input[type="button"]');
	  inputBtnArr.forEach(function (btn) {
	    btn.addEventListener('click', handleStBtnClick);
	  }); // 输入框监听

	  var inputTextArr = document.querySelectorAll('input[type="text"]');
	  inputTextArr.forEach(function (text) {
	    text.addEventListener('blur', handleStInput);
	  });
	  var inputTextAreaArr = document.querySelectorAll('input[type="textarea"]');
	  inputTextAreaArr.forEach(function (textarea) {
	    textarea.addEventListener('blur', handleStInput);
	  });
	  var textAreaArr = document.querySelectorAll('textarea');
	  textAreaArr.forEach(function (textarea) {
	    textarea.addEventListener('blur', handleStInput);
	  }); // radio监听

	  var radioArr = document.querySelectorAll('input[type="radio"]');
	  radioArr.forEach(function (radio) {
	    radio.addEventListener('click', handleStRadioClick);
	  }); // checkbox监听

	  var checkboxArr = document.querySelectorAll('input[type="checkbox"]');
	  checkboxArr.forEach(function (checkbox) {
	    checkbox.addEventListener('change', handleStCheckboxChange);
	  }); // 下拉框监听

	  var selectArr = document.querySelectorAll('select');
	  selectArr.forEach(function (checkbox) {
	    checkbox.addEventListener('change', handleStSelectChange);
	  });
	}
	/**
	 * 页面装载辅助类
	 * @param {Event} event
	 */


	function handleStPageLoad() {
	  var data = {
	    type: load_page,
	    description: "\u8F7D\u5165\u9875\u9762 ".concat(document.title)
	  };
	  createOperation(data);
	}
	/**
	 * 按钮点击辅助类
	 */


	function handleStBtnClick(event) {
	  var data = {
	    type: click_button,
	    description: "\u70B9\u51FB\u6309\u94AE ".concat(event.target.innerText || '')
	  };
	  createOperation(data);
	}
	/**
	 * radio点击辅助类
	 */


	function handleStRadioClick(event) {
	  var data = {
	    type: click_select,
	    description: "\u70B9\u51FB\u5355\u9009 ".concat(event.target.innerText || '')
	  };
	  createOperation(data);
	}
	/**
	 * input输入框辅助类
	 */


	function handleStInput() {
	  var data = {
	    type: click_enter,
	    description: "\u7528\u6237\u8F93\u5165"
	  };
	  createOperation(data);
	}
	/**
	 * checkbox点击辅助类
	 */


	function handleStCheckboxChange(event) {
	  var _isChecked = event.target.checked;
	  var data = {
	    type: click_select,
	    description: "".concat(_isChecked ? '点击' : '取消', "\u590D\u9009 ").concat(event.target.innerText || '')
	  };
	  createOperation(data);
	}
	/**
	 * select选择辅助类
	 */


	function handleStSelectChange(event) {
	  var _options = event.target.options;
	  var _index = _options.selectedIndex;
	  var _selected = _options[_index];
	  var data = {
	    type: click_select,
	    description: "\u4E0B\u62C9\u9009\u62E9 ".concat(_selected.innerText || '')
	  };
	  createOperation(data);
	}
	/**
	 * 移除页面监听
	 */


	function clearEventListener() {
	  // 移除导航监听
	  location.href.indexOf('#') > -1 ? window.removeEventListener('hashchange', handleStPageLoad) : window.removeEventListener('popstate', handleStPageLoad); // 移除按钮监听

	  var btnArr = document.querySelectorAll('button');
	  btnArr.forEach(function (btn) {
	    btn.removeEventListener('click', handleStBtnClick);
	  });
	  var inputBtnArr = document.querySelectorAll('input[type="button"]');
	  inputBtnArr.forEach(function (btn) {
	    btn.removeEventListener('click', handleStBtnClick);
	  }); // 移除输入框监听

	  var inputTextArr = document.querySelectorAll('input[type="text"]');
	  inputTextArr.forEach(function (text) {
	    text.removeEventListener('blur', handleStInput);
	  });
	  var inputTextAreaArr = document.querySelectorAll('input[type="textarea"]');
	  inputTextAreaArr.forEach(function (textarea) {
	    textarea.removeEventListener('blur', handleStInput);
	  });
	  var textAreaArr = document.querySelectorAll('textarea');
	  textAreaArr.forEach(function (textarea) {
	    textarea.removeEventListener('blur', handleStInput);
	  }); // 移除radio监听

	  var radioArr = document.querySelectorAll('input[type="radio"]');
	  radioArr.forEach(function (radio) {
	    radio.removeEventListener('click', handleStRadioClick);
	  }); // checkbox监听

	  var checkboxArr = document.querySelectorAll('input[type="checkbox"]');
	  checkboxArr.forEach(function (checkbox) {
	    checkbox.removeEventListener('change', handleStCheckboxChange);
	  }); // 移除下拉框监听

	  var selectArr = document.querySelectorAll('select');
	  selectArr.forEach(function (checkbox) {
	    checkbox.removeEventListener('change', handleStSelectChange);
	  });
	}
	/**
	 * 拦截Canvas的2D方法，canvas转base64上传
	 */


	var recordCanvasToBase64 = false; // 是否将canvas转为base64

	var recordCanvasToBase64Options = {
	  interval: 250,
	  // canvas变化记录间隔ms
	  uploadInterval: 500,
	  // canvas变化后的上传间隔ms
	  maxSize: 10,
	  // 接口一次性上传canvas的最大数量
	  blockClasses: [],
	  // 排除具有某种样式的canvas元素
	  blockSelectors: [],
	  // 排除具有某种属性的canvas元素
	  retryMaxTimes: 0,
	  // 上传失败重试最大次数，0不重试，默认为0，重试会占用内存，canvans元素多时，请慎重打开
	  maxPdfPages: 20 // 此配置在ios下有效

	};
	var recordCanvasToBase64Timer = -1;
	var recordCanvasToBase64UploadTimer = -1;
	var RECORD_BASE64_UPLOAD_TASKS = [
	  /** 
	  {
	    recordId: '', // 附加的canvas记录id，用来获取元素
	    uuid: '', // 变更时生成的uuid
	    base64: '', // 变更时对应的base64数据
	    status: 'waiting', // 上传状态，waiting=等待上传|uploading=上传中|error=上传失败
	    times: 0, // 调用接口上传次数
	    isNeedClean: false, // 是否需要清理
	  }
	   */
	]; // 清理任务，match=(task) => {}

	function cleanRecordTasks(match) {
	  for (var i = 0; i < RECORD_BASE64_UPLOAD_TASKS.length;) {
	    var task = RECORD_BASE64_UPLOAD_TASKS[i];

	    if (match(task)) {
	      RECORD_BASE64_UPLOAD_TASKS.splice(i, 1);
	    } else {
	      i++;
	    }
	  }
	}

	function cleanRecordTasksByData(data) {
	  for (var i = 0, ilen = data.length; i < ilen; i++) {
	    // 上传成功的任务，如果还在任务池内，标识为清理
	    var uuid = data[i].uuid;

	    for (var j = 0, jlen = RECORD_BASE64_UPLOAD_TASKS.length; j < jlen; j++) {
	      var task = RECORD_BASE64_UPLOAD_TASKS[j];

	      if (task.uuid === uuid) {
	        task.isNeedClean = true;
	        break;
	      }
	    }
	  }

	  cleanRecordTasks(function (item) {
	    return item.isNeedClean;
	  });
	} // 上传canvas转base64


	function uploadRecordBase64() {
	  var data = [];
	  var retryMaxTimes = recordCanvasToBase64Options.retryMaxTimes;

	  for (var i = 0, ilen = RECORD_BASE64_UPLOAD_TASKS.length; i < ilen; i++) {
	    var task = RECORD_BASE64_UPLOAD_TASKS[i];

	    if (task && task.status !== 'uploading' && task.base64) {
	      if (task.times < retryMaxTimes) {
	        // 小于重试次数放进上传数据数组内
	        task.status = 'uploading';
	        task.times = task.times + 1;
	        data.push({
	          uuid: task.uuid,
	          base64: task.base64
	        });
	      } // 大于或等于重试次数，标识需要清理


	      if (task.times >= retryMaxTimes) {
	        task.isNeedClean = true;
	      }
	    }
	  } // 清理掉被标识的任务，释放内存


	  cleanRecordTasks(function (item) {
	    return item.isNeedClean;
	  });

	  if (data.length > 0) {
	    http.post(getBaseUrl(baseUrl) + '/record/recordCanvas', {
	      taskId: taskId,
	      data: data
	    }).then(function (res) {
	      if (res.code !== 10000) {
	        for (var i = 0, ilen = data.length; i < ilen; i++) {
	          // 上传失败的任务，如果还在任务池内，标识为失败
	          var uuid = data[i].uuid;

	          for (var j = 0, jlen = RECORD_BASE64_UPLOAD_TASKS.length; j < jlen; j++) {
	            var task = RECORD_BASE64_UPLOAD_TASKS[j];

	            if (task.uuid === uuid) {
	              task.status = 'error';
	              break;
	            }
	          }
	        }
	      }

	      if (res.code === 10000) {
	        // 上传成功清掉对应的任务
	        cleanRecordTasksByData(data);
	        return {
	          code: 10000,
	          msg: '上传base64成功'
	        };
	      } else if (res.code === 90000) {
	        return {
	          code: 90000,
	          msg: '非法用户'
	        };
	      } else {
	        return {
	          code: 20002,
	          msg: '接口调用失败'
	        };
	      }
	    })["catch"](function (error) {
	      // 这种基本都是接口404，不重试，直接清掉对应的任务
	      cleanRecordTasksByData(data);
	      console.error('[ST Error(上传base64接口调用失败)]:', error);
	      return {
	        code: 20003,
	        msg: '接口调用异常'
	      };
	    });
	  }
	}

	function toDataURL(task, callback) {
	  var canvas = document.querySelector('[data-record-id-ivbor="' + task.recordId + '"]');

	  if (canvas) {
	    try {
	      // 加个try，避免toDataURL报错
	      var uuid = generateUUID();
	      canvas.setAttribute('data-record-base64-uuid', uuid);
	      task.uuid = uuid; // 克隆一个新的canvas再调用toDataURL，避免ios阻塞卡住

	      var cloned = canvas.cloneNode(true);
	      cloned.__recordCloned = true;
	      var ctx = cloned.getContext('2d');
	      ctx.drawImage(canvas, 0, 0);
	      task.base64 = cloned.toDataURL();
	      cloned = null; // 取到base64后，检查任务池内base64有值且status不为uploading的数据，
	      // 如果大于maxSize，马上触发上传，避免一次性上传太多

	      var count = 0;

	      for (var i = 0, ilen = RECORD_BASE64_UPLOAD_TASKS.length; i < ilen; i++) {
	        var item = RECORD_BASE64_UPLOAD_TASKS[i];

	        if (item && item.status !== 'uploading' && item.base64) {
	          count += 1;
	        }
	      }

	      if (count >= recordCanvasToBase64Options.maxSize) {
	        uploadRecordBase64();
	      } // 取到base64后，正常延时上传


	      clearTimeout(recordCanvasToBase64UploadTimer);
	      recordCanvasToBase64UploadTimer = setTimeout(function () {
	        uploadRecordBase64();
	      }, recordCanvasToBase64Options.uploadInterval);
	      callback && callback();
	    } catch (error) {
	      // 如果toDataURL出现异常，清掉此task
	      cleanRecordTasks(function (item) {
	        return item === task;
	      });
	      callback && callback();
	    }
	  } else {
	    // canvas元素如果不存在了，清掉recordId相同且base64为空的task
	    cleanRecordTasks(function (item) {
	      return item.recordId === task.recordId && !item.base64;
	    });
	    callback && callback();
	  }
	} // 连续调用canvas.toDataURL，在ios可能会出现页面卡住，封装使用Promise链的函数进行排队延时调用


	var toDataURLPromise = Promise.resolve();

	function toDataURLAsync(task) {
	  toDataURLPromise = toDataURLPromise.then(function () {
	    return new Promise(function (resolve, reject) {
	      toDataURL(task, function () {
	        if (window.requestIdleCallback) {
	          window.requestIdleCallback(function () {
	            resolve();
	          });
	        } else {
	          window.requestAnimationFrame(function () {
	            resolve();
	          });
	        }
	      });
	    });
	  });
	  return toDataURLPromise;
	} // 判断是否是跳过不录制转换canvas


	function isBlockRecordCanvas(canvas) {
	  var blockClasses = recordCanvasToBase64Options.blockClasses;

	  for (var i = 0, ilen = blockClasses.length; i < ilen; i++) {
	    var item = blockClasses[i];

	    try {
	      if (canvas.classList.contains(item)) {
	        return true;
	      }
	    } catch (error) {// 空函数捕捉异常
	    }
	  }

	  var blockSelectors = recordCanvasToBase64Options.blockSelectors;

	  for (var i = 0, ilen = blockSelectors.length; i < ilen; i++) {
	    var item = blockSelectors[i];

	    try {
	      if (canvas.matches(item)) {
	        return true;
	      }
	    } catch (error) {// 空函数捕捉异常
	    }
	  }

	  return false;
	} // 部分iphone手机条款pdf过大时，转换base64会导致页面出现白屏
	// 增加判断，超过recordCanvasToBase64Options.maxPdfPages时iphone下不执行转换
	// 在可回溯后台进行视频播放采用抓取pdf文件模拟播放


	function isBlockMaxPdfPages(canvas) {
	  var userAgent = window.navigator.userAgent;
	  var isIos = !!userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
	  var pdfPages = clause.getPdfPages(canvas);

	  if (isIos && pdfPages > recordCanvasToBase64Options.maxPdfPages) {
	    return true;
	  }

	  return false;
	} // 处理canvas转base64


	function handleRecordCanvasToBase64(options) {
	  Object.assign(recordCanvasToBase64Options, options); // data-situ-record-sign是SituRecorderSignPatch.js实现电子签字补丁的属性，需要排除掉

	  var blockSelectors = recordCanvasToBase64Options.blockSelectors;

	  if (blockSelectors.indexOf('[data-situ-record-sign]') === -1) {
	    blockSelectors.push('[data-situ-record-sign]');
	  }

	  clearInterval(recordCanvasToBase64Timer);
	  recordCanvasToBase64Timer = setInterval(function () {
	    window.requestAnimationFrame(function (timestamp) {
	      if (recordCanvasToBase64 && isRecording) {
	        // 过滤出需要录制转换并且有发生变更且未放进过上传任务的的canvas元素
	        var canvases = document.querySelectorAll("canvas");

	        for (var i = 0, ilen = canvases.length; i < ilen; i++) {
	          var canvas = canvases[i]; // 处理需要录制转换，有发生变更且未上传过的canvas

	          if (!isBlockRecordCanvas(canvas) && !isBlockMaxPdfPages(canvas) && canvas.__recordMutationRandom && canvas.__recordMutationRandom !== canvas.__recordUploadRandom) {
	            canvas.__recordUploadRandom = canvas.__recordMutationRandom;
	            var task = {
	              recordId: canvas.__recordId,
	              uuid: '',
	              // 初始为空字符串，后面代码调用toDataURLAsync(task)赋值
	              base64: '',
	              // 初始为空字符串，后面代码调用toDataURLAsync(task)赋值
	              status: 'waiting',
	              times: -1,
	              isNeedClean: false
	            }; // 先清掉recordId相同且base64为空的task，避免重复

	            cleanRecordTasks(function (item) {
	              return item.recordId === task.recordId && !item.base64;
	            }); // 插入任务

	            RECORD_BASE64_UPLOAD_TASKS.push(task); // 赋值uuid、base64

	            toDataURLAsync(task);
	          }
	        }
	      }
	    });
	  }, recordCanvasToBase64Options.interval);

	  if (window._RECORD_INTERCEPT_CANVAS_C344438EB) {
	    return;
	  }

	  var props2D = Object.getOwnPropertyNames(CanvasRenderingContext2D.prototype);

	  for (var i = 0, ilen = props2D.length; i < ilen; i++) {
	    var prop2D = props2D[i];

	    try {
	      (function (attr) {
	        var original = CanvasRenderingContext2D.prototype[attr];
	        var INCLUDE_PROPS_2D = ['clearRect', 'fill', 'fillRect', 'fillText', 'stroke', 'strokeRect', 'strokeText', 'clip', 'drawFocusIfNeeded', 'drawImage', 'putImageData'];

	        if (INCLUDE_PROPS_2D.indexOf(attr) > -1 && typeof original === 'function') {
	          CanvasRenderingContext2D.prototype[attr] = function () {
	            var result = original.apply(this, arguments);
	            var canvas = this.canvas;

	            if (canvas.__recordCloned) {
	              return result;
	            }

	            if (document.documentElement.contains(canvas)) {
	              if (!canvas.__recordId) {
	                // 使用自定义id属性标识canvas
	                canvas.__recordId = generateUUID();
	                canvas.setAttribute('data-record-id-ivbor', canvas.__recordId);
	              } // 记录最新变更的随机数和触发变更的方法


	              canvas.__recordMutationRandom = Math.random();
	              canvas.__recordMutationMethod = attr;
	            }

	            return result;
	          };
	        }
	      })(prop2D);
	    } catch (error) {// 部分属性无法覆盖，空函数捕捉错误
	    }
	  } // 标识是否已经拦截过canvas方法，避免重复拦截


	  window._RECORD_INTERCEPT_CANVAS_C344438EB = true;
	}
	/**
	 * 结束录制
	 * @param {Object} params
	 */


	function stopRecord(_x2, _x3) {
	  return _stopRecord.apply(this, arguments);
	}
	/**
	 * 提交录制信息
	 * @param {*} data 
	 */


	function _stopRecord() {
	  _stopRecord = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, isSkipCheckStop) {
	    var data, orderInfo;
	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            // 时间片模式，最后一个录制清除一切监听，终止录制
	            if (recordMode === 2 && params.last) {
	              clearAllTimer();
	              autoDot && clearEventListener();
	              clause.disconnect();
	            } else if (recordMode === 1) {
	              autoDot && clearEventListener();
	              clause.disconnect();
	            }

	            data = {
	              taskId: taskId || generateTaskId(),
	              timestamp: getTimestamp(),
	              encodeMode: encodeMode
	            };

	            if (params instanceof Object && params.orderInfo instanceof Object) {
	              orderInfo = params.orderInfo;
	              data.orderInfo = {
	                orderId: orderInfo.orderId || '',
	                // 订单ID
	                insuranceNo: orderInfo.insuranceNo || '',
	                // 保单号
	                channel: orderInfo.channel || '',
	                // 渠道
	                businessType: orderInfo.businessType || '',
	                // 业务类型，例如：车险、意外险等
	                platform: orderInfo.platform || '',
	                // 平台：web、微信、小程序、app、H5
	                productName: orderInfo.productName || '',
	                // 产品名称
	                productCode: orderInfo.productCode || '',
	                // 产品编码
	                account: orderInfo.account || '',
	                // 当前客户账号，可能是微信ID、手机号
	                policyHolder: orderInfo.policyHolder || '',
	                // 投保人
	                createTime: orderInfo.createTime || '',
	                // 提交时间，时间戳
	                success: orderInfo.success,
	                // 是否购买成功，0=失败，1=成功
	                agencyName: orderInfo.agencyName || '',
	                // 机构名称
	                agencyCode: orderInfo.agencyCode || '',
	                // 机构编码
	                insureAppliNo: orderInfo.insureAppliNo || '',
	                // 投保单号
	                extraInfo: orderInfo.extraInfo || '' // 额外信息

	              };
	            }

	            data.last = params && params.last === 0 ? 0 : 1;
	            data.isManualCall = params && params.src === 0 || data.last === 1; // 是否为手工调用标志：params.src=0和last=1均为客户手工调用，params.src=1表示自动调用

	            data.urls = urls || [];
	            return _context2.abrupt("return", postRecord(data, isSkipCheckStop));

	          case 7:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));
	  return _stopRecord.apply(this, arguments);
	}

	function postRecord(_x4, _x5) {
	  return _postRecord.apply(this, arguments);
	}
	/**
	 * 获取录制传输额外信息，用以管理平台排查问题
	 * @param {*} data 
	 * @param {*} mode 录制模式：1=整段录制，2=时间片录制
	 * @returns data
	 */


	function _postRecord() {
	  _postRecord = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(data, isSkipCheckStop) {
	    var sortNos, length, arr, arrEvents, _length, _arr;

	    return regeneratorRuntime.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            sortNos = [];

	            if (!(SituWorker && recordMode === 2 && !data.isManualCall)) {
	              _context4.next = 13;
	              break;
	            }

	            length = events.length;
	            arr = events.slice(current_event_index, length);
	            /**
	             * 时间片录制传输增量：无增量，且无订单信息，且last=0，则不调用recording接口
	             */

	            if (!(arr.length === 0 && !data.orderInfo && data.last === 0)) {
	              _context4.next = 6;
	              break;
	            }

	            return _context4.abrupt("return", {
	              code: 10000,
	              msg: '成功'
	            });

	          case 6:
	            /**
	             * 不能传DOM，也不能传大数据（光大签字版的补丁）
	             */
	            if (gdym_signature) {
	              arrEvents = [];
	              arr.forEach(function (element) {
	                var property = element.data.property;

	                if (!property || property !== 'drawImage' && property !== 'putImageData' && property !== 'getImageData') {
	                  arrEvents.push(element);
	                }
	              });
	              arr = arrEvents;
	            }

	            data = getRecordExtraData(data, recordMode);
	            current_event_index = length;
	            temp_events = arr;
	            return _context4.abrupt("return", new Promise(function (resolve) {
	              sortNos = arr.map(function (item) {
	                return item.sortNo;
	              });

	              var onmessage = /*#__PURE__*/function () {
	                var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(event) {
	                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                    while (1) {
	                      switch (_context3.prev = _context3.next) {
	                        case 0:
	                          data.recordInfo = event.data[0];
	                          resolve(doRecording(data, sortNos, isSkipCheckStop));

	                        case 2:
	                        case "end":
	                          return _context3.stop();
	                      }
	                    }
	                  }, _callee3);
	                }));

	                return function onmessage(_x12) {
	                  return _ref2.apply(this, arguments);
	                };
	              }();

	              SituWorkerPostMessage({
	                events: arr,
	                encodeMode: encodeMode
	              }, onmessage);
	            }));

	          case 13:
	            if (!(recordMode === 2)) {
	              _context4.next = 24;
	              break;
	            }

	            _length = events.length;
	            _arr = events.slice(current_event_index, _length);
	            /**
	             * 时间片录制传输增量：无增量，且无订单信息，且last=0，则不调用recording接口
	             */

	            if (!(_arr.length === 0 && !data.orderInfo && data.last === 0)) {
	              _context4.next = 18;
	              break;
	            }

	            return _context4.abrupt("return", {
	              code: 10000,
	              msg: '成功'
	            });

	          case 18:
	            data = getRecordExtraData(data, recordMode);
	            data.recordInfo = encodingHandler(encodeMode, _arr);
	            current_event_index = _length;
	            sortNos = _arr.map(function (item) {
	              return item.sortNo;
	            });
	            _context4.next = 27;
	            break;

	          case 24:
	            data = getRecordExtraData(data, recordMode);
	            data.recordInfo = encodingHandler(encodeMode, events);
	            sortNos = events.map(function (item) {
	              return item.sortNo;
	            });

	          case 27:
	            return _context4.abrupt("return", doRecording(data, sortNos, isSkipCheckStop));

	          case 28:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4);
	  }));
	  return _postRecord.apply(this, arguments);
	}

	function getRecordExtraData(data, mode) {
	  data.index = ++recordNum;
	  data.recordMode = mode;
	  data.last === 1 && (data.total = recordNum);
	  return data;
	}
	/**
	 * 加密逻辑辅助类
	 * @param {Number} mode 录制信息封装模式：1=AES加密，2=明文，3=protobuf，4=JSON序列化明文
	 * @param {Array} data 录制数据
	 * @returns {String|Array} 加密逻辑处理后的录制内容及格式
	 */


	function encodingHandler(mode, data) {
	  var result;

	  switch (mode) {
	    case 2:
	      result = data;
	      break;

	    case 3:
	      // todo protobuf处理逻辑
	      // result = 
	      break;

	    case 4:
	      result = JSON.stringify(data);
	      break;

	    default:
	      try {
	        result = generateSymEncrypt(JSON.stringify(data) || '');
	      } catch (error) {
	        console.error('[ST Error(序列化加密失败)]:', error);
	      }

	  }

	  return result;
	}
	/**
	 * 调用录制接口
	 * @param {*} data 数据
	 * @param {*} sortNos 上传成功需要置空的sortNo数组
	 * @param {*} isSkipCheckStop 是否跳过检查停止录制 
	 */


	function doRecording(_x6, _x7, _x8) {
	  return _doRecording.apply(this, arguments);
	}
	/**
	 * 创建操作记录
	 * @param {Object} params 
	 */


	function _doRecording() {
	  _doRecording = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(data, sortNos, isSkipCheckStop) {
	    var res, i, ilen, item, j;
	    return regeneratorRuntime.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            data.last === 1 && (recordNum = 0);
	            _context5.prev = 1;
	            _context5.next = 4;
	            return http.post(getBaseUrl(baseUrl) + '/record/recording', generateSign(data));

	          case 4:
	            res = _context5.sent;

	            if (!(res.code === 10000)) {
	              _context5.next = 29;
	              break;
	            }

	            if (!isSkipCheckStop && (data.last || recordMode === 1)) {
	              stopRecording();
	              urls = [];
	              events = [];
	              console.log('[ST Info]:录制结束');
	            } // 上传成功后根据sortNo，置空对应的event，释放内存


	            if (!(sortNos.length > 0 && events.length > 0)) {
	              _context5.next = 26;
	              break;
	            }

	            i = 0, ilen = events.length;

	          case 9:
	            if (!(i < ilen)) {
	              _context5.next = 26;
	              break;
	            }

	            item = events[i];

	            if (!item) {
	              _context5.next = 21;
	              break;
	            }

	            j = 0;

	          case 13:
	            if (!(j < sortNos.length)) {
	              _context5.next = 21;
	              break;
	            }

	            if (!(item.sortNo === sortNos[j])) {
	              _context5.next = 18;
	              break;
	            }

	            events[i] = null; // 只置空，不删除，避免影响current_event_index

	            sortNos.splice(1, j);
	            return _context5.abrupt("break", 21);

	          case 18:
	            j++;
	            _context5.next = 13;
	            break;

	          case 21:
	            if (!(sortNos.length === 0)) {
	              _context5.next = 23;
	              break;
	            }

	            return _context5.abrupt("break", 26);

	          case 23:
	            i++;
	            _context5.next = 9;
	            break;

	          case 26:
	            return _context5.abrupt("return", {
	              code: 10000,
	              msg: '成功'
	            });

	          case 29:
	            if (!(res.code === 90000)) {
	              _context5.next = 33;
	              break;
	            }

	            return _context5.abrupt("return", {
	              code: 90000,
	              msg: '非法用户'
	            });

	          case 33:
	            return _context5.abrupt("return", {
	              code: 20002,
	              msg: '接口调用失败'
	            });

	          case 34:
	            _context5.next = 40;
	            break;

	          case 36:
	            _context5.prev = 36;
	            _context5.t0 = _context5["catch"](1);
	            console.error('[ST Error(录制数据上传接口调用失败)]:', _context5.t0);
	            return _context5.abrupt("return", {
	              code: 20003,
	              msg: '接口调用异常'
	            });

	          case 40:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5, null, [[1, 36]]);
	  }));
	  return _doRecording.apply(this, arguments);
	}

	function createOperation(_x9) {
	  return _createOperation.apply(this, arguments);
	}
	/**
	 * 保存资源
	 * @param {Object} params 
	 */


	function _createOperation() {
	  _createOperation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params) {
	    var data, res;
	    return regeneratorRuntime.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            data = {
	              taskId: taskId || generateTaskId(),
	              timestamp: getTimestamp()
	            };

	            if (params instanceof Object) {
	              data.orderId = params.orderId || ''; // 订单ID

	              data.type = params.type || ''; // 操作类型code，INPUT等

	              data.description = params.description || ''; // 客户自定义操作描述
	            }

	            _context6.prev = 2;
	            _context6.next = 5;
	            return http.post(getBaseUrl(baseUrl) + '/record/createOperation', generateSign(data));

	          case 5:
	            res = _context6.sent;

	            if (!(res.code === 10000)) {
	              _context6.next = 10;
	              break;
	            }

	            return _context6.abrupt("return", {
	              code: 10000,
	              msg: '记录操作成功'
	            });

	          case 10:
	            if (!(res.code === 90000)) {
	              _context6.next = 14;
	              break;
	            }

	            return _context6.abrupt("return", {
	              code: 90000,
	              msg: '非法用户'
	            });

	          case 14:
	            return _context6.abrupt("return", {
	              code: 20002,
	              msg: '接口调用失败'
	            });

	          case 15:
	            _context6.next = 21;
	            break;

	          case 17:
	            _context6.prev = 17;
	            _context6.t0 = _context6["catch"](2);
	            console.error('[ST Error(接口调用失败)]:', _context6.t0);
	            return _context6.abrupt("return", {
	              code: 20003,
	              msg: '接口调用异常'
	            });

	          case 21:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, _callee6, null, [[2, 17]]);
	  }));
	  return _createOperation.apply(this, arguments);
	}

	function saveResource(_x10) {
	  return _saveResource.apply(this, arguments);
	}
	/**
	 * 创建订单
	 */


	function _saveResource() {
	  _saveResource = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params) {
	    var data, res;
	    return regeneratorRuntime.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            data = {
	              taskId: params.taskId || taskId,
	              timestamp: getTimestamp()
	            };

	            if (data.taskId) {
	              _context7.next = 3;
	              break;
	            }

	            return _context7.abrupt("return", {
	              code: 20004,
	              msg: '请使用有效的taskId'
	            });

	          case 3:
	            if (!(typeof params.baseUrl === 'string' && params.baseUrl.length > 0 && !(params.baseUrl.indexOf('http://') > -1 || params.baseUrl.indexOf('https://') > -1))) {
	              _context7.next = 5;
	              break;
	            }

	            return _context7.abrupt("return", {
	              code: 20001,
	              msg: '参数错误'
	            });

	          case 5:
	            if (params instanceof Object) {
	              data = Object.assign(params, data);
	            }

	            _context7.prev = 6;
	            _context7.next = 9;
	            return http.post(getBaseUrl(params.baseUrl || baseUrl) + '/record/saveResource', generateSign(data));

	          case 9:
	            res = _context7.sent;

	            if (!(res.code === 10000)) {
	              _context7.next = 14;
	              break;
	            }

	            return _context7.abrupt("return", {
	              code: 10000,
	              msg: '保存资源成功'
	            });

	          case 14:
	            if (!(res.code === 90000)) {
	              _context7.next = 18;
	              break;
	            }

	            return _context7.abrupt("return", {
	              code: 90000,
	              msg: '非法用户'
	            });

	          case 18:
	            return _context7.abrupt("return", {
	              code: 20002,
	              msg: '接口调用失败'
	            });

	          case 19:
	            _context7.next = 25;
	            break;

	          case 21:
	            _context7.prev = 21;
	            _context7.t0 = _context7["catch"](6);
	            console.error('[ST Error(接口调用失败)]:', _context7.t0);
	            return _context7.abrupt("return", {
	              code: 20003,
	              msg: '接口调用异常'
	            });

	          case 25:
	          case "end":
	            return _context7.stop();
	        }
	      }
	    }, _callee7, null, [[6, 21]]);
	  }));
	  return _saveResource.apply(this, arguments);
	}

	function createOrderInfo(_x11) {
	  return _createOrderInfo.apply(this, arguments);
	}
	/**
	 * 更换访问协议
	 * @param {string} url url地址
	 */


	function _createOrderInfo() {
	  _createOrderInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params) {
	    var data, orderInfo, res;
	    return regeneratorRuntime.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            if (!(params instanceof Object && !params.taskId)) {
	              _context8.next = 2;
	              break;
	            }

	            return _context8.abrupt("return", {
	              code: 20001,
	              msg: '参数错误，taskId不能为空'
	            });

	          case 2:
	            data = {
	              taskId: params.taskId || taskId,
	              timestamp: getTimestamp()
	            };

	            if (params instanceof Object && params.orderInfo instanceof Object) {
	              orderInfo = params.orderInfo;
	              data.orderInfo = {
	                orderId: orderInfo.orderId || '',
	                // 订单ID
	                insuranceNo: orderInfo.insuranceNo || '',
	                // 保单号
	                channel: orderInfo.channel || '',
	                // 渠道
	                businessType: orderInfo.businessType || '',
	                // 业务类型，例如：车险、意外险等
	                platform: orderInfo.platform || '',
	                // 平台：web、微信、小程序、app、H5
	                productName: orderInfo.productName || '',
	                // 产品名称
	                productCode: orderInfo.productCode || '',
	                // 产品编码
	                account: orderInfo.account || '',
	                // 当前客户账号，可能是微信ID、手机号
	                policyHolder: orderInfo.policyHolder || '',
	                // 投保人
	                createTime: orderInfo.createTime || '',
	                // 提交时间，时间戳
	                success: orderInfo.success,
	                // 是否购买成功，0=失败，1=成功
	                agencyName: orderInfo.agencyName || '',
	                // 机构名称
	                agencyCode: orderInfo.agencyCode || '',
	                // 机构编码
	                insureAppliNo: orderInfo.insureAppliNo || '',
	                // 投保单号
	                extraInfo: orderInfo.extraInfo || '' // 额外信息

	              };
	            }

	            _context8.prev = 4;
	            _context8.next = 7;
	            return http.post(getBaseUrl(baseUrl) + '/record/createOrderInfo', generateSign(data));

	          case 7:
	            res = _context8.sent;

	            if (!(res.code === 10000)) {
	              _context8.next = 12;
	              break;
	            }

	            return _context8.abrupt("return", {
	              code: 10000,
	              msg: '成功'
	            });

	          case 12:
	            if (!(res.code === 90000)) {
	              _context8.next = 16;
	              break;
	            }

	            return _context8.abrupt("return", {
	              code: 90000,
	              msg: '非法用户'
	            });

	          case 16:
	            return _context8.abrupt("return", {
	              code: 20002,
	              msg: '接口调用失败'
	            });

	          case 17:
	            _context8.next = 23;
	            break;

	          case 19:
	            _context8.prev = 19;
	            _context8.t0 = _context8["catch"](4);
	            console.error('[ST Error(创建订单接口调用失败)]:', _context8.t0);
	            return _context8.abrupt("return", {
	              code: 20003,
	              msg: '接口调用异常'
	            });

	          case 23:
	          case "end":
	            return _context8.stop();
	        }
	      }
	    }, _callee8, null, [[4, 19]]);
	  }));
	  return _createOrderInfo.apply(this, arguments);
	}

	function getBaseUrl(url) {
	  if (location) {
	    // 判断客户传输的url地址是否带协议，如有则按用户定义的协议进行访问
	    var protocal = location.protocol;

	    if (url.indexOf('#situ_user_define#') > -1) {
	      var path = '';
	      path = url.replace('#situ_user_define#', '');
	      path = path.indexOf('https://') > -1 || path.indexOf('http://') > -1 ? path : "".concat(protocal, "//").concat(path);
	      return path;
	    } else {
	      var _path = url.replace('https://', '').replace('http://', '');

	      _path = "".concat(protocal, "//").concat(_path);
	      return _path;
	    }
	  } else {
	    return url;
	  }
	}
	/**
	 * 移除所有存储及定时器
	 */


	function clearAllTimer() {
	  clearSituCookie();
	  clearSituSessionStorage();
	  clearTimeout(timeout_timer);
	  clearInterval(videoSize_timer);
	  clearInterval(slice_timer);
	}
	/**
	 * 调用摄像头拍照，仅用于手机移动端
	 * @param {function} cb 回调函数
	 * todo 压缩比率
	 */


	function takeAPhoto(cb) {
	  if (typeof cb !== 'function') {
	    cb({
	      code: 20001,
	      msg: '参数错误'
	    });
	    return;
	  }

	  if (!validateDevice()) {
	    cb({
	      code: 20006,
	      msg: '请使用手机移动端拍照'
	    });
	    return;
	  }

	  var input_dom = document.createElement('input');
	  input_dom.id = 'camera_input';
	  input_dom.type = 'file';
	  input_dom.accept = 'image/*';
	  input_dom.capture = 'user';
	  input_dom.style = 'visibility: hidden;';
	  document.body.appendChild(input_dom);
	  input_dom.addEventListener('change', function () {
	    var file = input_dom.files[0];
	    var reader = new FileReader();

	    reader.onload = function () {
	      var size = Math.floor(file.size / 1024);
	      size = size > 1024 ? "".concat(Math.floor(size / 1024), "M") : "".concat(size, "K");
	      cb({
	        code: 10000,
	        msg: '成功',
	        result: {
	          encode: reader.result,
	          size: size
	        }
	      });
	    };

	    reader.onerror = function () {
	      cb({
	        code: 20007,
	        msg: '读取照片失败',
	        result: reader.error
	      });
	    };

	    if (file) {
	      reader.readAsDataURL(file);
	    }
	  });
	  input_dom.click();
	  console.log('[ST Info]:拍照');
	}
	/**
	 * 校验设备，如为手机移动端则返回true
	 * @returns {Boolean} 是否为手机移动端
	 */


	function validateDevice() {
	  var platform = navigator.platform.toLowerCase(); // const isIphone = function() {
	  //   return platform.indexOf('iphone') > -1
	  // }
	  // const isIpad = function() {
	  //   return platform.indexOf('ipad') > -1
	  // }

	  var isMac = function isMac() {
	    return platform.indexOf('mac') > -1;
	  };

	  var isWin = function isWin() {
	    return platform.indexOf('win') > -1;
	  }; // const isAndroid = function() {
	  //   return platform.indexOf('android') > -1
	  // }
	  // const isWeixin = function() {
	  //   return navigator.userAgent.indexOf('MicroMessenger') > -1
	  // }


	  if (isMac() || isWin()) {
	    return false;
	  }

	  return true;
	}

	(function () {
	  // 初始化web worker
	  if (window.Worker && !SituWorker) {
	    try {
	      var _CryptoJS_core = "var CryptoJS=CryptoJS||function(h,r){var k={},l=k.lib={},n=function(){},f=l.Base={extend:function(a){n.prototype=this;var b=new n;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\n      j=l.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=r?b:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var e=0;e<a;e++)b[c+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((c+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)b[c+e>>>2]=d[e>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<\n      32-8*(b%4);a.length=h.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],d=0;d<a;d+=4)b.push(4294967296*h.random()|0);return new j.init(b,a)}}),m=k.enc={},s=m.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var e=b[c>>>2]>>>24-8*(c%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,\n      2),16)<<24-4*(c%8);return new j.init(d,b/2)}},p=m.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new j.init(d,b)}},t=m.Utf8={stringify:function(a){try{return decodeURIComponent(escape(p.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return p.parse(unescape(encodeURIComponent(a)))}},\n      q=l.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new j.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=t.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,d=b.words,c=b.sigBytes,e=this.blockSize,f=c/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;c=h.min(4*a,c);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);b.sigBytes-=c}return new j.init(g,c)},clone:function(){var a=f.clone.call(this);\n      a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new u.HMAC.init(a,\n      d)).finalize(b)}}});var u=k.algo={};return k}(Math);";
	      var _CryptoJS_evpkdf = "(function(){var b=CryptoJS,a=b.lib,f=a.Base,k=a.WordArray,a=b.algo,l=a.EvpKDF=f.extend({cfg:f.extend({keySize:4,hasher:a.MD5,iterations:1}),init:function(a){this.cfg=this.cfg.extend(a)},compute:function(a,b){for(var c=this.cfg,d=c.hasher.create(),g=k.create(),f=g.words,h=c.keySize,c=c.iterations;f.length<h;){e&&d.update(e);var e=d.update(a).finalize(b);d.reset();for(var j=1;j<c;j++)e=d.finalize(e),d.reset();g.concat(e)}g.sigBytes=4*h;return g}});b.EvpKDF=function(a,b,c){return l.create(c).compute(a,b)}})();";
	      var _CryptoJS_enc_base64 = "(function(){var h=CryptoJS,j=h.lib.WordArray;h.enc.Base64={stringify:function(b){var e=b.words,f=b.sigBytes,c=this._map;b.clamp();b=[];for(var a=0;a<f;a+=3)for(var d=(e[a>>>2]>>>24-8*(a%4)&255)<<16|(e[a+1>>>2]>>>24-8*((a+1)%4)&255)<<8|e[a+2>>>2]>>>24-8*((a+2)%4)&255,g=0;4>g&&a+0.75*g<f;g++)b.push(c.charAt(d>>>6*(3-g)&63));if(e=c.charAt(64))for(;b.length%4;)b.push(e);return b.join(\"\")},parse:function(b){var e=b.length,f=this._map,c=f.charAt(64);c&&(c=b.indexOf(c),-1!=c&&(e=c));for(var c=[],a=0,d=0;d<\n        e;d++)if(d%4){var g=f.indexOf(b.charAt(d-1))<<2*(d%4),h=f.indexOf(b.charAt(d))>>>6-2*(d%4);c[a>>>2]|=(g|h)<<24-8*(a%4);a++}return j.create(c,a)},_map:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"}})();";
	      var _CryptoJS_cipher = "CryptoJS.lib.Cipher||function(u){var g=CryptoJS,f=g.lib,k=f.Base,l=f.WordArray,q=f.BufferedBlockAlgorithm,r=g.enc.Base64,v=g.algo.EvpKDF,n=f.Cipher=q.extend({cfg:k.extend(),createEncryptor:function(a,b){return this.create(this._ENC_XFORM_MODE,a,b)},createDecryptor:function(a,b){return this.create(this._DEC_XFORM_MODE,a,b)},init:function(a,b,c){this.cfg=this.cfg.extend(c);this._xformMode=a;this._key=b;this.reset()},reset:function(){q.reset.call(this);this._doReset()},process:function(a){this._append(a);\n        return this._process()},finalize:function(a){a&&this._append(a);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(a){return{encrypt:function(b,c,d){return(\"string\"==typeof c?s:j).encrypt(a,b,c,d)},decrypt:function(b,c,d){return(\"string\"==typeof c?s:j).decrypt(a,b,c,d)}}}});f.StreamCipher=n.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var m=g.mode={},t=function(a,b,c){var d=this._iv;d?this._iv=u:d=this._prevBlock;for(var e=\n        0;e<c;e++)a[b+e]^=d[e]},h=(f.BlockCipherMode=k.extend({createEncryptor:function(a,b){return this.Encryptor.create(a,b)},createDecryptor:function(a,b){return this.Decryptor.create(a,b)},init:function(a,b){this._cipher=a;this._iv=b}})).extend();h.Encryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize;t.call(this,a,b,d);c.encryptBlock(a,b);this._prevBlock=a.slice(b,b+d)}});h.Decryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize,e=a.slice(b,b+d);c.decryptBlock(a,\n        b);t.call(this,a,b,d);this._prevBlock=e}});m=m.CBC=h;h=(g.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,e=[],f=0;f<c;f+=4)e.push(d);c=l.create(e,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};f.BlockCipher=n.extend({cfg:n.cfg.extend({mode:m,padding:h}),reset:function(){n.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;\n        this._mode=c.call(a,this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var p=f.CipherParams=k.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),m=(g.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;\n        return(a?l.create([1398893684,1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=l.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return p.create({ciphertext:a,salt:c})}},j=f.SerializableCipher=k.extend({cfg:k.extend({format:m}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var e=a.createEncryptor(c,d);b=e.finalize(b);e=e.cfg;return p.create({ciphertext:b,key:c,iv:e.iv,algorithm:a,mode:e.mode,padding:e.padding,\n        blockSize:a.blockSize,formatter:d.format})},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return\"string\"==typeof a?b.parse(a,this):a}}),g=(g.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=l.random(8));a=v.create({keySize:b+c}).compute(a,d);c=l.create(a.words.slice(b),4*c);a.sigBytes=4*b;return p.create({key:a,iv:c,salt:d})}},s=f.PasswordBasedCipher=j.extend({cfg:j.cfg.extend({kdf:g}),encrypt:function(a,\n        b,c,d){d=this.cfg.extend(d);c=d.kdf.execute(c,a.keySize,a.ivSize);d.iv=c.iv;a=j.encrypt.call(this,a,b,c.key,d);a.mixIn(c);return a},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);c=d.kdf.execute(c,a.keySize,a.ivSize,b.salt);d.iv=c.iv;return j.decrypt.call(this,a,b,c.key,d)}})}();";
	      var _CryptoJS_aes = "(function(){for(var q=CryptoJS,x=q.lib.BlockCipher,r=q.algo,j=[],y=[],z=[],A=[],B=[],C=[],s=[],u=[],v=[],w=[],g=[],k=0;256>k;k++)g[k]=128>k?k<<1:k<<1^283;for(var n=0,l=0,k=0;256>k;k++){var f=l^l<<1^l<<2^l<<3^l<<4,f=f>>>8^f&255^99;j[n]=f;y[f]=n;var t=g[n],D=g[t],E=g[D],b=257*g[f]^16843008*f;z[n]=b<<24|b>>>8;A[n]=b<<16|b>>>16;B[n]=b<<8|b>>>24;C[n]=b;b=16843009*E^65537*D^257*t^16843008*n;s[f]=b<<24|b>>>8;u[f]=b<<16|b>>>16;v[f]=b<<8|b>>>24;w[f]=b;n?(n=t^g[g[g[E^t]]],l^=g[g[l]]):n=l=1}var F=[0,1,2,4,8,\n        16,32,64,128,27,54],r=r.AES=x.extend({_doReset:function(){for(var c=this._key,e=c.words,a=c.sigBytes/4,c=4*((this._nRounds=a+6)+1),b=this._keySchedule=[],h=0;h<c;h++)if(h<a)b[h]=e[h];else{var d=b[h-1];h%a?6<a&&4==h%a&&(d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255]):(d=d<<8|d>>>24,d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255],d^=F[h/a|0]<<24);b[h]=b[h-a]^d}e=this._invKeySchedule=[];for(a=0;a<c;a++)h=c-a,d=a%4?b[h]:b[h-4],e[a]=4>a||4>=h?d:s[j[d>>>24]]^u[j[d>>>16&255]]^v[j[d>>>\n        8&255]]^w[j[d&255]]},encryptBlock:function(c,e){this._doCryptBlock(c,e,this._keySchedule,z,A,B,C,j)},decryptBlock:function(c,e){var a=c[e+1];c[e+1]=c[e+3];c[e+3]=a;this._doCryptBlock(c,e,this._invKeySchedule,s,u,v,w,y);a=c[e+1];c[e+1]=c[e+3];c[e+3]=a},_doCryptBlock:function(c,e,a,b,h,d,j,m){for(var n=this._nRounds,f=c[e]^a[0],g=c[e+1]^a[1],k=c[e+2]^a[2],p=c[e+3]^a[3],l=4,t=1;t<n;t++)var q=b[f>>>24]^h[g>>>16&255]^d[k>>>8&255]^j[p&255]^a[l++],r=b[g>>>24]^h[k>>>16&255]^d[p>>>8&255]^j[f&255]^a[l++],s=\n        b[k>>>24]^h[p>>>16&255]^d[f>>>8&255]^j[g&255]^a[l++],p=b[p>>>24]^h[f>>>16&255]^d[g>>>8&255]^j[k&255]^a[l++],f=q,g=r,k=s;q=(m[f>>>24]<<24|m[g>>>16&255]<<16|m[k>>>8&255]<<8|m[p&255])^a[l++];r=(m[g>>>24]<<24|m[k>>>16&255]<<16|m[p>>>8&255]<<8|m[f&255])^a[l++];s=(m[k>>>24]<<24|m[p>>>16&255]<<16|m[f>>>8&255]<<8|m[g&255])^a[l++];p=(m[p>>>24]<<24|m[f>>>16&255]<<16|m[g>>>8&255]<<8|m[k&255])^a[l++];c[e]=q;c[e+1]=r;c[e+2]=s;c[e+3]=p},keySize:8});q.AES=x._createHelper(r)})();";
	      var _CryptoJS_ecb = "CryptoJS.mode.ECB=function(){var a=CryptoJS.lib.BlockCipherMode.extend();a.Encryptor=a.extend({processBlock:function(a,b){this._cipher.encryptBlock(a,b)}});a.Decryptor=a.extend({processBlock:function(a,b){this._cipher.decryptBlock(a,b)}});return a}();"; // const subWorkerStr = `!function(e){"function"==typeof define&&define.amd?define(e):e()}((function(){"use strict";onmessage=function(e){var t,o,r,n=e.data,s=(t=n,o=CryptoJS.enc.Utf8.parse("0ca03a92751282f6ee05f8e6e42020b5"),r=CryptoJS.enc.Utf8.parse(t),CryptoJS.AES.encrypt(r,o,{mode:CryptoJS.mode.ECB,padding:CryptoJS.pad.Pkcs7}).toString());postMessage(s)}}));`

	      var subWorkerStr_new = "!function(e){\"function\"==typeof define&&define.amd?define(e):e()}((function(){\"use strict\";onmessage=function(e){var r=e.data.events,t=function(e,r){var t;switch(e){case 2:t=r;break;case 3:break;case 4:t=JSON.stringify(r);break;default:try{t=function(e){var r=CryptoJS.enc.Utf8.parse(\"0ca03a92751282f6ee05f8e6e42020b5\"),t=CryptoJS.enc.Utf8.parse(e);return CryptoJS.AES.encrypt(t,r,{mode:CryptoJS.mode.ECB,padding:CryptoJS.pad.Pkcs7}).toString()}(JSON.stringify(r)||\"\")}catch(e){console.error(\"[ST Error(\u5E8F\u5217\u5316\u52A0\u5BC6\u5931\u8D25)]:\",e)}}return t}(e.data.encodeMode,r);postMessage([t,e.data._uuId])}}));"; // const workerUrl = URL.createObjectURL(new Blob([_CryptoJS_core + _CryptoJS_evpkdf + _CryptoJS_enc_base64 + _CryptoJS_cipher + _CryptoJS_aes + _CryptoJS_ecb + subWorkerStr]))

	      var workerUrl = URL.createObjectURL(new Blob([_CryptoJS_core + _CryptoJS_evpkdf + _CryptoJS_enc_base64 + _CryptoJS_cipher + _CryptoJS_aes + _CryptoJS_ecb + subWorkerStr_new]));
	      SituWorker = new Worker(workerUrl);

	      SituWorker.onerror = function (error) {
	        console.error('[ST Error(SituWorker运行异常)]:', "\u7B2C".concat(error.lineno, "\u884C\uFF0C\u5F02\u5E38\u4FE1\u606F\uFF1A"), error.message);
	      }; // 二次封装SituWorker.postMessage，避免SituWorker.onmessage覆盖
	      // 不允许直接使用SituWorker.postMessage、SituWorker.onmessage


	      var onmessages = {};

	      SituWorkerPostMessage = function SituWorkerPostMessage(message, onmessage) {
	        message._uuId = String(Math.random()).replace('.', '');
	        onmessages[message._uuId] = onmessage;
	        SituWorker.postMessage(message);
	      };

	      SituWorker.onmessage = function (event) {
	        var data = event.data;
	        var onmessage = onmessages[data[1]];
	        onmessages[data[1]] = null;
	        delete onmessages[data[1]];
	        onmessage(event);
	      };
	    } catch (error) {
	      console.error('[ST Error(worker创建失败，采用传统定时录制)]:', error);
	    }
	  }
	})();

	var SituRecorder = {
	  startRecord: startRecord,
	  stopRecord: stopRecord,
	  createOperation: createOperation,
	  saveResource: saveResource,
	  takeAPhoto: takeAPhoto,
	  createOrderInfo: createOrderInfo,
	  http: http
	};

	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = SituRecorder;
	} else {
	  if (typeof define === 'function' && define.amd) {
	    define([], function () {
	      return SituRecorder;
	    });
	  } else {
	    window.SituRecorder = SituRecorder;
	  }
	}

	return SituRecorder;

}));
